# ============================================
# CI/CD Pipeline - Build and Deploy
# ============================================
# WHY GitHub Actions?
# - Native GitHub integration
# - Free for public repos
# - Easy to configure with YAML
# - Supports OIDC for secure AWS auth
#
# INTERVIEW TIP: "We use GitHub Actions for CI/CD because
# it integrates directly with our repo. On every push to main,
# we build the image, push to ECR, and deploy to EKS automatically."

name: CI/CD Pipeline

on:
  push:
    branches: [main, master]
    paths:
      - 'app/**'
      - 'helm/**'
      - '.github/workflows/ci-cd.yaml'
  pull_request:
    branches: [main, master]
  workflow_dispatch:  # Manual trigger

# ============================================
# Environment Variables
# ============================================
env:
  AWS_REGION: eu-west-1
  ECR_REPOSITORY: hello-flask-app
  EKS_CLUSTER_NAME: hello-flask-cluster

jobs:
  # ============================================
  # Job 1: Build and Push Docker Image
  # ============================================
  build:
    name: Build & Push
    runs-on: ubuntu-latest
    
    # Required for OIDC authentication
    permissions:
      id-token: write
      contents: read
    
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
    
    steps:
      # ============================================
      # Checkout Code
      # ============================================
      - name: Checkout code
        uses: actions/checkout@v4
      
      # ============================================
      # Configure AWS Credentials (OIDC)
      # ============================================
      # WHY OIDC?
      # - No long-lived credentials stored in GitHub
      # - More secure than access keys
      # - Follows AWS best practices
      #
      # INTERVIEW TIP: "We use OIDC federation instead of
      # storing AWS access keys. GitHub exchanges its JWT
      # for temporary AWS credentials with limited scope."
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      # ============================================
      # Login to ECR
      # ============================================
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      # ============================================
      # Build, Tag, and Push Docker Image
      # ============================================
      - name: Build and push Docker image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build image
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./app
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest ./app
          
          # Push both tags
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # Output image tag for deploy job
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "‚úÖ Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

  # ============================================
  # Job 2: Deploy to EKS
  # ============================================
  deploy:
    name: Deploy to EKS
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'  # Only deploy on push/merge
    
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      # ============================================
      # Update kubeconfig
      # ============================================
      # This configures kubectl to talk to our EKS cluster
      
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
          kubectl get nodes  # Verify connection
      
      # ============================================
      # Install Helm
      # ============================================
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.12.0
      
      # ============================================
      # Deploy with Helm
      # ============================================
      # WHY Helm for deployment?
      # - Templating for different environments
      # - Easy rollback with helm rollback
      # - Tracks release history
      
      - name: Deploy with Helm
        env:
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
        run: |
          helm upgrade --install hello-flask ./helm/hello-flask \
            --namespace default \
            --set image.repository=$ECR_REGISTRY/$ECR_REPOSITORY \
            --set image.tag=$IMAGE_TAG \
            --wait \
            --timeout 300s
          
          echo "‚úÖ Deployment successful!"
      
      # ============================================
      # Verify Deployment
      # ============================================
      - name: Verify deployment
        run: |
          kubectl rollout status deployment/hello-flask -n default
          kubectl get pods -n default -l app=hello-flask
          
          # Get the LoadBalancer URL
          echo "üåê LoadBalancer URL:"
          kubectl get svc hello-flask -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
      
      # ============================================
      # Smoke Test
      # ============================================
      - name: Smoke test
        run: |
          # Wait for LoadBalancer to be ready
          sleep 60
          
          # Get the endpoint
          ENDPOINT=$(kubectl get svc hello-flask -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          # Test health endpoint
          echo "Testing health endpoint..."
          curl -f http://$ENDPOINT/health || exit 1
          
          echo "‚úÖ Smoke test passed!"
