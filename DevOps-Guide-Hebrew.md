צריך <div dir="rtl" align="right">

# 📘 מדריך DevOps מקיף - הכנה לראיון עבודה

## פרויקט Rick and Morty API - מהקוד ועד לענן

---

# מבוא

מדריך זה נכתב עבור מי שמתכונן לראיון עבודה בתחום ה-DevOps.
המדריך עוקב אחרי פרויקט אמיתי, צעד אחר צעד, ומסביר כל מושג בצורה פשוטה.

**מה תלמד במדריך זה:**
- מה זה API ואיך עובדים איתו
- איך כותבים סקריפט ב-Python
- מה זה Docker ולמה הוא חשוב
- מה זה Kubernetes ואיך משתמשים בו
- מושגים שמראיינים אוהבים לשאול עליהם

---

# פרק 1: הבנת המשימה

## 1.1 מה התבקשנו לעשות?

קיבלנו תרגיל בית עם הדרישות הבאות:

**משימות חובה:**
1. לכתוב סקריפט שקורא נתונים מ-API
2. לסנן את הנתונים לפי קריטריונים מסוימים
3. לשמור את התוצאות לקובץ CSV
4. להעלות את הקוד ל-GitHub

**משימות בונוס:**
5. להפוך את הסקריפט לשירות עם Docker
6. לפרוס את השירות ב-Kubernetes
7. ליצור Helm Chart
8. לבנות CI/CD Pipeline

## 1.2 למה דווקא המשימות האלה?

המשימות האלה מייצגות את **מחזור החיים המלא** של אפליקציה:

</div>

```
קוד ← בדיקה ← אריזה ← פריסה ← ניטור
Code → Test → Package → Deploy → Monitor
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "תאר את מחזור החיים של אפליקציה מהפיתוח ועד הפרודקשן"

**תשובה טובה:** "האפליקציה עוברת מספר שלבים: כתיבת קוד, בדיקות אוטומטיות, אריזה לקונטיינר עם Docker, פריסה לסביבת Kubernetes, וניטור מתמשך. כל שלב מנוהל על ידי Pipeline אוטומטי."

---

# פרק 2: מה זה API?

## 2.1 הגדרה פשוטה

**API** (Application Programming Interface) = ממשק תכנות יישומים

בפשטות: זו הדרך שבה תוכנות מדברות אחת עם השנייה.

**דוגמה מהחיים:**
כשאתה מזמין אוכל דרך אפליקציה, האפליקציה שולחת בקשה ל-API של המסעדה.
ה-API מחזיר את התפריט, המחירים, וזמני המשלוח.

## 2.2 מה זה REST API?

**REST** (Representational State Transfer) = סגנון ארכיטקטוני לבניית API

**עקרונות REST:**

| עיקרון | הסבר |
|--------|------|
| Stateless | כל בקשה עומדת בפני עצמה |
| Client-Server | הפרדה בין הלקוח לשרת |
| Uniform Interface | ממשק אחיד ועקבי |
| Cacheable | ניתן לשמור תשובות במטמון |

## 2.3 שיטות HTTP

**שאלת ראיון נפוצה:** "מה ההבדל בין GET ל-POST?"

</div>

```
┌──────────┬────────────────────────────────────────┐
│  Method  │  שימוש                                 │
├──────────┼────────────────────────────────────────┤
│  GET     │  קבלת מידע (קריאה בלבד)              │
│  POST    │  יצירת משאב חדש                       │
│  PUT     │  עדכון משאב קיים (מחליף לגמרי)       │
│  PATCH   │  עדכון חלקי של משאב                  │
│  DELETE  │  מחיקת משאב                          │
└──────────┴────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 2.4 קודי תגובה HTTP

**שאלת ראיון נפוצה:** "מה המשמעות של קוד 404? ומה 500?"

</div>

```
┌──────────┬────────────────────────────────────────┐
│  קוד     │  משמעות                               │
├──────────┼────────────────────────────────────────┤
│  200     │  OK - הבקשה הצליחה                    │
│  201     │  Created - נוצר משאב חדש              │
│  400     │  Bad Request - בקשה שגויה            │
│  401     │  Unauthorized - לא מורשה             │
│  403     │  Forbidden - אסור (גם עם הרשאה)      │
│  404     │  Not Found - המשאב לא נמצא           │
│  500     │  Internal Server Error - שגיאת שרת   │
│  502     │  Bad Gateway - שגיאה בשרת ביניים     │
│  503     │  Service Unavailable - השירות לא זמין│
└──────────┴────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 2.5 ה-API שעבדנו איתו

**כתובת ה-API:** `https://rickandmortyapi.com/api/character`

**מה מקבלים בתגובה:**

</div>

```json
{
  "info": {
    "count": 826,
    "pages": 42,
    "next": "https://rickandmortyapi.com/api/character?page=2",
    "prev": null
  },
  "results": [
    {
      "id": 1,
      "name": "Rick Sanchez",
      "status": "Alive",
      "species": "Human",
      "origin": {
        "name": "Earth (C-137)"
      },
      "location": {
        "name": "Citadel of Ricks"
      },
      "image": "https://rickandmortyapi.com/api/character/avatar/1.jpeg"
    }
  ]
}
```

<div dir="rtl" align="right">

---

# פרק 3: כתיבת הסקריפט ב-Python

## 3.1 מה זה Python?

Python היא שפת תכנות פופולרית מאוד בעולם ה-DevOps בגלל:
- קלה ללמידה
- ספריות רבות (libraries)
- מתאימה לאוטומציה
- קהילה גדולה

## 3.2 מה זה Pagination?

**שאלת ראיון נפוצה:** "איך מטפלים ב-API שמחזיר הרבה נתונים?"

**Pagination** = חלוקת נתונים לעמודים

**למה צריך?**
- ה-API שלנו מחזיר 826 דמויות
- לא הגיוני להחזיר הכל בבקשה אחת
- לכן ה-API מחזיר 20 דמויות בכל עמוד = 42 עמודים

**איך מטפלים?**

</div>

```
בקשה ראשונה:
GET /character?page=1
    ↓
תגובה: 20 דמויות + לינק לעמוד הבא
    ↓
בקשה שנייה:
GET /character?page=2
    ↓
תגובה: 20 דמויות + לינק לעמוד הבא
    ↓
... וכך הלאה עד עמוד 42
```

<div dir="rtl" align="right">

## 3.3 הקוד שכתבנו - הסבר מלא

**קובץ: main.py**

</div>

```python
#!/usr/bin/env python3
"""
סקריפט לשליפת דמויות מ-Rick and Morty API
"""

# ייבוא ספריות
import requests  # לשליחת בקשות HTTP
import csv       # לכתיבה לקובץ CSV

# כתובת ה-API
API_BASE_URL = "https://rickandmortyapi.com/api/character"


def fetch_all_characters():
    """
    שולף את כל הדמויות מה-API.
    מטפל ב-Pagination אוטומטית.
    """
    all_characters = []  # רשימה ריקה לאחסון כל הדמויות
    url = API_BASE_URL   # מתחילים מהעמוד הראשון
    
    while url:  # כל עוד יש עמוד הבא
        response = requests.get(url)  # שולחים בקשת GET
        response.raise_for_status()   # אם יש שגיאה - זורקים exception
        data = response.json()        # ממירים את התגובה ל-JSON
        
        all_characters.extend(data['results'])  # מוסיפים את הדמויות לרשימה
        url = data['info']['next']  # מעדכנים ל-URL הבא (או None אם נגמר)
    
    return all_characters


def filter_characters(characters):
    """
    מסנן דמויות לפי הקריטריונים:
    - species = Human (אנושי)
    - status = Alive (חי)
    - origin = Earth (מכדור הארץ)
    """
    filtered = []
    
    for char in characters:
        # בודקים כל קריטריון
        is_human = char['species'] == 'Human'
        is_alive = char['status'] == 'Alive'
        is_from_earth = 'Earth' in char['origin']['name']
        
        # אם כל התנאים מתקיימים
        if is_human and is_alive and is_from_earth:
            filtered.append({
                'Name': char['name'],
                'Location': char['location']['name'],
                'Image': char['image']
            })
    
    return filtered


def write_to_csv(characters, filename='output.csv'):
    """
    כותב את הדמויות לקובץ CSV.
    """
    with open(filename, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=['Name', 'Location', 'Image'])
        writer.writeheader()  # כותב את כותרות העמודות
        writer.writerows(characters)  # כותב את כל השורות
    
    print(f"נכתבו {len(characters)} דמויות לקובץ {filename}")


def main():
    """
    הפונקציה הראשית - מריצה את כל התהליך.
    """
    print("שולף דמויות מה-API...")
    
    # שלב 1: שליפת כל הדמויות
    all_characters = fetch_all_characters()
    print(f"סה״כ דמויות: {len(all_characters)}")
    
    # שלב 2: סינון
    filtered = filter_characters(all_characters)
    print(f"דמויות שעברו סינון: {len(filtered)}")
    
    # שלב 3: כתיבה לקובץ
    write_to_csv(filtered)


# נקודת הכניסה לתוכנית
if __name__ == "__main__":
    main()
```

<div dir="rtl" align="right">

## 3.4 מושגים חשובים בקוד

**שאלת ראיון נפוצה:** "מה זה `if __name__ == "__main__"`?"

**תשובה:** זה בודק אם הקובץ רץ ישירות (ולא מיובא כמודול).
- אם מריצים `python main.py` → הקוד ב-if ירוץ
- אם עושים `import main` מקובץ אחר → הקוד ב-if לא ירוץ

**שאלת ראיון נפוצה:** "מה ההבדל בין append ל-extend?"

</div>

```python
# append - מוסיף אלמנט אחד
list1 = [1, 2, 3]
list1.append([4, 5])
# תוצאה: [1, 2, 3, [4, 5]]

# extend - מוסיף את האלמנטים של הרשימה
list2 = [1, 2, 3]
list2.extend([4, 5])
# תוצאה: [1, 2, 3, 4, 5]
```

<div dir="rtl" align="right">

---

# פרק 4: מה זה Docker?

## 4.1 הבעיה שלפני Docker

**המצב ההיסטורי:**

</div>

```
מפתח 1:              מפתח 2:              שרת Production:
─────────            ─────────            ────────────────
Python 3.9           Python 3.11          Python 3.8
Windows              Mac                  Linux
Flask 2.0            Flask 3.0            Flask 1.0

        "אצלי זה עובד!" - כולם אומרים
```

<div dir="rtl" align="right">

## 4.2 מה Docker פותר?

**Docker** יוצר "קופסה" (Container) שבתוכה יש את כל מה שהאפליקציה צריכה.

</div>

```
┌─────────────────────────────────────────────────────────┐
│                   Docker Container                       │
│  ┌───────────────────────────────────────────────────┐  │
│  │  מערכת הפעלה (Linux)                              │  │
│  │  Python 3.11                                      │  │
│  │  Flask 3.0                                        │  │
│  │  הקוד שלנו                                        │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                         │
     ┌───────────────────┼───────────────────┐
     ▼                   ▼                   ▼
 Developer           Developer            Server
 (Windows)           (Mac)                (Linux)

              עובד אצל כולם!
```

<div dir="rtl" align="right">

## 4.3 מושגי יסוד ב-Docker

**שאלת ראיון נפוצה:** "מה ההבדל בין Image ל-Container?"

| מושג | הסבר | משל |
|------|------|-----|
| **Image** | תבנית לקריאה בלבד | מתכון לעוגה |
| **Container** | מופע רץ של Image | העוגה עצמה |
| **Dockerfile** | קובץ הוראות לבניית Image | רשימת המצרכים והוראות |
| **Registry** | מאגר לאחסון Images | חנות מתכונים (Docker Hub) |

**שאלת ראיון נפוצה:** "מה ההבדל בין Container ל-Virtual Machine?"

</div>

```
Virtual Machine:                    Container:
────────────────                    ──────────

┌──────────────────┐               ┌──────────────────┐
│   Application    │               │   Application    │
├──────────────────┤               ├──────────────────┤
│   Guest OS       │               │   (No OS!)       │
│   (Full Linux)   │               │                  │
├──────────────────┤               ├──────────────────┤
│   Hypervisor     │               │  Docker Engine   │
├──────────────────┤               ├──────────────────┤
│   Host OS        │               │   Host OS        │
├──────────────────┤               ├──────────────────┤
│   Hardware       │               │   Hardware       │
└──────────────────┘               └──────────────────┘

גודל: GB                           גודל: MB
עלייה: דקות                        עלייה: שניות
```

<div dir="rtl" align="right">

## 4.4 ה-Dockerfile שלנו - שורה אחרי שורה

</div>

```dockerfile
# ═══════════════════════════════════════════════════════════════
# שורה 1: FROM - מאיזו תמונת בסיס להתחיל?
# ═══════════════════════════════════════════════════════════════
FROM python:3.11-slim
# python:3.11-slim = תמונה רשמית של Python גרסה 3.11
# slim = גרסה "רזה" - בלי extras מיותרים (קטנה יותר)

# ═══════════════════════════════════════════════════════════════
# שורה 2: WORKDIR - באיזו תיקייה לעבוד בתוך הקונטיינר?
# ═══════════════════════════════════════════════════════════════
WORKDIR /app
# יוצר תיקייה /app ועובר אליה
# כל הפקודות הבאות יתבצעו מתוך /app

# ═══════════════════════════════════════════════════════════════
# שורה 3-4: התקנת dependencies
# ═══════════════════════════════════════════════════════════════
COPY app/requirements.txt .
# מעתיק את קובץ הדרישות מהמחשב שלנו לתוך הקונטיינר

RUN pip install --no-cache-dir -r requirements.txt
# מתקין את הספריות (Flask, requests)
# --no-cache-dir = לא שומר cache (חוסך מקום)

# ═══════════════════════════════════════════════════════════════
# שורה 5: העתקת הקוד
# ═══════════════════════════════════════════════════════════════
COPY app/ .
# מעתיק את כל התיקייה app/ לתוך /app בקונטיינר

# ═══════════════════════════════════════════════════════════════
# שורה 6: EXPOSE - איזה פורט האפליקציה מאזינה?
# ═══════════════════════════════════════════════════════════════
EXPOSE 5000
# מסמן שהאפליקציה מאזינה על פורט 5000
# הערה: זה רק תיעוד! לא באמת פותח פורט

# ═══════════════════════════════════════════════════════════════
# שורה 7: CMD - מה להריץ כשהקונטיינר עולה?
# ═══════════════════════════════════════════════════════════════
CMD ["python", "api.py"]
# מריץ את הפקודה: python api.py
```

<div dir="rtl" align="right">

## 4.5 Docker Layer Caching

**שאלת ראיון נפוצה:** "למה חשוב סדר הפקודות ב-Dockerfile?"

כל שורה ב-Dockerfile יוצרת **Layer** (שכבה).
Docker שומר את השכבות במטמון.
אם שכבה לא השתנתה, Docker משתמש בגרסה השמורה.

**למה קודם מעתיקים requirements.txt ורק אחר כך את הקוד?**

</div>

```
Build ראשון:                    Build שני (שינוי בקוד):
────────────                    ────────────────────────

Layer 1: FROM python      →    Layer 1: FROM python      [CACHED]
Layer 2: COPY requirements →   Layer 2: COPY requirements [CACHED]
Layer 3: RUN pip install  →    Layer 3: RUN pip install  [CACHED]
Layer 4: COPY app/        →    Layer 4: COPY app/        [REBUILD]
Layer 5: CMD              →    Layer 5: CMD              [REBUILD]

זמן: 60 שניות                   זמן: 5 שניות!
```

<div dir="rtl" align="right">

אם היינו מעתיקים קודם את הקוד, כל שינוי קטן היה גורם להתקנה מחדש של כל הספריות!

## 4.6 פקודות Docker חיוניות

**שאלת ראיון נפוצה:** "תראה לי את פקודות Docker הבסיסיות"

</div>

```bash
# ═══════════════════════════════════════════════════════════════
# בניית Image
# ═══════════════════════════════════════════════════════════════
docker build -t rick-morty-api .
#        │    └─────────────────┘ └┘
#        │           שם             הקובץ נמצא בתיקייה הנוכחית
#        └── build = בנה image

# ═══════════════════════════════════════════════════════════════
# הרצת Container
# ═══════════════════════════════════════════════════════════════
docker run -d -p 5000:5000 --name my-api rick-morty-api
#          │  └──────────┘ └──────────┘ └─────────────┘
#          │  port mapping   שם          שם ה-image
#          │  host:container
#          └── detached (ברקע)

# ═══════════════════════════════════════════════════════════════
# הצגת Containers רצים
# ═══════════════════════════════════════════════════════════════
docker ps
# מציג רק containers פעילים

docker ps -a
# מציג את כל ה-containers (גם עצורים)

# ═══════════════════════════════════════════════════════════════
# צפייה בלוגים
# ═══════════════════════════════════════════════════════════════
docker logs my-api
# מציג את הלוגים של הקונטיינר

docker logs -f my-api
# מציג לוגים בזמן אמת (follow)

# ═══════════════════════════════════════════════════════════════
# כניסה לתוך Container
# ═══════════════════════════════════════════════════════════════
docker exec -it my-api /bin/bash
#           │││
#           │└┴── interactive + tty (טרמינל אינטראקטיבי)
#           └── execute = הרץ פקודה

# ═══════════════════════════════════════════════════════════════
# עצירה ומחיקה
# ═══════════════════════════════════════════════════════════════
docker stop my-api     # עוצר את הקונטיינר
docker rm my-api       # מוחק את הקונטיינר
docker rmi rick-morty-api  # מוחק את ה-image
```

<div dir="rtl" align="right">

---

# פרק 5: מה זה Kubernetes?

## 5.1 למה צריך Kubernetes?

**המצב עם Docker בלבד:**

</div>

```
┌─────────────────┐
│   Container     │  ← אם נופל - אף אחד לא מרים אותו
│   rick-morty    │  ← אם יש עומס - אין אפשרות להוסיף עותקים
│                 │  ← אין חלוקת עומסים
└─────────────────┘
```

<div dir="rtl" align="right">

**מה Kubernetes פותר:**

</div>

```
┌──────────────────────────────────────────────────────────┐
│                  Kubernetes Cluster                       │
│                                                          │
│   ┌─────────┐  ┌─────────┐  ┌─────────┐                 │
│   │  Pod 1  │  │  Pod 2  │  │  Pod 3  │  ← Scaling      │
│   │   API   │  │   API   │  │   API   │    אוטומטי     │
│   └─────────┘  └─────────┘  └─────────┘                 │
│        │            │            │                       │
│        └────────────┼────────────┘                       │
│                     │                                    │
│              Load Balancing                              │
│              חלוקת עומסים                               │
│                                                          │
│   + Self Healing - אם Pod נופל, קם חדש אוטומטית        │
│   + Rolling Updates - עדכונים בלי downtime             │
│   + Service Discovery - Pods מוצאים אחד את השני        │
└──────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 5.2 מושגי יסוד ב-Kubernetes

**שאלת ראיון נפוצה:** "מה זה Pod?"

| מושג | הסבר | משל |
|------|------|-----|
| **Cluster** | קבוצת שרתים שמנהלים יחד | עיר שלמה |
| **Node** | שרת בודד בקלאסטר | בניין בעיר |
| **Pod** | יחידת ההרצה הקטנה ביותר. מכיל Container אחד או יותר | דירה בבניין |
| **Deployment** | מגדיר איך להריץ Pods (כמה עותקים, איזה image) | חוזה שכירות |
| **Service** | חושף Pods לתקשורת. מאפשר Load Balancing | דלפק קבלה |
| **Ingress** | חושף שירותים לעולם החיצוני עם domain | כתובת הבניין |

## 5.3 הקבצים שיצרנו ומה הם עושים

</div>

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  deployment.yaml ──▶ service.yaml ──▶ ingress.yaml              │
│                                                                  │
│       "מה"              "איך"           "איפה"                   │
│       להריץ             להגיע           לחשוף                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 5.4 Deployment - הסבר מלא

**קובץ: yamls/deployment.yaml**

</div>

```yaml
apiVersion: apps/v1       # גרסת ה-API של Kubernetes
kind: Deployment          # סוג המשאב
metadata:
  name: rick-morty-api    # שם הפריסה
  labels:
    app: rick-morty-api   # תוויות לזיהוי

spec:
  replicas: 2             # כמה עותקים (Pods) להריץ
  
  selector:
    matchLabels:
      app: rick-morty-api # לאילו Pods הפריסה שייכת
  
  template:               # תבנית ליצירת Pod
    metadata:
      labels:
        app: rick-morty-api
    spec:
      containers:
      - name: rick-morty-api
        image: rick-morty-api:latest  # איזה Docker Image
        ports:
        - containerPort: 5000         # איזה פורט

        # ═══════════════════════════════════════════════════════
        # Liveness Probe - בדיקת חיים
        # אם נכשל: Kubernetes יעשה restart ל-Pod
        # ═══════════════════════════════════════════════════════
        livenessProbe:
          httpGet:
            path: /healthcheck
            port: 5000
          initialDelaySeconds: 10   # המתן 10 שניות לפני בדיקה ראשונה
          periodSeconds: 30         # בדוק כל 30 שניות

        # ═══════════════════════════════════════════════════════
        # Readiness Probe - בדיקת מוכנות
        # אם נכשל: לא ישלחו traffic ל-Pod הזה
        # ═══════════════════════════════════════════════════════
        readinessProbe:
          httpGet:
            path: /healthcheck
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 10

        # ═══════════════════════════════════════════════════════
        # Resource Limits - הגבלת משאבים
        # ═══════════════════════════════════════════════════════
        resources:
          requests:         # מינימום מובטח
            memory: "64Mi"  # 64 מגה זיכרון
            cpu: "100m"     # 0.1 CPU (100 millicores)
          limits:           # מקסימום מותר
            memory: "128Mi"
            cpu: "200m"
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "מה ההבדל בין Liveness Probe ל-Readiness Probe?"

| Probe | מטרה | מה קורה אם נכשל |
|-------|------|-----------------|
| **Liveness** | לבדוק אם האפליקציה חיה | Restart ל-Container |
| **Readiness** | לבדוק אם האפליקציה מוכנה | לא שולחים traffic |

**דוגמה:** 
- אפליקציה עלתה אבל עדיין טוענת נתונים
- Liveness יעבור (היא חיה)
- Readiness ייכשל (היא לא מוכנה לקבל בקשות)

## 5.5 Service - הסבר מלא

**קובץ: yamls/service.yaml**

</div>

```yaml
apiVersion: v1
kind: Service
metadata:
  name: rick-morty-api-service
  labels:
    app: rick-morty-api

spec:
  type: ClusterIP         # סוג השירות (ראה טבלה למטה)
  ports:
  - port: 80              # הפורט שהשירות חושף
    targetPort: 5000      # הפורט של ה-Container
    protocol: TCP
  selector:
    app: rick-morty-api   # לאילו Pods לנתב (לפי labels)
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "מה ההבדל בין סוגי Service?"

| סוג | נגישות | שימוש |
|-----|--------|-------|
| **ClusterIP** | רק מתוך הקלאסטר | שירותים פנימיים |
| **NodePort** | דרך פורט על כל Node | פיתוח ובדיקות |
| **LoadBalancer** | דרך Load Balancer חיצוני | פרודקשן בענן |

## 5.6 Ingress - הסבר מלא

**קובץ: yamls/ingress.yaml**

</div>

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: rick-morty-api-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /

spec:
  ingressClassName: nginx    # איזה Ingress Controller
  rules:
  - host: rick-morty.local   # ה-domain
    http:
      paths:
      - path: /              # הנתיב
        pathType: Prefix
        backend:
          service:
            name: rick-morty-api-service  # לאיזה Service לנתב
            port:
              number: 80
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "מה ההבדל בין Service ל-Ingress?"

| רכיב | תפקיד |
|------|-------|
| **Service** | חשיפה פנימית + Load Balancing בין Pods |
| **Ingress** | חשיפה חיצונית + ניתוב לפי domain/path + SSL |

## 5.7 פקודות kubectl חיוניות

**שאלת ראיון נפוצה:** "איך בודקים מצב של Pods בקלאסטר?"

</div>

```bash
# ═══════════════════════════════════════════════════════════════
# הצגת משאבים
# ═══════════════════════════════════════════════════════════════
kubectl get pods              # הצג את כל ה-Pods
kubectl get pods -o wide      # הצג עם מידע נוסף (IP, Node)
kubectl get services          # הצג את כל ה-Services
kubectl get deployments       # הצג את כל ה-Deployments
kubectl get ingress           # הצג את כל ה-Ingresses
kubectl get all               # הצג הכל

# ═══════════════════════════════════════════════════════════════
# יישום קבצי YAML
# ═══════════════════════════════════════════════════════════════
kubectl apply -f deployment.yaml   # יישם קובץ בודד
kubectl apply -f yamls/            # יישם כל הקבצים בתיקייה

# ═══════════════════════════════════════════════════════════════
# מידע מפורט
# ═══════════════════════════════════════════════════════════════
kubectl describe pod <pod-name>    # מידע מפורט על Pod
kubectl logs <pod-name>            # לוגים של Pod
kubectl logs -f <pod-name>         # לוגים בזמן אמת

# ═══════════════════════════════════════════════════════════════
# ניפוי באגים
# ═══════════════════════════════════════════════════════════════
kubectl exec -it <pod-name> -- /bin/bash   # כניסה ל-Pod
kubectl port-forward svc/my-service 8080:80 # העברת פורט

# ═══════════════════════════════════════════════════════════════
# מחיקה
# ═══════════════════════════════════════════════════════════════
kubectl delete -f deployment.yaml  # מחק לפי קובץ
kubectl delete pod <pod-name>      # מחק Pod ספציפי
```

<div dir="rtl" align="right">

---

# פרק 6: הזרימה המלאה - איך הכל מתחבר

## 6.1 תרשים מקיף

</div>

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              התמונה הגדולה                                   │
└─────────────────────────────────────────────────────────────────────────────┘

                    משתמש מהאינטרנט
                          │
                          │ HTTP Request
                          │ http://rick-morty.local/characters
                          ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Kubernetes Cluster                                  │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           INGRESS                                       │ │
│  │                                                                         │ │
│  │  1. מקבל את הבקשה                                                       │ │
│  │  2. בודק את ה-host (rick-morty.local)                                  │ │
│  │  3. בודק את ה-path (/)                                                 │ │
│  │  4. מעביר ל-Service המתאים                                             │ │
│  │                                                                         │ │
│  └────────────────────────────────────┬───────────────────────────────────┘ │
│                                       │                                      │
│  ┌────────────────────────────────────┼───────────────────────────────────┐ │
│  │                           SERVICE                                       │ │
│  │                                    │                                    │ │
│  │  1. מקבל את הבקשה מ-Ingress       │                                    │ │
│  │  2. מחפש Pods עם התווית המתאימה   │                                    │ │
│  │  3. מפזר עומסים (Load Balance)     │                                    │ │
│  │  4. מעביר ל-Pod שנבחר             │                                    │ │
│  │                                    │                                    │ │
│  │                    ┌───────────────┴───────────────┐                    │ │
│  │                    │                               │                    │ │
│  └────────────────────┼───────────────────────────────┼────────────────────┘ │
│                       │                               │                      │
│          ┌────────────┴─────────────┐    ┌───────────┴────────────┐         │
│          ▼                          ▼    ▼                        ▼         │
│  ┌───────────────┐          ┌───────────────┐          ┌───────────────┐    │
│  │     POD 1     │          │     POD 2     │          │     POD N     │    │
│  │ ┌───────────┐ │          │ ┌───────────┐ │          │ ┌───────────┐ │    │
│  │ │ Container │ │          │ │ Container │ │          │ │ Container │ │    │
│  │ │           │ │          │ │           │ │          │ │           │ │    │
│  │ │  api.py   │ │          │ │  api.py   │ │          │ │  api.py   │ │    │
│  │ │  Flask    │ │          │ │  Flask    │ │          │ │  Flask    │ │    │
│  │ │  :5000    │ │          │ │  :5000    │ │          │ │  :5000    │ │    │
│  │ │           │ │          │ │           │ │          │ │           │ │    │
│  │ └───────────┘ │          │ └───────────┘ │          │ └───────────┘ │    │
│  └───────────────┘          └───────────────┘          └───────────────┘    │
│          │                          │                          │            │
│          │                          │                          │            │
│          └──────────────────────────┴──────────────────────────┘            │
│                                     │                                        │
│                           DEPLOYMENT                                        │
│                      (מנהל את כל ה-Pods)                                    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      │ HTTP Request
                                      ▼
                         ┌─────────────────────────┐
                         │  Rick and Morty API     │
                         │  rickandmortyapi.com    │
                         └─────────────────────────┘
```

<div dir="rtl" align="right">

## 6.2 מה קורה כשמשתמש שולח בקשה?

**שלב 1: Ingress**
- מקבל בקשה ל-`rick-morty.local/characters`
- בודק את כללי הניתוב
- מעביר ל-Service `rick-morty-api-service` על פורט 80

**שלב 2: Service**
- מקבל את הבקשה
- מוצא את כל ה-Pods עם `app: rick-morty-api`
- בוחר Pod (Round Robin / Random)
- מעביר את הבקשה לפורט 5000 של ה-Pod

**שלב 3: Pod**
- ה-Container מקבל את הבקשה
- Flask מזהה את הנתיב `/characters`
- הקוד קורא מ-Rick and Morty API
- מסנן את הדמויות
- מחזיר JSON

**שלב 4: חזרה**
- התגובה עוברת: Pod ← Service ← Ingress ← משתמש

---

# פרק 7: שאלות ראיון נפוצות - סיכום

## 7.1 שאלות על API

| שאלה | תשובה |
|------|-------|
| מה זה REST API? | ארכיטקטורה לתקשורת בין מערכות המבוססת על HTTP |
| מה ההבדל בין GET ל-POST? | GET לקריאה, POST ליצירה |
| מה זה Status Code 500? | שגיאה בצד השרת |
| איך מטפלים ב-Pagination? | קוראים עמוד-עמוד עד שאין next |

## 7.2 שאלות על Docker

| שאלה | תשובה |
|------|-------|
| מה ההבדל בין Image ל-Container? | Image = תבנית, Container = מופע רץ |
| למה Docker ולא VM? | יותר קל, מהיר, וצורך פחות משאבים |
| מה עושה EXPOSE? | מתעד איזה פורט האפליקציה מאזינה (לא פותח באמת) |
| מה ההבדל בין CMD ל-ENTRYPOINT? | CMD ניתן לדריסה, ENTRYPOINT קבוע |

## 7.3 שאלות על Kubernetes

| שאלה | תשובה |
|------|-------|
| מה זה Pod? | יחידת ההרצה הקטנה ביותר, מכיל Container אחד או יותר |
| מה ההבדל בין Deployment ל-Pod? | Deployment מנהל Pods (replicas, updates) |
| מתי משתמשים ב-ClusterIP? | לשירותים פנימיים בלבד |
| מה עושה Liveness Probe? | בודק אם האפליקציה חיה. אם לא - restart |

---

# פרק 8: מבנה הפרויקט הסופי

</div>

```
rick-morty-devops/
│
├── app/                          # קוד האפליקציה
│   ├── main.py                   # סקריפט שמייצר CSV
│   ├── api.py                    # שרת REST API
│   ├── requirements.txt          # ספריות Python נדרשות
│   └── output.csv                # קובץ הפלט
│
├── yamls/                        # קבצי Kubernetes
│   ├── deployment.yaml           # הגדרת הפריסה
│   ├── service.yaml              # הגדרת השירות
│   └── ingress.yaml              # הגדרת הכניסה
│
├── Dockerfile                    # הוראות לבניית Docker Image
├── .gitignore                    # קבצים להתעלמות ב-Git
└── README.md                     # תיעוד הפרויקט
```

<div dir="rtl" align="right">

---

# פרק 9: מפת הקשרים - איך הכל מתחבר

## 9.1 המפה הגדולה - כל הפרויקט במבט אחד

</div>

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│                          🗺️ MINDMAP - מפת הפרויקט המלאה                                │
│                                                                                         │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                         │
│                                ┌─────────────────────┐                                  │
│                                │   🎯 המשימה שלנו   │                                  │
│                                │  Rick & Morty API   │                                  │
│                                └──────────┬──────────┘                                  │
│                                           │                                             │
│                ┌──────────────────────────┼──────────────────────────┐                  │
│                │                          │                          │                  │
│                ▼                          ▼                          ▼                  │
│     ┌─────────────────┐       ┌─────────────────┐       ┌─────────────────┐            │
│     │  📊 DATA        │       │  🔧 CODE        │       │  🚀 DEPLOY      │            │
│     │  מאיפה המידע?   │       │  איך מעבדים?    │       │  איך מריצים?    │            │
│     └────────┬────────┘       └────────┬────────┘       └────────┬────────┘            │
│              │                         │                         │                      │
│              ▼                         ▼                         ▼                      │
│ ┌─────────────────────────┐  ┌─────────────────────────┐  ┌─────────────────────────┐  │
│ │ rickandmortyapi.com     │  │ Python Scripts          │  │ Docker + Kubernetes     │  │
│ │ └─▶ 826 דמויות         │  │ └─▶ main.py (CSV)       │  │ └─▶ Container           │  │
│ │ └─▶ 42 עמודים          │  │ └─▶ api.py (REST)       │  │ └─▶ Pods                │  │
│ │ └─▶ JSON format        │  │ └─▶ סינון + עיבוד       │  │ └─▶ Services            │  │
│ └─────────────────────────┘  └─────────────────────────┘  └─────────────────────────┘  │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 9.2 זרימת הנתונים - השרשרת המלאה

</div>

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│                          📡 THE CHAIN - שרשרת הבקשה                                     │
│                                                                                         │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                         │
│   User Request                                                                          │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  INGRESS (rick-morty.local)                                                      │  │
│   │  • בודק host ו-path                                                              │  │
│   │  • מעביר לשירות המתאים                                                           │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  SERVICE (finds pods by label, load balance)                                     │  │
│   │  • מוצא את ה-Pods לפי label                                                      │  │
│   │  • מפזר עומסים בין ה-Pods                                                        │  │
│   │  • ממיר port 80 → 5000                                                          │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  POD (runs container from image)                                                 │  │
│   │  • מריץ Container מה-Docker Image                                                │  │
│   │  • liveness + readiness probes בודקים אותו                                       │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  CONTAINER (runs api.py on port 5000)                                            │  │
│   │  • Python + Flask                                                                │  │
│   │  • מאזין על port 5000                                                            │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  FLASK (handles /characters route)                                               │  │
│   │  • מזהה את הנתיב /characters                                                     │  │
│   │  • קורא לפונקציה המתאימה                                                         │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  PYTHON CODE (calls external API, filters data)                                  │  │
│   │  • שולח בקשות ל-Rick & Morty API                                                 │  │
│   │  • מטפל ב-Pagination (42 עמודים)                                                 │  │
│   │  • מסנן: Human + Alive + Earth                                                   │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  RICK & MORTY API (External)                                                     │  │
│   │  • 826 דמויות ב-42 עמודים                                                        │  │
│   │  • מחזיר JSON                                                                    │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  FILTER (109 characters remain)                                                  │  │
│   │  species == "Human" ✓                                                            │  │
│   │  status == "Alive" ✓                                                             │  │
│   │  origin contains "Earth" ✓                                                       │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   JSON Response back to User                                                            │
│   {"count": 109, "characters": [...]}                                                   │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 9.3 מפת הקבצים - מי תלוי במי?

</div>

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│                      📁 FILE DEPENDENCIES - תלויות בין קבצים                           │
│                                                                                         │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                         │
│   requirements.txt                                                                      │
│        │                                                                                │
│        │ pip install                                                                    │
│        ▼                                                                                │
│   ┌─────────────┐                         ┌─────────────┐                               │
│   │  main.py    │                         │   api.py    │                               │
│   │  imports:   │                         │  imports:   │                               │
│   │  - requests │                         │  - requests │                               │
│   │  - csv      │                         │  - flask    │                               │
│   │             │                         │             │                               │
│   │  OUTPUT:    │                         │  ENDPOINTS: │                               │
│   │  output.csv │                         │ /characters │                               │
│   └─────────────┘                         │ /healthcheck│                               │
│                                           └──────┬──────┘                               │
│                                                  │                                      │
│                                                  │ runs                                 │
│                                                  ▼                                      │
│                                           ┌─────────────┐                               │
│                                           │ Dockerfile  │                               │
│                                           │ CMD api.py  │                               │
│                                           └──────┬──────┘                               │
│                                                  │                                      │
│                                                  │ creates                              │
│                                                  ▼                                      │
│                                           ┌─────────────┐                               │
│                                           │Docker Image │                               │
│                                           │rick-morty-api                               │
│                                           └──────┬──────┘                               │
│                                                  │                                      │
│                          ┌───────────────────────┼───────────────────────┐              │
│                          │                       │                       │              │
│                          ▼                       ▼                       ▼              │
│                  ┌───────────────┐      ┌───────────────┐      ┌───────────────┐        │
│                  │deployment.yaml│      │ service.yaml  │      │ ingress.yaml  │        │
│                  │               │      │               │      │               │        │
│                  │ image: rick-  │      │ selector:     │      │ backend:      │        │
│                  │ morty-api     │◀─────│ app: rick-    │◀─────│ service:      │        │
│                  │               │      │ morty-api     │      │ rick-morty    │        │
│                  │ labels:       │──────▶               │      │               │        │
│                  │ app: rick-    │      │               │      │               │        │
│                  │ morty-api     │      │               │      │               │        │
│                  │               │      │               │      │               │        │
│                  │ probes:       │      │               │      │               │        │
│                  │ /healthcheck──┼──────▶ calls api.py endpoint                │        │
│                  └───────────────┘      └───────────────┘      └───────────────┘        │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 9.4 סיכום כל הקשרים

| # | מה | מתחבר ל | איך |
|---|-----|---------|-----|
| 1 | requirements.txt | Python files | pip install |
| 2 | main.py / api.py | Rick & Morty API | requests.get() |
| 3 | api.py | Port 5000 | Flask app.run() |
| 4 | Dockerfile | api.py | CMD ["python", "api.py"] |
| 5 | deployment.yaml | Docker Image | image: rick-morty-api |
| 6 | deployment.yaml | Pods | labels: app: rick-morty-api |
| 7 | service.yaml | Pods | selector: app: rick-morty-api |
| 8 | service.yaml | Container | port: 80 → targetPort: 5000 |
| 9 | ingress.yaml | Service | backend: service |
| 10 | Probes | api.py | httpGet: /healthcheck |

---

# סיכום

**מה למדנו:**

1. **API** - איך לקרוא נתונים משירות חיצוני
2. **Python** - איך לכתוב סקריפט שמעבד נתונים
3. **Docker** - איך לארוז אפליקציה לקונטיינר
4. **Kubernetes** - איך לפרוס ולנהל אפליקציה בענן

**מה הפרויקט מדגים:**
- הבנה של מחזור חיים של אפליקציה
- יכולת לכתוב קוד נקי ומתועד
- ידע ב-Containerization
- הבנה של Orchestration

---

# חלק ב׳: שאלות ראיון DevOps - מדריך מקיף

---

## פרק 10: AWS VPC - כל מה שצריך לדעת

### ❓ "מה זה VPC?"

**VPC** (Virtual Private Cloud) = רשת וירטואלית פרטית בענן AWS.

זה כמו לבנות את הרשת הפרטית שלך בתוך AWS - אתה מחליט:
- איזה טווח כתובות IP (CIDR)
- איך לחלק ל-Subnets
- מי יכול לגשת למה
- איך תנועה נכנסת ויוצאת

### ❓ "מה ההבדל בין Subnet פרטי לציבורי?"

| מאפיין | Public Subnet | Private Subnet |
|--------|---------------|----------------|
| גישה לאינטרנט | ישירה דרך IGW | רק דרך NAT Gateway |
| IP ציבורי | יש | אין |
| Route Table | מצביע ל-IGW | מצביע ל-NAT |
| שימוש | Web servers, Load Balancers | Databases, Internal services |

### ❓ "מהו Internet Gateway?"

**Internet Gateway (IGW)** = שער שמאפשר תקשורת בין VPC לאינטרנט.
- מאפשר לשרתים ב-Public Subnet לצאת ולהיכנס מהאינטרנט
- Highly Available - AWS מנהל אותו
- חינמי (משלמים רק על Data Transfer)

### ❓ "מהו NAT Gateway?"

**NAT Gateway** = מאפשר לשרתים ב-Private Subnet לצאת לאינטרנט בלי להיחשף.
- יציאה בלבד - אין אפשרות להיכנס מבחוץ
- יושב ב-Public Subnet
- עולה כסף (לפי שעה + Data)

### ❓ "מהי טכנולוגיית Private Link?"

**Private Link / VPC Endpoints** = גישה לשירותי AWS בלי לעבור דרך האינטרנט.

**שני סוגים:**
- **Interface Endpoint** - ENI בתוך ה-VPC. עובד עם רוב השירותים.
- **Gateway Endpoint** - רק ל-S3 ו-DynamoDB. חינמי!

---

## פרק 11: AWS IAM - זהויות והרשאות

### ❓ "מה ההבדל בין IAM Role ל-IAM User?"

| מאפיין | IAM User | IAM Role |
|--------|----------|----------|
| מיועד ל | אנשים (בני אדם) | שירותים / אפליקציות |
| אימות | Username + Password | Assume Role (זמני) |
| תוקף | קבוע עד שמוחקים | זמני (credentials מתחלפים) |
| דוגמה | מפתח שנכנס ל-Console | EC2 שניגש ל-S3 |

### ❓ "מה ההבדל בין IAM Policy ל-Resource Based Policy?"

| סוג | IAM Policy | Resource Based Policy |
|-----|------------|----------------------|
| מוצמד ל | User / Group / Role | משאב (S3 Bucket, SQS) |
| מגדיר | "מה המשתמש יכול לעשות" | "מי יכול לגשת למשאב" |
| Cross-Account | דורש Assume Role | ישיר |

---

## פרק 12: AWS Storage

### ❓ "מה ההבדל בין EBS ל-EFS?"

| מאפיין | EBS | EFS |
|--------|-----|-----|
| סוג | Block Storage (דיסק) | File Storage (NFS) |
| חיבור | EC2 אחד בלבד | מרובה EC2 |
| Scaling | ידני | אוטומטי |
| מחיר | זול יותר | יקר יותר |
| שימוש | Database, Boot | Shared files |

### ❓ "מה זה S3?"

**S3** (Simple Storage Service) = Object Storage.
- **Unlimited** - אין הגבלה
- **Durability** - 99.999999999%
- **Storage Classes** - Standard, IA, Glacier
- **שימושים:** Backup, Static website, Data lake

---

## פרק 13: AWS Compute

### ❓ "מה ההבדל בין On-Demand, Reserved, Spot, Dedicated?"

| סוג | מאפיין | הנחה | שימוש |
|-----|--------|------|-------|
| **On-Demand** | לפי שימוש | 0% | Dev, Testing |
| **Reserved** | התחייבות 1-3 שנים | עד 72% | Production |
| **Spot** | קיבולת עודפת | עד 90% | Batch jobs |
| **Dedicated** | שרת פיזי שלם | תלוי | Compliance |

### ❓ "מה זה Lambda?"

**Lambda** = Serverless compute.
- Event-driven
- Pay per use
- Auto-scale
- Max 15 minutes

### ❓ "איזה שירות מתזמן טריגרים של Lambda?"

**Amazon EventBridge** - Cron, Rate, Event patterns

---

## פרק 14: Load Balancing, DNS, CDN

### ❓ "אילו סוגי Load Balancer יש?"

| סוג | שכבה | שימוש |
|-----|------|-------|
| **ALB** | Layer 7 | Web apps, Microservices |
| **NLB** | Layer 4 | High performance |
| **GLB** | Layer 3 | Security appliances |

### ❓ "מה ההבדל בין ניתוב Geolocation, Latency, Weight?"

| סוג | לוגיקה | שימוש |
|-----|--------|-------|
| **Geolocation** | לפי מיקום | תוכן מותאם למדינה |
| **Latency** | לפי זמן תגובה | ביצועים מיטביים |
| **Weighted** | לפי אחוזים | A/B testing |

### ❓ "מה זה CloudFront?"

**CloudFront** = CDN של AWS.
- מפיץ תוכן ל-Edge Locations
- מוריד Latency
- Caching
- SSL/TLS מובנה

### ❓ "האם SSL חינם? מהו ACM?"

**ACM** = AWS Certificate Manager. **חינם!**
- חידוש אוטומטי
- עובד עם: ALB, CloudFront, API Gateway

---

## פרק 15: Databases

### ❓ "מה ההבדל בין DB רלציוני ללא-רלציוני?"

| מאפיין | SQL | NoSQL |
|--------|-----|-------|
| מבנה | טבלאות | Documents, Key-Value |
| Schema | קבוע | גמיש |
| Scaling | Vertical | Horizontal |
| AWS | RDS, Aurora | DynamoDB |

### ❓ "מה זה Redis?"

**Redis** = In-memory key-value store.
- מהיר מאוד
- Caching
- Session storage
- **AWS:** ElastiCache for Redis

### ❓ "מה ההבדל בין Standby ל-Primary DB?"

| סוג | תפקיד |
|-----|-------|
| **Primary** | Write + Read |
| **Standby** | רק גיבוי - Failover אוטומטי |
| **Read Replica** | רק Read |

---

## פרק 16: Kubernetes מתקדם

### ❓ "מהו Namespace?"

**Namespace** = חלוקה לוגית של הקלאסטר.
- מפריד בין סביבות
- מאפשר Resource Quotas

### ❓ "מה ההבדל בין Deployment ל-ReplicaSet?"

| מאפיין | ReplicaSet | Deployment |
|--------|------------|------------|
| Rolling Updates | ❌ | ✅ |
| Rollback | ❌ | ✅ |
| שימוש | נדיר | תמיד! |

### ❓ "מה זה Ingress ו-Ingress Controller?"

| רכיב | תפקיד |
|------|-------|
| **Ingress** | YAML שמגדיר חוקי ניתוב |
| **Ingress Controller** | התוכנה שאוכפת (NGINX) |

### ❓ "מהו Sidecar, Init, Application Container?"

| סוג | מתי רץ | תפקיד |
|-----|--------|-------|
| **Init** | לפני Main | הכנות |
| **Application** | אחרי Init | האפליקציה |
| **Sidecar** | במקביל | עזר (Logging) |

### ❓ "מה זה Probe? Liveness?"

| Probe | שואל | אם נכשל |
|-------|------|---------|
| **Liveness** | "אתה חי?" | Restart |
| **Readiness** | "אתה מוכן?" | No traffic |

### ❓ "מהו Service Account?"

**Service Account** = זהות עבור Pods.
- תקשורת עם K8s API
- RBAC permissions
- קישור ל-AWS IAM (IRSA)

### ❓ "איך מתבצע Autoscale?"

- **HPA** - מוסיף Pods לפי metrics
- **VPA** - משנה Resources
- **Cluster Autoscaler** - מוסיף Nodes

### ❓ "מה זה PVC?"

**PVC** = Persistent Volume Claim = בקשה לאחסון.
- **PV** = האחסון הפיזי
- **PVC** = הבקשה
- **StorageClass** = סוג האחסון

---

## פרק 17: סוגי Workloads

### ❓ "StatefulSet vs DaemonSet vs Deployment?"

| סוג | תפקיד | דוגמה |
|-----|-------|-------|
| **Deployment** | Stateless, Pods זהים | Web servers |
| **StatefulSet** | Stateful, זהות קבועה | Databases |
| **DaemonSet** | Pod על כל Node | Logging agent |

### ❓ "סוגי Services?"

| סוג | נגישות |
|-----|--------|
| **ClusterIP** | רק מתוך הקלאסטר |
| **NodePort** | Port על כל Node |
| **LoadBalancer** | Cloud LB חיצוני |

### ❓ "4 סוגי פריסות?"

| סוג | איך עובד |
|-----|----------|
| **Rolling Update** | מחליף בהדרגה |
| **Recreate** | מוחק הכל → מעלה חדש |
| **Blue-Green** | סביבה חדשה → Switch |
| **Canary** | % קטן מהמשתמשים |

### ❓ "מהו Istio?"

**Istio** = Service Mesh.
- Traffic Management
- Security (mTLS)
- Observability

---

## פרק 18: Helm

### ❓ "מה זה Helm?"

**Helm** = Package manager לקוברנטיס.
- **Charts** - חבילות מוכנות
- **Templating** - YAMLים דינמיים
- **Values** - קובץ הגדרות
- **Releases** - ניהול גרסאות

### ❓ "מה זה Helm Lint?"

`helm lint` = בודק תקינות Chart לפני התקנה.

### ❓ "מה זה _helpers.tpl?"

קובץ עם פונקציות לשימוש חוזר בתוך Chart.

---

## פרק 19: CI/CD

### ❓ "מה זה CI ו-CD?"

| מונח | משמעות | מה כולל |
|------|--------|---------|
| **CI** | Continuous Integration | Build, Test, Lint |
| **CD** | Continuous Delivery | פריסה אוטומטית |

### ❓ "GitHub Actions vs Jenkins?"

| מאפיין | GitHub Actions | Jenkins |
|--------|----------------|---------|
| התקנה | מובנה (SaaS) | Self-hosted |
| תחזוקה | GitHub | אתה |
| גמישות | טובה | מקסימלית |

### ❓ "מה זה Artifact?"

**Artifact** = תוצר Build: Docker Image, JAR, Binary

### ❓ "Test vs Stage vs Prod?"

| סביבה | מטרה |
|-------|------|
| **Dev/Test** | בדיקות מפתחים |
| **Staging** | Pre-production |
| **Production** | משתמשים אמיתיים |

---

## פרק 20: Terraform

### ❓ "מהו Drift?"

**Drift** = פער בין State למצב האמיתי. קורה כששינו ידנית.

### ❓ "עריכת שם Bucket - מה יקרה?"

**ימחק את הישן ויצור חדש!** (immutable)

### ❓ "מה זה Terraform Validate?"

בודק תקינות קבצי .tf (לא מול הענן).

### ❓ "איפה לשמור State?"

**Remote Backend** - S3 + DynamoDB locking. לא ב-Git!

### ❓ "מה זה Workspace?"

State נפרד לאותו קוד (dev, staging, prod).

### ❓ "מהו Module?"

קבוצת Resources לשימוש חוזר (כמו פונקציה).

### ❓ "CloudFormation vs Terraform?"

| מאפיין | CloudFormation | Terraform |
|--------|----------------|-----------|
| ספק | AWS בלבד | Multi-cloud |
| שפה | JSON/YAML | HCL |
| State | AWS מנהל | אתה מנהל |

---

## פרק 21: Architecture

### ❓ "Microservices vs Monolith?"

| Monolith | Microservices |
|----------|---------------|
| אפליקציה אחת | שירותים קטנים |
| פשוט להתחיל | קשה לנהל |
| קשה לסקייל חלקים | כל שירות נפרד |

### ❓ "מה זה Decoupled Services?"

שירותים לא תלויים ישירות - תקשורת דרך Queue/Events.

### ❓ "מתי EC2 ומתי Kubernetes?"

| EC2 | Kubernetes |
|-----|------------|
| אפליקציה פשוטה | Microservices |
| צוות קטן | צוות עם ידע K8s |
| Stateful legacy | Cloud Native |

---

## פרק 22: Monitoring

### ❓ "מה זה Prometheus?"

מערכת Monitoring - Pull-based, Time-series, PromQL.

### ❓ "מה זה Grafana?"

כלי Visualization - Dashboards, Alerts.

### ❓ "מהו NGINX?"

Web server / Reverse Proxy / Load Balancer / Ingress Controller.

---

## פרק 23: API & HTTP

### ❓ "קודים 2xx, 3xx, 4xx, 5xx?"

| סדרה | משמעות |
|------|--------|
| **2xx** | הצלחה |
| **3xx** | Redirect |
| **4xx** | שגיאת Client |
| **5xx** | שגיאת Server |

### ❓ "4 סוגי קריאות API?"

GET (Read), POST (Create), PUT (Update), DELETE (Delete)

### ❓ "REST vs SOAP?"

| REST | SOAP |
|------|------|
| JSON | XML |
| קל | כבד |
| Modern | Enterprise |

---

## פרק 24: תרחישים

### תרחיש: הקמת אתר E-Commerce

**שאלות לשאול:**
1. גאוגרפיה - ישראל או גלובלי?
2. עדכניות מוצרים - לעיתים רחוקות? Redis
3. כמות כניסות - Scaling planning

### תרחיש: קמפיין חגים (10K → 40K)

1. Auto Scaling לפי CPU
2. Read Replicas
3. Redis Caching
4. Pre-warming

### תרחיש: שדרוג K8s Cluster

1. Control Plane קודם
2. בדיקת תקינות
3. Worker Nodes אחד-אחד

### תרחיש: Pods ב-Error

1. `kubectl describe pod`
2. `kubectl logs`
3. בדיקת: Image, Permissions, Resources

### תרחיש: Traffic מ-ALB לK8s

- ALB: Public Subnet, SG 80/443
- K8s: SG Referencing, Ingress

### תרחיש: K8s בלי אינטרנט

- Private Registry (ECR + Endpoint)
- Golden AMI
- Private Link

---

## פרק 25: Docker מתקדם

### ❓ "מה זה Multi-Stage Build?"

**איך הייתי עונה בראיון:**

"Multi-Stage Build זה טכניקה שבה אני בונה Docker Image בכמה שלבים נפרדים, כאשר ה-Image הסופי מכיל רק את מה שצריך להריץ את האפליקציה - בלי כל הכלים שהשתמשתי בהם כדי לבנות אותה.

**הבעיה שזה פותר:**
כשאני בונה אפליקציה, אני צריך כלים - compiler, npm, build tools. אבל ב-Production אני לא צריך אותם! אם אני משאיר אותם ב-Image, קורות שתי בעיות:
1. **ה-Image ענק** - במקום 50MB, הוא 800MB
2. **פגיעויות אבטחה** - כל כלי זה עוד קוד שיכול להיות פגיע

**איך זה עובד - Build vs Runtime:**

```dockerfile
# ========== STAGE 1: BUILD ==========
# פה יש לי את כל הכלים - Node.js, npm, webpack
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install          # מתקין dependencies
COPY . .
RUN npm run build        # יוצר תיקיית dist/

# ========== STAGE 2: RUNTIME ==========
# פה יש לי רק nginx קטן - בלי Node, בלי npm!
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
# זהו! ה-Image הסופי מכיל רק nginx + הקבצים הסטטיים
```

**Build Stage** = הסביבה שבה אני בונה (Node.js, npm, compiler)
**Runtime Stage** = הסביבה שבה האפליקציה רצה (רק nginx)

**התוצאה:**
- Image קטן (50MB במקום 800MB)
- פחות פגיעויות (אין npm ב-Production)
- Faster deployments
- פחות משאבים"

---

### ❓ "מה זה Volumes ו-Bind Mounts?"

**איך הייתי עונה בראיון:**

"הבעיה: כשContainer נמחק, כל המידע שבתוכו נמחק. אם יש לי Database בתוך Container והוא קורס - איבדתי את כל הנתונים. Volumes פותרים את זה.

**Volume (מנוהל על ידי Docker):**
Docker יוצר תיקייה מיוחדת שהוא מנהל. אני לא יודע איפה בדיוק היא נמצאת בדיסק, ולא צריך לדעת. המידע נשמר גם אם ה-Container נמחק.
```bash
docker run -v mydata:/app/data mysql
#          ↑ שם ה-Volume    ↑ איפה ב-Container
```
**מתי:** Production, Databases, מידע קריטי

**Bind Mount (תיקייה שלי):**
אני מחבר תיקייה ספציפית מהמחשב שלי לתוך ה-Container. כל שינוי בתיקייה משתקף מיד ב-Container.
```bash
docker run -v /home/user/code:/app myapp
#          ↑ תיקייה במחשב שלי  ↑ איפה ב-Container
```
**מתי:** Development - כי אני רוצה לערוך קוד ולראות שינויים מיד

**tmpfs (זיכרון בלבד):**
המידע נשמר רק בזיכרון, לא בדיסק. כש-Container נעצר - הכל נמחק.
**מתי:** מידע רגיש שלא רוצים שיישאר בדיסק"

| סוג | איפה נשמר | מי מנהל | Persists? | שימוש |
|-----|-----------|---------|-----------|-------|
| **Volume** | Docker storage | Docker | ✅ כן | Production, DBs |
| **Bind Mount** | תיקייה שלך | אתה | ✅ כן | Development |
| **tmpfs** | RAM | - | ❌ לא | Secrets, Cache |

### ❓ "מה זה Docker Compose?"

כלי להרצת מספר Containers יחד. קובץ YAML אחד, פקודה אחת.

### ❓ "Docker Networking Types?"

| Type | תיאור |
|------|-------|
| **bridge** | ברירת מחדל - מבודד |
| **host** | רשת של ה-host |
| **none** | ללא רשת |
| **overlay** | בין hosts |

### ❓ "Container Restart Policies?"

| Policy | התנהגות |
|--------|---------|
| `no` | לא מפעיל מחדש |
| `always` | תמיד |
| `on-failure` | רק ב-error |
| `unless-stopped` | תמיד חוץ מאם עצרת |

---

## פרק 26: Kubernetes Scheduling

### ❓ "Labels ו-Selectors?"

**Labels** = תגיות key-value על Resources.
**Selectors** = בחירת Resources לפי Labels.

### ❓ "Taints ו-Tolerations?"

**Taint** = "רעל" על Node - דוחה Pods.
**Toleration** = "חיסון" ל-Pod - מאפשר לו לרוץ.

*משל: שלט "כניסה אסורה" (Taint), אישור מיוחד (Toleration)*

### ❓ "Node Selector vs Node Affinity?"

| מושג | תיאור | גמישות |
|------|-------|--------|
| **Node Selector** | label פשוט | equality בלבד |
| **Node Affinity** | תנאים מורכבים | In, NotIn, Gt, Lt |

### ❓ "Pod Affinity vs Anti-Affinity?"

**Affinity** = "רוצה ליד Pod מסוים" (Web + Cache)
**Anti-Affinity** = "רוצה רחוק מ-Pod" (DB replicas - HA)

---

## פרק 27: Kubernetes Configuration

### ❓ "מה זה ConfigMap?"

אחסון configuration לא-רגיש: env vars, files.

### ❓ "מה זה Secret?"

אחסון רגיש (base64): passwords, API keys, certs.
⚠️ base64 ≠ הצפנה! להשתמש עם Vault.

### ❓ "Rolling Update ו-Rollback?"

**Rolling Update** = עדכון הדרגתי ללא downtime.
**Rollback** = חזרה לגרסה קודמת.

```bash
kubectl rollout undo deployment/myapp
kubectl rollout undo deployment/myapp --to-revision=2
```

---

## פרק 28: K8s Networking

### ❓ "מה זה CNI?"

**CNI** = Container Network Interface. Plugins: Calico, Flannel, Weave, AWS VPC CNI.

### ❓ "מה זה CoreDNS?"

DNS פנימי של הקלאסטר. מתרגם: `my-service.namespace.svc.cluster.local`

### ❓ "מה זה Network Policy?"

Firewall ברמת Pod. קובע איזה Traffic מותר Ingress/Egress.

---

## פרק 29: Jenkins

### ❓ "Freestyle vs Pipeline?"

| מאפיין | Freestyle | Pipeline |
|--------|-----------|----------|
| הגדרה | GUI | קוד (Jenkinsfile) |
| Git | ❌ | ✅ |
| שימוש | פשוט | CI/CD מלא |

### ❓ "Jenkins Agents/Slaves?"

**Master** = מנהל, מתזמן
**Agent** = מבצע העבודה

### ❓ "הרצה ידנית בין שלבים?"

כן! עם `input` step:
```groovy
input message: 'Deploy?', ok: 'Deploy!'
```

### ❓ "Jenkins Parameters?"

משתנים שהמשתמש מזין: string, choice, boolean.

---

## פרק 30: Security & Best Practices

### ❓ "מה זה SG Referencing?"

התייחסות ל-Security Group במקום CIDR.
**יתרון:** יותר מאובטח, יותר דינמי.

### ❓ "OIDC בין GitHub ל-AWS?"

אימות בלי Access Keys!
1. Identity Provider ב-AWS
2. IAM Role עם Trust Policy
3. `aws-actions/configure-aws-credentials`

### ❓ "GitHub vs GitLab?"

| מאפיין | GitHub | GitLab |
|--------|--------|--------|
| CI/CD | Actions | מובנה יותר |
| Self-hosted | יקר | Community חינם |

### ❓ "Vertical vs Horizontal Scaling?"

| Vertical | Horizontal |
|----------|------------|
| יותר כח למכונה | יותר מכונות |
| יש גבול | כמעט ללא גבול |
| DBs | Stateless |

---

---

# 📚 מילון מושגים מפורט - A-Z

> **חיפוש מהיר:** Ctrl+F ← הקלד את המושג

---

## ☁️ AWS - Amazon Web Services

---

### ACM (AWS Certificate Manager)

**מה זה:** שירות לניהול תעודות SSL/TLS.

**עלות:** חינם לשירותי AWS!

**מאפיינים:**
- חידוש אוטומטי
- תומך wildcard certificates
- אינטגרציה עם ALB, CloudFront, API Gateway

**⚠️ מגבלה:** לא עובד ישירות עם EC2 - צריך לשים מאחורי ALB.

**פקודה:**
```bash
aws acm request-certificate --domain-name example.com
```

---

### ALB (Application Load Balancer)

**מה זה:** Load Balancer ברמת Layer 7 (HTTP/HTTPS).

**יכולות:**
- Path-based routing (`/api` → service A, `/web` → service B)
- Host-based routing (`api.example.com` → service A)
- WebSocket support
- HTTP/2 support
- Integration עם WAF

**מתי להשתמש:**
- Web applications
- Microservices
- Container-based apps

**לעומת NLB:**
| ALB | NLB |
|-----|-----|
| Layer 7 | Layer 4 |
| HTTP/HTTPS | TCP/UDP |
| Path routing | Port routing |
| איטי יותר | מהיר מאוד |

---

### Auto Scaling Group (ASG)

**מה זה:** קבוצת EC2 instances שגדלה וקטנה אוטומטית.

**הגדרות:**
- **Minimum:** מינימום instances (לא יורד מזה)
- **Maximum:** מקסימום instances (לא עולה מזה)
- **Desired:** כמות רצויה נוכחית

**Scaling Policies:**
| סוג | איך עובד |
|-----|----------|
| Target Tracking | "שמור על 70% CPU" |
| Step Scaling | "אם CPU > 80% הוסף 2" |
| Scheduled | "בשעה 9 בבוקר הוסף 5" |

**דוגמה:**
```
Min: 2, Max: 10, Desired: 4
CPU > 70% → Desired: 6
CPU < 30% → Desired: 3
```

---

### CloudFront

**מה זה:** CDN (Content Delivery Network) של AWS.

**איך עובד:**
1. משתמש מבקש קובץ
2. CloudFront בודק אם יש ב-Edge Location הקרוב
3. אם יש (Cache Hit) → מחזיר מיד
4. אם אין (Cache Miss) → מביא מה-Origin, שומר, מחזיר

**יתרונות:**
- Latency נמוך (200+ Edge Locations)
- DDoS protection מובנה
- SSL/TLS חינם
- עובד עם S3, ALB, EC2, או כל HTTP server

**TTL (Time To Live):**
- קובע כמה זמן לשמור ב-cache
- ברירת מחדל: 24 שעות

---

### CloudWatch

**מה זה:** שירות Monitoring וLogging של AWS.

**רכיבים:**

| רכיב | תפקיד |
|------|-------|
| **Metrics** | מדדים (CPU, Memory, Custom) |
| **Logs** | לוגים מכל שירות |
| **Alarms** | התראות על סף מסוים |
| **Dashboards** | גרפים ויזואליים |
| **Events/EventBridge** | תגובה לאירועים |

**Metrics חשובים ל-EC2:**
- CPUUtilization
- NetworkIn/Out
- DiskReadOps/WriteOps
- StatusCheckFailed

---

### CloudTrail

**מה זה:** מתעד כל פעולת API ב-AWS account.

**שימושים:**
- Security audit
- Compliance
- Troubleshooting

**מה נרשם:**
- מי עשה (User/Role)
- מה עשה (API call)
- מתי (Timestamp)
- מאיפה (IP address)

---

### Decoupled Services

**מה זה:** ארכיטקטורה שבה שירותים לא תלויים ישירות אחד בשני.

**Tightly Coupled (רע):**
```
Service A → Service B (ישיר)
אם B נופל, A נופל
```

**Decoupled (טוב):**
```
Service A → SQS Queue → Service B
אם B נופל, ההודעות ממתינות בQueue
```

**יתרונות:**
- Fault tolerance
- Independent scaling
- Async processing
- Easier maintenance

**שירותי AWS ל-Decoupling:**
- SQS (Simple Queue Service)
- SNS (Simple Notification Service)
- EventBridge

---

### EBS (Elastic Block Store)

**מה זה:** דיסק וירטואלי ל-EC2.

**סוגים:**

| סוג | IOPS | שימוש |
|-----|------|-------|
| gp3 | עד 16,000 | General purpose (הכי נפוץ) |
| io2 | עד 64,000 | High performance DB |
| st1 | עד 500 | Big data, throughput |
| sc1 | עד 250 | Cold data, archive |

**מאפיינים:**
- מחובר ל-EC2 אחד בלבד
- באותו AZ בלבד!
- Snapshots לגיבוי (נשמרים ב-S3)

---

### EFS (Elastic File System)

**מה זה:** NFS מנוהל - file system משותף.

**הבדל מ-EBS:**

| מאפיין | EBS | EFS |
|--------|-----|-----|
| חיבור | EC2 אחד | מרובה EC2 |
| AZ | אחד | Cross-AZ |
| Scaling | ידני | אוטומטי |
| פרוטוקול | Block | NFS |
| מחיר | זול יותר | יקר יותר |

**שימושים:**
- Shared application files
- CMS content
- Development environments

---

### IAM (Identity and Access Management)

**מה זה:** ניהול זהויות והרשאות ב-AWS.

**רכיבים:**

| רכיב | מה זה | דוגמה |
|------|-------|-------|
| **User** | זהות לאדם | john@company.com |
| **Group** | קבוצת Users | "Developers" |
| **Role** | זהות לשירות | EC2 שניגש ל-S3 |
| **Policy** | מסמך הרשאות | מה מותר/אסור |

**IAM User vs IAM Role:**

| מאפיין | User | Role |
|--------|------|------|
| מיועד ל | אנשים | שירותים |
| אימות | Password/Keys | Assume Role |
| תוקף | קבוע | זמני |
| Best Practice | לאנשים | לאוטומציה |

**IAM Policy vs Resource Policy:**

| מאפיין | IAM Policy | Resource Policy |
|--------|------------|-----------------|
| מוצמד ל | User/Group/Role | המשאב עצמו |
| שואל | "מה User יכול?" | "מי יכול לגשת?" |
| Cross-Account | דורש Assume | ישיר |

---

### Internet Gateway (IGW)

**מה זה:** שער שמחבר VPC לאינטרנט.

**מאפיינים:**
- Horizontally scaled, redundant, HA
- AWS מנהל - אין לך מה לדאוג
- חינמי (משלמים Data Transfer)
- אחד ל-VPC

**חובה בשביל:**
- EC2 עם Public IP יוכל לצאת לאינטרנט
- תנועה נכנסת מהאינטרנט

---

### Lambda

**מה זה:** Serverless compute - מריץ קוד בלי שרתים.

**מאפיינים:**
- Event-driven
- Pay per millisecond
- Auto-scale (עד אלפי executions במקביל)
- תומך: Python, Node.js, Java, Go, .NET

**מגבלות:**
| מגבלה | ערך |
|-------|-----|
| Timeout | 15 דקות |
| Memory | 128MB - 10GB |
| Package size | 250MB |
| /tmp storage | 512MB (או 10GB עם EFS) |

**Triggers נפוצים:**
- API Gateway
- S3 events
- EventBridge (cron)
- SQS
- DynamoDB Streams

**מתזמן:** EventBridge
```
cron(0 2 * * ? *)  # כל יום ב-2 בלילה
rate(5 minutes)    # כל 5 דקות
```

---

### NAT Gateway

**איך הייתי עונה בראיון:**

"NAT Gateway פותר בעיה ספציפית: יש לי שרת ב-Private Subnet שצריך לצאת לאינטרנט (להוריד עדכונים, לקרוא ל-API חיצוני), אבל אני לא רוצה שמישהו מבחוץ יוכל להגיע אליו.

**הבעיה:**
- Private Subnet = אין גישה לאינטרנט
- אבל צריך: `apt update`, `pip install`, Docker images

**הפתרון:**
NAT Gateway יושב ב-Public Subnet ומשמש כ'שער יציאה':

```
EC2 ב-Private רוצה להגיע ל-google.com
           │
           ▼
   ┌───────────────────┐
   │   NAT Gateway     │ (יושב ב-Public Subnet)
   │   IP: 3.4.5.6     │ ← מחליף את ה-IP המקורי
   └─────────┬─────────┘
             │
             ▼
   ┌───────────────────┐
   │  Internet Gateway │
   └─────────┬─────────┘
             │
             ▼
         google.com
         
google.com רואה: בקשה מ-3.4.5.6 (ה-NAT)
                 לא יודע שמאחורי זה EC2 ב-Private
```

**המפתח:** יציאה בלבד! Traffic יכול לצאת, אבל אי אפשר להתחיל connection מבחוץ.

**עלות:** ~$0.045/שעה + $0.045 לכל GB (לא זול! לכן שוקלים Private Link)

**HA:** NAT הוא per-AZ. לHA מלא - צריך NAT בכל AZ."

---

### Private Link / VPC Endpoint

**מה זה:** גישה לשירותי AWS בלי אינטרנט.

**שני סוגים:**

| סוג | מה זה | עלות | שירותים |
|-----|-------|------|---------|
| **Interface** | ENI בתוך VPC | בתשלום | רוב השירותים |
| **Gateway** | Route Table | חינם! | S3, DynamoDB בלבד |

**יתרונות:**
- אבטחה: Traffic לא יוצא מ-AWS
- ביצועים: Latency נמוך
- עלות: חוסך NAT Gateway

**דוגמה - ECR בלי אינטרנט:**
```
צריך 3 Interface Endpoints:
- com.amazonaws.region.ecr.api
- com.amazonaws.region.ecr.dkr
- com.amazonaws.region.s3 (Gateway - חינם)
```

---

### RDS (Relational Database Service)

**מה זה:** בסיס נתונים מנוהל.

**מנועים נתמכים:**
MySQL, PostgreSQL, MariaDB, Oracle, SQL Server, Aurora

**Multi-AZ:**
- Standby ב-AZ אחר
- Failover אוטומטי (1-2 דקות)
- Standby לא נגיש לקריאה!

**Read Replica:**
- עותק לקריאה
- נגיש לקריאה
- Async replication

| מאפיין | Multi-AZ | Read Replica |
|--------|----------|--------------|
| מטרה | HA | ביצועים |
| נגיש? | לא | כן |
| Sync | Synchronous | Async |
| Failover | אוטומטי | ידני |

---

### Route 53

**מה זה:** שירות DNS של AWS.

**סוגי ניתוב:**

| סוג | לוגיקה | שימוש | דוגמה |
|-----|--------|-------|-------|
| **Simple** | IP אחד | Basic | אתר פשוט |
| **Weighted** | לפי אחוזים | A/B Testing | 90% v1, 10% v2 |
| **Latency** | לפי מהירות | Global users | Region הכי מהיר |
| **Geolocation** | לפי מיקום | Compliance | ישראל → il-central |
| **Failover** | Primary/Secondary | DR | אם Primary נופל |
| **Multivalue** | כמה IPs | Simple LB | 8 IPs רנדומלי |

---

### S3 (Simple Storage Service)

**מה זה:** Object Storage ללא הגבלה.

**מאפיינים:**
- Objects (לא קבצים רגילים)
- 99.999999999% Durability (11 תשיעיות)
- Max object size: 5TB
- Versioning
- Encryption (SSE-S3, SSE-KMS, SSE-C)

**Storage Classes:**

| Class | זמינות | Min Duration | שימוש |
|-------|--------|--------------|-------|
| Standard | מיידי | אין | גישה תכופה |
| Standard-IA | מיידי | 30 יום | גישה לא תכופה |
| One Zone-IA | מיידי | 30 יום | פחות קריטי |
| Glacier Instant | מיידי | 90 יום | ארכיון + גישה מהירה |
| Glacier Flexible | דקות-שעות | 90 יום | ארכיון |
| Glacier Deep | 12-48 שעות | 180 יום | ארכיון ארוך |

---

### Security Group (SG)

**מה זה:** Firewall וירטואלי ברמת Instance.

**מאפיינים:**
- **Stateful:** אם נכנס, יוצא אוטומטית
- Default: All inbound denied, All outbound allowed
- רק Allow rules (אין Deny)

**SG Referencing:**
במקום CIDR, אפשר להתייחס ל-SG אחר:
```
Inbound: Allow from sg-alb-12345 (רק ALB יכול)
```
**יותר מאובטח מ:** `Allow 10.0.0.0/16`

---

### Subnet

**איך הייתי עונה בראיון:**

"Subnet זה חלוקה של ה-VPC לרשתות קטנות יותר. השאלה המרכזית היא: Public או Private?

---

**Public Subnet - פתוח לעולם:**

**מה מייחד אותו:**
1. יש Route ישיר ל-Internet Gateway
2. Instances מקבלים Public IP
3. אפשר להגיע אליהם מהאינטרנט

**מה שמים ב-Public Subnet:**
- Load Balancers (ALB/NLB) - חייבים לקבל Traffic מבחוץ
- NAT Gateway - חייב להיות ב-Public כדי לצאת לאינטרנט
- Bastion Host - שרת גישה לניהול

**Route Table:**
```
Destination    → Target
10.0.0.0/16    → local (תנועה פנימית)
0.0.0.0/0      → igw-xxx (כל השאר → אינטרנט)
```

---

**Private Subnet - מבודד מהעולם:**

**מה מייחד אותו:**
1. אין Route ישיר לאינטרנט
2. אין Public IP
3. אי אפשר להגיע מבחוץ (אלא דרך ALB או Bastion)

**מה שמים ב-Private Subnet:**
- Databases (RDS) - לא רוצים שיהיו חשופים
- Application servers - מאחורי Load Balancer
- Internal services

**Route Table:**
```
Destination    → Target
10.0.0.0/16    → local (תנועה פנימית)
0.0.0.0/0      → nat-xxx (יציאה דרך NAT)
```

---

**למה צריך את שניהם?**

```
אינטרנט
    │
    ▼
┌─────────────────────────────────────────────────────┐
│ VPC (10.0.0.0/16)                                   │
│                                                     │
│  Public Subnet (10.0.1.0/24)                       │
│  ┌─────────────┐  ┌─────────────┐                  │
│  │     ALB     │  │ NAT Gateway │                  │
│  └──────┬──────┘  └──────┬──────┘                  │
│         │                │                          │
│ --------│----------------│------------------------- │
│         │                │                          │
│  Private Subnet (10.0.10.0/24)                     │
│  ┌──────▼──────┐  ┌──────┴──────┐                  │
│  │  App Server │  │  Database   │                  │
│  │ (מקבל Traffic │  │ (יוצא לעדכונים)│              │
│  │  מה-ALB)    │  │              │                  │
│  └─────────────┘  └─────────────┘                  │
│                                                     │
└─────────────────────────────────────────────────────┘
```

**האפליקציה ב-Private:** מקבלת Traffic רק מה-ALB, לא ישירות מהאינטרנט
**ה-Database ב-Private:** יוצא לאינטרנט (דרך NAT) רק לעדכונים, אי אפשר להיכנס אליו מבחוץ"

---

**CIDR - חישוב כתובות:**
```
VPC: 10.0.0.0/16        = 65,536 IPs
├── Public:  10.0.1.0/24  = 256 IPs (AZ-a)
├── Public:  10.0.2.0/24  = 256 IPs (AZ-b)
├── Private: 10.0.10.0/24 = 256 IPs (AZ-a)
└── Private: 10.0.11.0/24 = 256 IPs (AZ-b)
```

**כלל אצבע:** מספר גדול אחרי ה-/ = פחות כתובות
- /16 = 65,536
- /24 = 256
- /28 = 16

---

### VPC (Virtual Private Cloud)

**מה זה:** רשת וירטואלית פרטית שלך ב-AWS.

**רכיבים:**
- **CIDR Block:** טווח IPs
- **Subnets:** חלוקות
- **Route Tables:** לאן לשלוח traffic
- **IGW:** גישה לאינטרנט
- **NAT:** יציאה לאינטרנט מ-Private
- **Security Groups:** Firewall

---

## ☸️ Kubernetes - מושגים מפורטים

---

### ConfigMap

**מה זה:** אחסון configuration לא-רגיש.

**שימושים:**
- Environment variables
- Configuration files
- Command-line arguments

**יצירה:**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  DATABASE_HOST: "db.example.com"
  LOG_LEVEL: "debug"
  config.json: |
    {"feature_flag": true}
```

**שימוש ב-Pod:**
```yaml
env:
  - name: DATABASE_HOST
    valueFrom:
      configMapKeyRef:
        name: app-config
        key: DATABASE_HOST
```

---

### DaemonSet

**מה זה:** מבטיח שPod אחד רץ על כל Node.

**שימושים:**
- Logging agents (Fluentd)
- Monitoring agents (Prometheus Node Exporter)
- Storage daemons
- Network plugins

**הבדל מ-Deployment:**
| Deployment | DaemonSet |
|------------|-----------|
| X replicas איפשהו | Pod אחד על כל Node |
| Scheduler מחליט | Node = Pod |

---

### Deployment Strategies - 4 אסטרטגיות פריסה

**איך הייתי עונה בראיון:**

"יש 4 דרכים עיקריות לפרוס גרסה חדשה, וכל אחת מתאימה למצב אחר:

---

**1. Rolling Update (ברירת מחדל בקוברנטיס)**

**מה קורה:** מחליפים Pod אחד בכל פעם. תמיד יש Pods שעובדים.

```
התחלה:  [v1] [v1] [v1] [v1]    ← כולם v1
שלב 1:  [v1] [v1] [v1] [v2]    ← אחד עודכן
שלב 2:  [v1] [v1] [v2] [v2]    ← שניים עודכנו
שלב 3:  [v1] [v2] [v2] [v2]    ← שלושה עודכנו
סיום:   [v2] [v2] [v2] [v2]    ← כולם v2
```

**יתרונות:** Zero downtime, Rollback פשוט עם `kubectl rollout undo`
**חסרונות:** לזמן מסוים יש שתי גרסאות במקביל - צריך שהאפליקציה תתמוך בזה
**מתי להשתמש:** רוב המקרים - זו ברירת המחדל והכי נפוצה

---

**2. Recreate (מחק והתקן מחדש)**

**מה קורה:** מוחקים את כל ה-Pods הישנים, ורק אז מעלים חדשים.

```
התחלה:  [v1] [v1] [v1] [v1]    ← כולם v1
שלב 1:  [  ] [  ] [  ] [  ]    ← מחקנו הכל! DOWNTIME
שלב 2:  [v2] [v2] [v2] [v2]    ← הכל חדש
```

**יתרונות:** פשוט, אין שתי גרסאות
**חסרונות:** יש DOWNTIME! האתר לא עובד לכמה שניות/דקות
**מתי להשתמש:** כשאי אפשר להריץ שתי גרסאות (למשל migration של DB schema)

---

**3. Blue-Green**

**מה קורה:** מעלים סביבה חדשה לגמרי (Green), בודקים שהיא עובדת, ואז מעבירים את כל ה-Traffic אליה בבת אחת.

```
לפני:
  Blue (v1):  [v1] [v1] [v1] [v1]  ← מקבל Traffic
  Green (v2): [v2] [v2] [v2] [v2]  ← מוכן, לא מקבל Traffic

אחרי Switch:
  Blue (v1):  [v1] [v1] [v1] [v1]  ← Standby (לגיבוי)
  Green (v2): [v2] [v2] [v2] [v2]  ← מקבל Traffic
```

**יתרונות:** Zero downtime, Rollback מיידי (פשוט מחזירים ל-Blue)
**חסרונות:** צריך כפול משאבים (שתי סביבות מלאות)
**מתי להשתמש:** כשחייבים Rollback מיידי, או כשרוצים לבדוק סביבה מלאה לפני Switch

---

**4. Canary (קנרית במכרה פחם)**

**מה קורה:** מעלים גרסה חדשה רק לאחוז קטן מהמשתמשים. אם הכל בסדר - מגדילים בהדרגה.

```
שלב 1 (5% traffic):
  [v1] [v1] [v1] [v1] [v1] [v1] [v1] [v1] [v1] [v2]
  └─────────────── 95% ─────────────────┘    └5%┘

שלב 2 (25% traffic):
  [v1] [v1] [v1] [v1] [v1] [v1] [v1] [v2] [v2] [v2]
  └─────────── 75% ───────────────┘  └── 25% ──┘

שלב 3 (100% traffic):
  [v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2]
  └─────────────────── 100% ────────────────────┘
```

**למה קנרית?** פעם שמו כלוב עם ציפור קנרית במכרות פחם. אם היא מתה - סימן שיש גז רעיל. פה זה אותו רעיון - מנסים על קבוצה קטנה קודם.

**יתרונות:** בדיקה ב-Production עם משתמשים אמיתיים, מזהים בעיות מוקדם
**חסרונות:** דורש Monitoring טוב, מורכב יותר לניהול
**מתי להשתמש:** Features חדשים, שינויים מסוכנים, A/B testing"

---

**טבלת סיכום:**

| אסטרטגיה | Downtime | Rollback | משאבים | מתי |
|----------|----------|----------|--------|-----|
| Rolling | ❌ אין | מהיר | רגיל | ברירת מחדל |
| Recreate | ✅ יש! | מהיר | רגיל | DB migrations |
| Blue-Green | ❌ אין | מיידי | x2 | צריך instant rollback |
| Canary | ❌ אין | מהיר | מעט יותר | בדיקה ב-Prod |

---

### HPA (Horizontal Pod Autoscaler)

**מה זה:** Auto-scaling של Pods לפי metrics.

**איך עובד:**
1. מודד CPU/Memory/Custom metrics
2. משווה ל-target (למשל 70%)
3. מחשב כמה Pods צריך
4. מוסיף/מוריד Pods

**הגדרה:**
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: my-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

---

### Ingress & Ingress Controller

**Ingress (Resource):**
מסמך YAML שמגדיר חוקי ניתוב.

**Ingress Controller (Software):**
התוכנה שקוראת את ה-Ingress ומבצעת בפועל.

**Controllers נפוצים:**
- NGINX Ingress Controller
- Traefik
- HAProxy
- AWS ALB Ingress Controller

**דוגמת Ingress:**
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /users
        pathType: Prefix
        backend:
          service:
            name: users-service
            port:
              number: 80
      - path: /orders
        pathType: Prefix
        backend:
          service:
            name: orders-service
            port:
              number: 80
```

---

### Namespace

**מה זה:** חלוקה לוגית של הקלאסטר.

**שימושים:**
- הפרדה בין סביבות: dev, staging, prod
- הפרדה בין צוותים
- Resource Quotas
- Network Policies

**Default Namespaces:**
| Namespace | תפקיד |
|-----------|--------|
| default | ברירת מחדל |
| kube-system | רכיבי K8s (CoreDNS, etc.) |
| kube-public | משאבים ציבוריים |

**פקודות:**
```bash
kubectl get namespaces
kubectl create namespace dev
kubectl get pods -n production
kubectl get pods --all-namespaces
```

---

### Node Affinity & Pod Affinity

**Node Selector (פשוט):**
```yaml
nodeSelector:
  disktype: ssd
```

**Node Affinity (מתקדם):**
```yaml
affinity:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
      - matchExpressions:
        - key: disktype
          operator: In
          values: [ssd, nvme]
```

**Pod Affinity:**
"רוץ על Node שיש עליו Pod עם label מסוים"
שימוש: Web server ליד Cache

**Pod Anti-Affinity:**
"רוץ על Node שאין עליו Pod עם label מסוים"
שימוש: DB replicas על Nodes שונים (HA)

---

### Probes - בדיקות בריאות

**איך הייתי עונה בראיון:**

"Probes הם הדרך של קוברנטיס לדעת אם האפליקציה שלי בריאה. בלעדיהם, קוברנטיס לא יודע אם משהו השתבש.

יש 3 סוגים, וכל אחד עונה על שאלה אחרת:

---

**1. Liveness Probe - "האם אתה עדיין חי?"**

**הבעיה שזה פותר:** לפעמים אפליקציה נתקעת (deadlock, infinite loop) - היא לא קורסת, אבל גם לא עובדת. בלי Liveness Probe, קוברנטיס חושב שהכל בסדר.

**מה קורה אם נכשל:** קוברנטיס עושה Restart ל-Container

**דוגמה מהחיים:** 
```
קוברנטיס: "היי Container, אתה חי?"
Container: *לא עונה*
קוברנטיס: "אוקיי, אני הורג אותך ומעלה חדש"
```

---

**2. Readiness Probe - "האם אתה מוכן לקבל Traffic?"**

**הבעיה שזה פותר:** אפליקציה יכולה להיות חיה אבל לא מוכנה - למשל, היא עדיין מתחברת ל-Database או טוענת cache.

**מה קורה אם נכשל:** קוברנטיס לא שולח Traffic ל-Pod (מוריד אותו מה-Service)

**דוגמה מהחיים:**
```
קוברנטיס: "היי Container, אתה מוכן לעבוד?"
Container: "רגע, אני עדיין טוען נתונים..."
קוברנטיס: "אוקיי, לא שולח לך לקוחות עד שתהיה מוכן"
```

**ההבדל מ-Liveness:** Liveness הורג, Readiness רק מפסיק לשלוח Traffic

---

**3. Startup Probe - "האם עלית בכלל?"**

**הבעיה שזה פותר:** יש אפליקציות שלוקח להן הרבה זמן לעלות (Java apps, loading ML models). בלי Startup Probe, ה-Liveness Probe יהרוג אותן לפני שהספיקו לעלות.

**מה קורה אם נכשל:** ממתינים עוד (עד timeout)

**דוגמה:**
```yaml
startupProbe:
  httpGet:
    path: /healthcheck
    port: 8080
  failureThreshold: 30   # 30 ניסיונות
  periodSeconds: 10      # כל 10 שניות
  # = 5 דקות להתעורר
```

---

**סוגי בדיקות (איך בודקים):**

| סוג | איך עובד | מתי להשתמש |
|-----|----------|------------|
| **httpGet** | GET request ל-URL | Web apps (הכי נפוץ) |
| **tcpSocket** | בדיקה אם Port פתוח | Databases, non-HTTP |
| **exec** | מריץ command בתוך Container | בדיקות מורכבות |

---

**דוגמה מלאה:**
```yaml
livenessProbe:           # האם חי?
  httpGet:
    path: /healthcheck
    port: 8080
  initialDelaySeconds: 10  # תמתין 10 שניות לפני הבדיקה הראשונה
  periodSeconds: 30        # בדוק כל 30 שניות
  failureThreshold: 3      # אחרי 3 כישלונות - Restart

readinessProbe:          # האם מוכן?
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 10
  # אם נכשל - לא שולחים Traffic, לא הורגים
```

**Best Practice:**
- תמיד להגדיר Liveness + Readiness
- Liveness בודק endpoint פשוט (`/healthcheck`)
- Readiness בודק שהכל מוכן (`/ready` - כולל DB connection)"

---

### PVC (Persistent Volume Claim)

**מה זה:** בקשה לאחסון קבוע.

**3 רכיבים:**
| רכיב | מה זה | מי יוצר |
|------|-------|---------|
| **PV** | האחסון הפיזי | Admin / Dynamic |
| **PVC** | הבקשה | Developer |
| **StorageClass** | סוג האחסון | Admin |

**דוגמה:**
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: gp2
```

**Access Modes:**
- **ReadWriteOnce (RWO):** Node אחד
- **ReadOnlyMany (ROX):** הרבה Nodes קריאה
- **ReadWriteMany (RWX):** הרבה Nodes כתיבה

---

### Secret

**מה זה:** אחסון מידע רגיש.

**סוגים:**
- Opaque (ברירת מחדל)
- kubernetes.io/tls
- kubernetes.io/dockerconfigjson

**⚠️ חשוב:** base64 ≠ הצפנה!
לאבטחה אמיתית: External Secrets, Vault, Sealed Secrets

**יצירה:**
```bash
kubectl create secret generic db-secret \
  --from-literal=username=admin \
  --from-literal=password=secret123
```

---

### Service - סוגים בפירוט

**איך הייתי עונה בראיון:**

"Service בקוברנטיס הוא הדרך לחשוף Pods לתקשורת. הבעיה: Pods מתים ונולדים כל הזמן, ה-IP שלהם משתנה. Service נותן כתובת קבועה.

יש 4 סוגים, וחשוב להבין מתי להשתמש בכל אחד:

---

**1. ClusterIP (ברירת מחדל)**

**מה זה:** Service שנגיש רק מתוך הקלאסטר. מקבל IP פנימי קבוע.

**איך עובד:**
```
Pod A רוצה לדבר עם Pod B
       ↓
Pod A → ClusterIP Service (10.96.0.15) → Pod B
       (כתובת קבועה)      (IP משתנה)
```

```yaml
spec:
  type: ClusterIP  # ברירת מחדל, אפשר לא לכתוב
  ports:
  - port: 80          # איזה Port ה-Service מאזין
    targetPort: 8080  # לאיזה Port ב-Pod לשלוח
```

**מתי להשתמש:** שירותים פנימיים - Backend שמדבר עם Database, Microservices שמדברים ביניהם
**יתרונות:** פשוט, מאובטח (לא חשוף לעולם)

---

**2. NodePort**

**מה זה:** פותח Port קבוע על כל Node בקלאסטר. מבחוץ אפשר לגשת דרך `<Node-IP>:<NodePort>`.

**איך עובד:**
```
משתמש מבחוץ
       ↓
http://192.168.1.100:30080  (IP של Node + NodePort)
       ↓
NodePort Service
       ↓
Pod (port 8080)
```

```yaml
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: 8080
    nodePort: 30080  # חייב להיות 30000-32767
```

**מתי להשתמש:** Development, Testing, או כשאין Cloud Load Balancer

**⚠️ חסרונות (למה לא ב-Production):**
- צריך לדעת את ה-IP של Node ספציפי
- אם ה-Node נופל - אין גישה
- Port מוגבל לטווח 30000-32767
- לא יפה לתת ללקוחות כתובת עם Port מוזר

---

**3. LoadBalancer**

**מה זה:** יוצר Load Balancer אמיתי בענן (ALB/NLB ב-AWS). מקבל External IP או DNS.

**איך עובד:**
```
משתמש מבחוץ
       ↓
http://my-lb-12345.us-east-1.elb.amazonaws.com (DNS של LB)
       ↓
Cloud Load Balancer (AWS יוצר אוטומטית)
       ↓
NodePort (מאחורי הקלעים)
       ↓
Pod
```

```yaml
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 8080
```

**מתי להשתמש:** Production! זו הדרך הנכונה לחשוף שירות לעולם.
**יתרונות:** DNS יפה, HA, SSL termination
**חסרונות:** עלות - כל LoadBalancer עולה כסף

---

**4. ExternalName**

**מה זה:** לא באמת Service - זה DNS CNAME שמצביע לשירות חיצוני.

**איך עובד:**
```yaml
spec:
  type: ExternalName
  externalName: my.database.amazonaws.com
```

Pod בקלאסטר יכול לפנות ל-`my-service.default.svc.cluster.local` והוא יופנה ל-`my.database.amazonaws.com`.

**מתי להשתמש:** כשרוצים לגשת לשירות חיצוני (RDS, external API) עם שם פנימי
**יתרון:** אם מחר ה-Database עובר - משנים רק את ה-Service, לא את כל הקוד"

---

**טבלת סיכום:**

| סוג | נגישות | שימוש | Production? |
|-----|--------|-------|-------------|
| **ClusterIP** | רק מתוך הקלאסטר | Internal services | ✅ כן |
| **NodePort** | Node-IP:30000-32767 | Dev/Test | ❌ לא מומלץ |
| **LoadBalancer** | External DNS/IP | Public services | ✅ כן |
| **ExternalName** | DNS redirect | External services | ✅ כן |

---

### Service Account

**מה זה:** זהות עבור Pods (לא בני אדם).

**שימושים:**
- גישה ל-Kubernetes API
- RBAC permissions
- קישור ל-AWS IAM (IRSA)

**דוגמה:**
```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-app-sa
---
# Pod שמשתמש ב-SA
spec:
  serviceAccountName: my-app-sa
```

---

### StatefulSet

**מה זה:** כמו Deployment אבל ל-Stateful apps.

**הבדלים מ-Deployment:**

| מאפיין | Deployment | StatefulSet |
|--------|------------|-------------|
| שמות Pods | רנדומלי (abc123) | סדרתי (pod-0, pod-1) |
| סדר יצירה | מקבילי | סדרתי |
| PVC | משותף | לכל Pod בנפרד |
| DNS | Service | Pod-specific |

**שימושים:**
- Databases (MySQL, PostgreSQL)
- Message queues (Kafka, RabbitMQ)
- Distributed systems (Elasticsearch)

---

### Taints & Tolerations

**Taint (על Node):**
"אל תשים עלי Pods (אלא אם יש להם Toleration)"

```bash
kubectl taint nodes node1 gpu=true:NoSchedule
```

**Toleration (על Pod):**
"אני יכול לרוץ על Node עם Taint"

```yaml
tolerations:
- key: "gpu"
  operator: "Equal"
  value: "true"
  effect: "NoSchedule"
```

**Effects:**
| Effect | התנהגות |
|--------|---------|
| NoSchedule | לא ישים Pods חדשים |
| PreferNoSchedule | ינסה לא לשים |
| NoExecute | יסיר Pods קיימים! |

---

## 🔧 CI/CD & DevOps Tools

---

### Artifact

**מה זה:** תוצר של תהליך Build.

**דוגמאות:**
- Docker Image
- JAR/WAR file
- Compiled binary
- npm package
- Test reports
- Helm chart

**איפה שומרים:**
- Docker Registry (ECR, Docker Hub)
- Artifactory / Nexus
- S3
- GitHub Packages

---

### CI vs CD

| מונח | משמעות | מה כולל |
|------|--------|---------|
| **CI** | Continuous Integration | Build, Test, Lint על כל commit |
| **CD** | Continuous Delivery | פריסה אוטומטית לסביבות |

**שלבי Pipeline מלא:**
```
1. Source     ← Code checkout
2. Build      ← Compile, npm install
3. Test       ← Unit, Integration
4. Security   ← SAST, Dependency scan
5. Package    ← Docker build
6. Deploy     ← Push to environment
7. Verify     ← Health checks
```

---

### GitHub Actions vs Jenkins

| מאפיין | GitHub Actions | Jenkins |
|--------|----------------|---------|
| סוג | SaaS (מנוהל) | Self-hosted |
| תחזוקה | GitHub | אתה |
| קובץ | YAML | Groovy |
| Marketplace | Actions | Plugins |
| עלות | דקות חינם + תשלום | חינם + שרתים |
| למידה | קל | מורכב יותר |
| גמישות | טובה | מקסימלית |

---

### Helm

**מה זה:** Package Manager לקוברנטיס.

**למה צריך:**
- Templating - YAMLים דינמיים
- Packaging - חבילות מוכנות (nginx, mysql)
- Versioning - גרסאות
- Rollback - חזרה לגרסה קודמת

**מבנה Chart:**
```
mychart/
├── Chart.yaml      # Metadata
├── values.yaml     # Default values
├── templates/
│   ├── deployment.yaml
│   ├── service.yaml
│   └── _helpers.tpl  # Functions
└── charts/         # Dependencies
```

**פקודות:**
```bash
helm install myapp ./mychart
helm upgrade myapp ./mychart
helm rollback myapp 1
helm uninstall myapp
helm lint ./mychart
```

**helm lint:** בודק תקינות Chart

**_helpers.tpl:** קובץ עם functions לשימוש חוזר

---

### Terraform

**מושגים:**

| מושג | הסבר |
|------|------|
| **State** | קובץ שמתעד מצב נוכחי |
| **Drift** | פער בין State לאמת |
| **Plan** | מראה מה ישתנה |
| **Apply** | מבצע שינויים |
| **Module** | קוד לשימוש חוזר |
| **Workspace** | States נפרדים |

**איפה לשמור State?**
Remote Backend (S3 + DynamoDB)
- שיתוף צוות
- Locking
- גיבוי
- לא ב-Git!

**terraform validate:** בודק syntax (לא מול הענן)

**שינוי שם Bucket:** ימחק וייצור חדש! (immutable)

---

## 📊 Monitoring

---

### Prometheus

**מה זה:** מערכת Monitoring ואיסוף Metrics.

**מאפיינים:**
- Pull-based (מושך metrics מכל target)
- Time-series database
- PromQL (שפת שאילתות)
- AlertManager לnרשות

**דוגמת PromQL:**
```
# CPU usage
rate(container_cpu_usage_seconds_total[5m])

# Memory
container_memory_usage_bytes
```

---

### Grafana

**מה זה:** כלי Visualization.

**מאפיינים:**
- Dashboards יפים
- מתחבר להרבה data sources
- Alerting
- Open source

---

### NGINX

**מה זה:** Web server רב-תכליתי.

**תפקידים:**
| תפקיד | הסבר |
|-------|------|
| Web Server | מגיש קבצים סטטיים |
| Reverse Proxy | מעביר ל-backend |
| Load Balancer | מפזר עומסים |
| Ingress Controller | בקוברנטיס |

---

## 🎯 תרחישים מלאים

---

### תרחיש: הקמת אתר E-Commerce

**שאלות לשאול:**

1. **גאוגרפיה**
   - ישראל בלבד → Region il-central-1
   - גלובלי → CloudFront

2. **עדכניות מוצרים**
   - לעיתים רחוקות → Redis caching
   - תכופות → פחות cache, יותר DB reads

3. **כמות כניסות**
   - לפי זה: sizing של instances ו-DB
   - Auto Scaling policies

**ארכיטקטורה:**
```
Users → CloudFront → ALB → EKS/EC2 (ASG)
                          ↓
                    RDS Aurora + ElastiCache
```

---

### תרחיש: קמפיין חגים (10K→40K)

**בעיה:** עומס צפוי x4

**פתרון:**

1. **Auto Scaling**
   - Target: CPU 70%
   - Max instances מספיק גבוה

2. **Database**
   - Read Replicas
   - Connection pooling

3. **Caching**
   - Redis/ElastiCache
   - CloudFront TTL

4. **Pre-warming**
   - הגדל capacity מראש
   - Load testing

---

### תרחיש: שדרוג K8s Cluster

**שלבים:**

1. **Control Plane קודם**
   - חייב להיות ≤2 versions מ-Workers
   - AWS EKS עושה אוטומטי

2. **בדיקה**
   ```bash
   kubectl get nodes
   kubectl get pods --all-namespaces
   ```

3. **Worker Nodes**
   - אחד-אחד
   - drain → upgrade → uncordon

4. **חזור על התהליך**
   - Max 2 minor versions בפעם

---

### תרחיש: Pods ב-ERROR

**שלב 1 - High Level:**
```bash
kubectl describe pod <name>
```
בודק: Events, Conditions, State

**שלב 2 - Application Level:**
```bash
kubectl logs <name>
kubectl logs <name> --previous  # אם קרס
```

**סיבות נפוצות:**

| Status | סיבה | פתרון |
|--------|------|-------|
| ImagePullBackOff | אין גישה ל-Registry | בדוק credentials |
| CrashLoopBackOff | App קורס | בדוק logs |
| OOMKilled | חוסר זיכרון | הגדל limits |
| Pending | אין resources | הוסף Nodes |

---

### תרחיש: Traffic ALB → K8s

**ברמת ALB:**
- Public Subnet
- SG: Inbound 80, 443 from 0.0.0.0/0
- Redirect HTTP → HTTPS
- Optional: WAF

**ברמת K8s:**
- SG Referencing (רק ALB SG)
- Ingress resource
- Ingress Controller (NGINX)

---

### תרחיש: K8s בלי אינטרנט

**בעיות:**
- לא יכול Pull images
- לא יכול להתקין packages

**פתרונות:**
1. **Private Registry**
   - ECR + VPC Endpoints
   
2. **Golden AMI**
   - Images מותקנים מראש
   
3. **Private Link**
   - Interface Endpoints לשירותי AWS

---

### תרחיש: DB Scaling ללא Downtime

**Aurora:**
- Auto Scaling אוטומטי
- Cross-Region reads

**RDS - Vertical:**
1. צור Standby ב-AZ אחר
2. Modify את ה-Standby (הוסף resources)
3. Failover (30-60 שניות)

**RDS - Horizontal:**
1. הוסף Read Replicas
2. Application routing:
   - SELECT → Replicas
   - INSERT/UPDATE → Master

**טיפ:** RDS Proxy מחזיק connections בזמן failover

---

---

---

# חלק ג׳: בניית הפרויקט צעד אחרי צעד

## מה קיבלנו במשימה (Last Exercise)

לפני שצוללים לקוד, בואו נבין מה התבקשנו לעשות:

**משימות חובה:**
1. ליצור סקריפט שקורא מ-Rick and Morty API
2. לסנן דמויות לפי: Human, Alive, מכוכב Earth
3. לשמור את התוצאות לקובץ CSV
4. להעלות ל-GitHub ולתת הרשאות לבודק

**משימות בונוס:**
5. להפוך לשירות עם Docker (עם /healthcheck)
6. קבצי Kubernetes (Deployment, Service, Ingress)
7. Helm Chart
8. CI/CD Pipeline עם GitHub Actions

---

## 📁 מבנה הפרויקט המלא

```
rick-morty-devops/
│
├── app/                           # 📂 תיקיית הקוד
│   ├── main.py                    # סקריפט ה-CSV (משימה 1)
│   ├── api.py                     # שרת REST API (בונוס 1)
│   ├── requirements.txt           # תלויות Python
│   └── output.csv                 # קובץ הפלט
│
├── yamls/                         # 📂 קבצי Kubernetes (בונוס 2)
│   ├── deployment.yaml
│   ├── service.yaml
│   └── ingress.yaml
│
├── helm/                          # 📂 Helm Chart (בונוס 3)
│   └── rick-morty-api/
│       ├── Chart.yaml
│       ├── values.yaml
│       └── templates/
│           ├── deployment.yaml
│           ├── service.yaml
│           └── ingress.yaml
│
├── .github/                       # 📂 CI/CD (בונוס 4)
│   └── workflows/
│       └── ci-cd.yaml
│
├── Dockerfile                     # 📄 הוראות בניית Docker Image
├── README.md                      # 📄 תיעוד
└── .gitignore                     # 📄 קבצים להתעלמות
```

---

# 📜 שלב 1: יצירת requirements.txt

**מה זה:** קובץ שמפרט את כל הספריות שהפרויקט צריך.

**למה צריך אותו:**
- Python לא מגיע עם requests או flask מובנה
- מאפשר לכל אחד להתקין את אותן ספריות בדיוק
- Docker משתמש בו כדי להתקין dependencies

**תוכן הקובץ:**

```
requests==2.31.0
flask==3.0.0
```

**הסבר שורה אחרי שורה:**

| שורה | מה זה | למה צריך |
|------|-------|----------|
| `requests==2.31.0` | ספרייה לשליחת HTTP requests | כדי לקרוא ל-Rick & Morty API |
| `flask==3.0.0` | Framework לבניית REST API | כדי ליצור את השרת שלנו |
| `==2.31.0` | גרסה ספציפית | כדי שלכולם תהיה אותה גרסה (reproducibility) |

**פקודת התקנה:**

```bash
pip install -r requirements.txt
```

**מה הפקודה עושה:**
- `pip` = Python package installer
- `install` = התקן
- `-r` = מקרא קובץ (read file)
- `requirements.txt` = שם הקובץ עם הרשימה

---

# 📜 שלב 2: יצירת main.py - הסקריפט הראשי

**מה זה:** הסקריפט שקורא מה-API ויוצר את קובץ ה-CSV.

**הקובץ המלא עם הסבר לכל שורה:**

```python
#!/usr/bin/env python3
# ↑ SHEBANG - אומר למערכת ההפעלה איזו תוכנית להריץ
# בלינוקס אפשר להריץ: ./main.py במקום: python main.py

"""
Rick and Morty Character Fetcher
Fetches all Human, Alive characters from Earth and exports to CSV
"""
# ↑ DOCSTRING - תיעוד מה הקובץ עושה

# ═══════════════════════════════════════════════════════════════
# IMPORTS - ייבוא ספריות
# ═══════════════════════════════════════════════════════════════
import requests  # ספרייה לשליחת HTTP requests (GET, POST, etc.)
import csv       # ספרייה מובנית לעבודה עם קבצי CSV
from typing import List, Dict  # Type hints - לא חובה, אבל עוזר להבין מה הפונקציה מחזירה

# ═══════════════════════════════════════════════════════════════
# CONSTANTS - קבועים
# ═══════════════════════════════════════════════════════════════
API_BASE_URL = "https://rickandmortyapi.com/api/character"
# ↑ כתובת ה-API שממנו אנחנו קוראים
# למה קבוע? כי אם הכתובת תשתנה, נשנה במקום אחד


# ═══════════════════════════════════════════════════════════════
# FUNCTION 1: fetch_all_characters
# שולפת את כל הדמויות מה-API
# ═══════════════════════════════════════════════════════════════
def fetch_all_characters() -> List[Dict]:
    """Fetch all characters from the API with pagination support."""
    # ↑ Type hint: הפונקציה מחזירה רשימה (List) של מילונים (Dict)
    
    all_characters = []  # רשימה ריקה - נאסוף לכאן את כל הדמויות
    url = API_BASE_URL   # מתחילים מהעמוד הראשון
    
    # ═══════════════════════════════════════════════════════════
    # PAGINATION LOOP - לולאה שעוברת על כל העמודים
    # ═══════════════════════════════════════════════════════════
    while url:  # כל עוד יש URL (לא None)
        response = requests.get(url)  # שולח GET request לכתובת
        # response = האובייקט שחזר מהשרת
        
        response.raise_for_status()  # אם יש שגיאה (4xx, 5xx) - זורק Exception
        # למה? כי אם משהו נכשל, עדיף לעצור ולא להמשיך עם נתונים חלקיים
        
        data = response.json()  # ממיר את התגובה מ-JSON לdict של Python
        # data = {"info": {...}, "results": [...]}
        
        all_characters.extend(data['results'])  # מוסיף את הדמויות לרשימה
        # extend = מוסיף את כל האיברים (לא כרשימה בתוך רשימה)
        # data['results'] = רשימה של 20 דמויות
        
        url = data['info']['next']  # מעדכן ל-URL של העמוד הבא
        # אם אין עמוד הבא, next יהיה None והלולאה תיעצר
    
    return all_characters  # מחזיר רשימה עם כל 826 הדמויות


# ═══════════════════════════════════════════════════════════════
# FUNCTION 2: filter_characters
# מסננת דמויות לפי הקריטריונים
# ═══════════════════════════════════════════════════════════════
def filter_characters(characters: List[Dict]) -> List[Dict]:
    """
    Filter characters by:
    - Species: Human (אנושי)
    - Status: Alive (חי)
    - Origin: Earth (מכדור הארץ - כולל וריאציות)
    """
    filtered = []  # רשימה ריקה לדמויות שעברו את הסינון
    
    for char in characters:  # עובר על כל דמות
        # בודק כל קריטריון בנפרד (יותר קריא)
        is_human = char['species'] == 'Human'
        is_alive = char['status'] == 'Alive'
        is_from_earth = 'Earth' in char['origin']['name']
        # ↑ למה 'in' ולא '=='?
        # כי יש וריאציות: "Earth (C-137)", "Earth (Replacement Dimension)"
        # עם 'in' נתפוס את כולם
        
        # אם כל 3 התנאים מתקיימים
        if is_human and is_alive and is_from_earth:
            filtered.append({
                'Name': char['name'],           # שם הדמות
                'Location': char['location']['name'],  # מיקום נוכחי
                'Image': char['image']          # URL לתמונה
            })
            # ↑ יוצרים dict חדש רק עם השדות שצריך (לא את כל ה-50 שדות)
    
    return filtered  # מחזיר רשימה של ~109 דמויות


# ═══════════════════════════════════════════════════════════════
# FUNCTION 3: write_to_csv
# כותבת את הנתונים לקובץ CSV
# ═══════════════════════════════════════════════════════════════
def write_to_csv(characters: List[Dict], filename: str = 'output.csv') -> None:
    """Write filtered characters to CSV file."""
    # filename: str = 'output.csv' ← פרמטר עם ברירת מחדל
    # -> None ← הפונקציה לא מחזירה ערך
    
    with open(filename, 'w', newline='', encoding='utf-8') as f:
        # ↑ with = Context Manager - דואג לסגור את הקובץ אוטומטית
        # 'w' = write mode - יוצר קובץ חדש (דורס אם קיים)
        # newline='' = מונע שורות ריקות מיותרות ב-Windows
        # encoding='utf-8' = תומך בעברית ותווים מיוחדים
        
        writer = csv.DictWriter(f, fieldnames=['Name', 'Location', 'Image'])
        # ↑ DictWriter = כותב dict כשורות CSV
        # fieldnames = שמות העמודות (חייב להתאים למפתחות ב-dict)
        
        writer.writeheader()  # כותב את שורת הכותרות: Name,Location,Image
        writer.writerows(characters)  # כותב את כל השורות בפעם אחת
    
    print(f"Written {len(characters)} characters to {filename}")
    # ↑ f-string - מודפס: "Written 109 characters to output.csv"


# ═══════════════════════════════════════════════════════════════
# FUNCTION 4: main
# הפונקציה הראשית - מחברת הכל ביחד
# ═══════════════════════════════════════════════════════════════
def main():
    print("Fetching characters from Rick and Morty API...")
    
    # שלב 1: שליפה
    all_characters = fetch_all_characters()
    print(f"Total characters fetched: {len(all_characters)}")  # 826
    
    # שלב 2: סינון
    filtered = filter_characters(all_characters)
    print(f"Characters matching criteria: {len(filtered)}")  # ~109
    
    # שלב 3: כתיבה
    write_to_csv(filtered)
    
    # הדפסת דוגמה
    if filtered:
        print("\nSample output:")
        for char in filtered[:3]:  # 3 ראשונות
            print(f"  - {char['Name']}, {char['Location']}")


# ═══════════════════════════════════════════════════════════════
# ENTRY POINT - נקודת הכניסה
# ═══════════════════════════════════════════════════════════════
if __name__ == "__main__":
    main()
# ↑ מה זה עושה?
# __name__ = משתנה מובנה בפייתון
# אם מריצים את הקובץ ישירות: __name__ == "__main__"
# אם מייבאים אותו (import main): __name__ == "main"
# זה מאפשר להשתמש בפונקציות בלי להריץ את main()
```

**פקודת הרצה:**

```bash
cd app
python main.py
```

**פלט צפוי:**

```
Fetching characters from Rick and Morty API...
Total characters fetched: 826
Characters matching criteria: 109
Written 109 characters to output.csv

Sample output:
  - Rick Sanchez, Citadel of Ricks
  - Morty Smith, Citadel of Ricks
  - Summer Smith, Earth (Replacement Dimension)
```

---

# 📜 שלב 3: יצירת api.py - שרת REST API

**מה זה:** שרת Flask שחושף את הנתונים כ-JSON דרך endpoints.

**למה צריך אותו:** 
- הסקריפט יוצר קובץ פעם אחת ונגמר
- API מאפשר לשלוף נתונים בזמן אמת, שוב ושוב

**הקובץ המלא עם הסבר:**

```python
#!/usr/bin/env python3
"""
REST API Service for Rick and Morty Character Data
Bonus: Dockerized service with /healthcheck endpoint
"""

from flask import Flask, jsonify
# Flask = ה-framework לבניית web servers
# jsonify = פונקציה שממירה dict לתגובת JSON

import requests
from typing import List, Dict

# ═══════════════════════════════════════════════════════════════
# יצירת אפליקציית Flask
# ═══════════════════════════════════════════════════════════════
app = Flask(__name__)
# __name__ = שם המודול הנוכחי
# Flask משתמש בו כדי למצוא קבצי static ו-templates

API_BASE_URL = "https://rickandmortyapi.com/api/character"


def fetch_filtered_characters() -> List[Dict]:
    """Fetch and filter characters from Rick and Morty API."""
    # אותה לוגיקה כמו ב-main.py, אבל משולבת בפונקציה אחת
    all_characters = []
    url = API_BASE_URL
    
    while url:
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()
        all_characters.extend(data['results'])
        url = data['info']['next']
    
    # סינון
    filtered = []
    for char in all_characters:
        if (char['species'] == 'Human' and 
            char['status'] == 'Alive' and 
            'Earth' in char['origin']['name']):
            filtered.append({
                'name': char['name'],
                'location': char['location']['name'],
                'image': char['image']
            })
    
    return filtered


# ═══════════════════════════════════════════════════════════════
# ENDPOINT 1: /healthcheck ו-/health
# ═══════════════════════════════════════════════════════════════
@app.route('/healthcheck', methods=['GET'])
@app.route('/health', methods=['GET'])
# ↑ DECORATOR - מקשר URL לפונקציה
# אפשר לשים כמה decorators על אותה פונקציה (aliases)
def healthcheck():
    """Health check endpoint."""
    return jsonify({
        'status': 'healthy',
        'service': 'rick-and-morty-api'
    }), 200
    # ↑ מחזיר tuple: (JSON, status_code)
    # 200 = OK

# למה צריך healthcheck?
# 1. Docker HEALTHCHECK משתמש בו
# 2. Kubernetes probes משתמשים בו
# 3. Load Balancer בודק אם השרת חי


# ═══════════════════════════════════════════════════════════════
# ENDPOINT 2: /characters
# ═══════════════════════════════════════════════════════════════
@app.route('/characters', methods=['GET'])
def get_characters():
    """Get all filtered characters."""
    try:
        characters = fetch_filtered_characters()
        return jsonify({
            'count': len(characters),  # מספר הדמויות
            'characters': characters   # הרשימה
        }), 200
    except Exception as e:
        # אם משהו נכשל (אין אינטרנט, API לא זמין)
        return jsonify({
            'error': str(e)
        }), 500  # Internal Server Error


# ═══════════════════════════════════════════════════════════════
# ENDPOINT 3: / (root)
# ═══════════════════════════════════════════════════════════════
@app.route('/', methods=['GET'])
def index():
    """API documentation."""
    return jsonify({
        'service': 'Rick and Morty Character API',
        'endpoints': {
            '/characters': 'GET - Fetch all Human, Alive characters from Earth',
            '/healthcheck': 'GET - Health check endpoint',
            '/health': 'GET - Health check endpoint (alias)'
        }
    }), 200


# ═══════════════════════════════════════════════════════════════
# הרצת השרת
# ═══════════════════════════════════════════════════════════════
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)
    # host='0.0.0.0' = מאזין על כל הכתובות (לא רק localhost)
    #                  חובה ב-Docker!
    # port=5000 = הפורט שהשרת מאזין עליו
    # debug=False = לא להפעיל debug mode ב-production
    #               debug=True גורם לבעיות אבטחה
```

**פקודת הרצה (לוקלית):**

```bash
cd app
python api.py
```

**בדיקה:**

```bash
# בטרמינל אחר
curl http://localhost:5000/healthcheck
# {"service":"rick-and-morty-api","status":"healthy"}

curl http://localhost:5000/characters
# {"characters":[...],"count":109}
```

---

# 🐳 שלב 4: יצירת Dockerfile

**מה זה:** קובץ הוראות לבניית Docker Image.

**הקובץ המלא עם הסבר:**

```dockerfile
# ═══════════════════════════════════════════════════════════════
# שורה 1: FROM - מאיזו תמונת בסיס להתחיל
# ═══════════════════════════════════════════════════════════════
FROM python:3.11-slim
# python:3.11-slim = תמונה רשמית של Python
# 3.11 = גרסת Python
# slim = גרסה "רזה" - בלי כלים מיותרים (gcc, make וכו')
#        גודל: ~150MB במקום ~1GB
# 
# אלטרנטיבות:
# - python:3.11 = גרסה מלאה (~1GB)
# - python:3.11-alpine = הכי קטנה (~50MB) אבל בעיות תאימות

# ═══════════════════════════════════════════════════════════════
# שורה 2: WORKDIR - באיזו תיקייה לעבוד
# ═══════════════════════════════════════════════════════════════
WORKDIR /app
# יוצר את התיקייה /app (אם לא קיימת)
# כל הפקודות הבאות יתבצעו מתוכה
# כמו: cd /app

# ═══════════════════════════════════════════════════════════════
# שורות 3-4: התקנת Dependencies (LAYER CACHING!)
# ═══════════════════════════════════════════════════════════════
COPY app/requirements.txt .
# מעתיק רק את requirements.txt קודם
# למה בנפרד? בגלל Docker Layer Caching!

RUN pip install --no-cache-dir -r requirements.txt
# pip install = מתקין את הספריות
# --no-cache-dir = לא שומר cache של pip (חוסך מקום)
# -r requirements.txt = מתוך הקובץ
#
# למה זה חשוב?
# כל שורה ב-Dockerfile יוצרת LAYER
# Docker שומר layers במטמון
# אם requirements.txt לא השתנה, הוא משתמש ב-cache!
#
# בלי הפרדה:
#   COPY app/ .                  ← אם שיניתי שורה בקוד
#   RUN pip install ...          ← pip install ירוץ שוב! (5 דקות)
#
# עם הפרדה:
#   COPY app/requirements.txt .  ← לא השתנה → CACHED
#   RUN pip install ...          ← CACHED! (0 שניות)
#   COPY app/ .                  ← שינוי בקוד? רק זה ירוץ

# ═══════════════════════════════════════════════════════════════
# שורה 5: העתקת הקוד
# ═══════════════════════════════════════════════════════════════
COPY app/ .
# מעתיק את כל תיקיית app/ לתוך /app בקונטיינר
# . = WORKDIR הנוכחי (/app)

# ═══════════════════════════════════════════════════════════════
# שורה 6: EXPOSE - תיעוד פורט
# ═══════════════════════════════════════════════════════════════
EXPOSE 5000
# זה לא באמת פותח פורט!
# זה רק תיעוד - אומר "האפליקציה מאזינה על 5000"
# כדי לפתוח באמת צריך: docker run -p 5000:5000

# ═══════════════════════════════════════════════════════════════
# שורות 7-8: HEALTHCHECK - בדיקת בריאות
# ═══════════════════════════════════════════════════════════════
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/healthcheck || exit 1
# --interval=30s = בדוק כל 30 שניות
# --timeout=3s = אם לא ענה תוך 3 שניות = נכשל
# --start-period=5s = תן 5 שניות לאפליקציה לעלות לפני הבדיקה הראשונה
# --retries=3 = 3 כשלונות רצופים = unhealthy
# 
# CMD = הפקודה לבדיקה
# curl -f = שולח GET request, נכשל אם status != 2xx
# || exit 1 = אם curl נכשל, תחזיר קוד שגיאה

# ═══════════════════════════════════════════════════════════════
# שורה 9: CMD - מה להריץ כשהקונטיינר עולה
# ═══════════════════════════════════════════════════════════════
CMD ["python", "api.py"]
# מריץ: python api.py
# למה מערך ולא מחרוזת?
# ["python", "api.py"] = exec form (מומלץ) - מריץ ישירות
# "python api.py" = shell form - מריץ דרך shell
# exec form עדיף כי:
# 1. PID 1 הוא התהליך שלנו (חשוב ל-signals)
# 2. לא צריך shell
```

---

# 🔧 שלב 5: פקודות Docker חיוניות

## בניית ה-Image

```bash
docker build -t rick-morty-api .
#             │  └────────────┘ └┘
#             │     שם ה-Image   מיקום Dockerfile
#             └── build = בנה
#
# -t = tag (שם)
# . = Dockerfile נמצא בתיקייה הנוכחית
```

**פלט צפוי:**

```
[+] Building 45.2s (10/10) FINISHED
 => [1/5] FROM python:3.11-slim
 => [2/5] WORKDIR /app
 => [3/5] COPY app/requirements.txt .
 => [4/5] RUN pip install --no-cache-dir -r requirements.txt
 => [5/5] COPY app/ .
Successfully built abc123def456
Successfully tagged rick-morty-api:latest
```

## הרצת Container

```bash
docker run -d -p 5000:5000 --name my-api rick-morty-api
#          │  └──────────┘ └──────────┘ └─────────────┘
#          │  port mapping    שם        שם ה-Image
#          └── detached (ברקע)
#
# -d = detached mode - רץ ברקע
# -p 5000:5000 = HOST:CONTAINER
#    5000 במחשב שלי → 5000 בקונטיינר
# --name = שם לקונטיינר (קל לזהות)
```

## בדיקת Containers רצים

```bash
docker ps
# מציג containers פעילים

docker ps -a
# מציג את כולם (גם עצורים)
```

**פלט לדוגמה:**

```
CONTAINER ID   IMAGE            COMMAND            STATUS         PORTS
a1b2c3d4e5f6   rick-morty-api   "python api.py"   Up 2 minutes   0.0.0.0:5000->5000/tcp
```

## צפייה בלוגים

```bash
docker logs my-api
# מציג את כל הלוגים

docker logs -f my-api
# מציג בזמן אמת (follow)
# Ctrl+C לעצור
```

## כניסה לתוך Container

```bash
docker exec -it my-api /bin/bash
# -i = interactive
# -t = tty (טרמינל)
# /bin/bash = פתח shell

# עכשיו אתה בתוך הקונטיינר!
ls -la  # תראה את הקבצים
exit    # יציאה
```

## עצירה ומחיקה

```bash
docker stop my-api    # עוצר את הקונטיינר
docker rm my-api      # מוחק את הקונטיינר
docker rmi rick-morty-api  # מוחק את ה-Image

# קיצור: עצור + מחק
docker rm -f my-api
```

## בדיקה שהכל עובד

```bash
# הרץ את הקונטיינר
docker run -d -p 5000:5000 --name my-api rick-morty-api

# המתן מספר שניות
sleep 5

# בדוק healthcheck
curl http://localhost:5000/healthcheck
# {"service":"rick-and-morty-api","status":"healthy"}

# בדוק characters
curl http://localhost:5000/characters | head -c 200
# {"characters":[{"image":"https://...","location":"Citadel of Ricks"...
```

---

# ☸️ שלב 6: קבצי Kubernetes

## קובץ 1: deployment.yaml

**מה זה:** מגדיר איך להריץ את האפליקציה - כמה עותקים, איזה image, probes.

```yaml
# ═══════════════════════════════════════════════════════════════
# METADATA - מטא-דאטה
# ═══════════════════════════════════════════════════════════════
apiVersion: apps/v1       # גרסת ה-API של Kubernetes
kind: Deployment          # סוג המשאב
metadata:
  name: rick-morty-api    # שם הפריסה
  labels:
    app: rick-morty-api   # תווית לזיהוי

# ═══════════════════════════════════════════════════════════════
# SPEC - הגדרות הפריסה
# ═══════════════════════════════════════════════════════════════
spec:
  replicas: 2             # כמה Pods להריץ
                          # 2 = High Availability
  
  selector:
    matchLabels:
      app: rick-morty-api # איזה Pods שייכים לפריסה הזו
                          # חייב להתאים ל-template.metadata.labels
  
  # ═══════════════════════════════════════════════════════════
  # TEMPLATE - תבנית ליצירת Pod
  # ═══════════════════════════════════════════════════════════
  template:
    metadata:
      labels:
        app: rick-morty-api  # תווית על ה-Pod
    spec:
      containers:
      - name: rick-morty-api
        image: rick-morty-api:latest   # איזה Docker Image
        imagePullPolicy: IfNotPresent  # לא למשוך אם קיים מקומית
        
        ports:
        - containerPort: 5000          # איזה פורט ה-Container חושף
        
        # ═══════════════════════════════════════════════════════
        # LIVENESS PROBE - בדיקת חיים
        # ═══════════════════════════════════════════════════════
        livenessProbe:
          httpGet:
            path: /healthcheck   # לאיזה endpoint לקרוא
            port: 5000           # באיזה פורט
          initialDelaySeconds: 10  # המתן 10 שניות לפני בדיקה ראשונה
          periodSeconds: 30        # בדוק כל 30 שניות
        # אם נכשל 3 פעמים רצוף → RESTART
        
        # ═══════════════════════════════════════════════════════
        # READINESS PROBE - בדיקת מוכנות
        # ═══════════════════════════════════════════════════════
        readinessProbe:
          httpGet:
            path: /healthcheck
            port: 5000
          initialDelaySeconds: 5   # התחל לבדוק אחרי 5 שניות
          periodSeconds: 10        # בדוק כל 10 שניות
        # אם נכשל → לא שולחים Traffic (אבל לא עושים restart)
        
        # ═══════════════════════════════════════════════════════
        # RESOURCES - הגבלת משאבים
        # ═══════════════════════════════════════════════════════
        resources:
          requests:           # מינימום מובטח
            memory: "64Mi"    # 64 מגה זיכרון
            cpu: "100m"       # 0.1 CPU (100 millicores)
          limits:             # מקסימום מותר
            memory: "128Mi"
            cpu: "200m"
        # requests = מה שה-Scheduler מבטיח
        # limits = אם האפליקציה תנסה לחרוג - תיהרג (OOMKilled)
```

## קובץ 2: service.yaml

**מה זה:** חושף את ה-Pods לתקשורת עם כתובת קבועה.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: rick-morty-api-service  # שם השירות
  labels:
    app: rick-morty-api

spec:
  type: ClusterIP     # סוג השירות
  # ClusterIP = נגיש רק מתוך הקלאסטר
  # NodePort = נגיש דרך פורט על כל Node
  # LoadBalancer = יוצר LB חיצוני
  
  ports:
  - port: 80              # הפורט שהשירות חושף
    targetPort: 5000      # הפורט של ה-Container
    protocol: TCP
  # כלומר: פנייה ל-service:80 → תגיע ל-pod:5000
  
  selector:
    app: rick-morty-api   # לאילו Pods לנתב
                          # מוצא Pods עם label מתאים
```

## קובץ 3: ingress.yaml

**מה זה:** חושף את השירות לעולם החיצוני עם domain.

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: rick-morty-api-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    # ↑ Annotation - הגדרה ספציפית ל-NGINX Ingress Controller
    # rewrite-target = משנה את ה-path לפני שמעביר ל-service

spec:
  ingressClassName: nginx    # איזה Ingress Controller להשתמש
  
  rules:
  - host: rick-morty.local   # ה-domain שמאזינים עליו
    http:
      paths:
      - path: /              # הנתיב
        pathType: Prefix     # Prefix = כל מה שמתחיל ב-/
        backend:
          service:
            name: rick-morty-api-service  # לאיזה Service לנתב
            port:
              number: 80
```

---

## פקודות Kubernetes חיוניות

```bash
# ═══════════════════════════════════════════════════════════════
# הכנה (למי שעובד עם Minikube)
# ═══════════════════════════════════════════════════════════════
minikube start                      # מפעיל את הקלאסטר
eval $(minikube docker-env)         # משתמש ב-Docker של Minikube
docker build -t rick-morty-api .    # בונה את ה-Image

# ═══════════════════════════════════════════════════════════════
# פריסה
# ═══════════════════════════════════════════════════════════════
kubectl apply -f yamls/             # מפעיל את כל הקבצים בתיקייה
# או אחד אחד:
kubectl apply -f yamls/deployment.yaml
kubectl apply -f yamls/service.yaml
kubectl apply -f yamls/ingress.yaml

# ═══════════════════════════════════════════════════════════════
# בדיקת סטטוס
# ═══════════════════════════════════════════════════════════════
kubectl get pods                    # רשימת Pods
kubectl get pods -o wide            # עם מידע נוסף (IP, Node)
kubectl get services                # רשימת Services
kubectl get deployments             # רשימת Deployments
kubectl get ingress                 # רשימת Ingresses
kubectl get all                     # הכל ביחד

# ═══════════════════════════════════════════════════════════════
# מידע מפורט
# ═══════════════════════════════════════════════════════════════
kubectl describe pod <pod-name>     # מידע מפורט על Pod
kubectl logs <pod-name>             # לוגים
kubectl logs -f <pod-name>          # לוגים בזמן אמת

# ═══════════════════════════════════════════════════════════════
# בדיקת האפליקציה
# ═══════════════════════════════════════════════════════════════
kubectl port-forward service/rick-morty-api-service 8080:80
# ↑ מפנה port 8080 במחשב שלי → port 80 של ה-Service
# עכשיו אפשר: curl http://localhost:8080/healthcheck

# ═══════════════════════════════════════════════════════════════
# מחיקה
# ═══════════════════════════════════════════════════════════════
kubectl delete -f yamls/            # מוחק הכל
kubectl delete pod <pod-name>       # מוחק Pod ספציפי
```

---

# 📦 שלב 7: Helm Chart

## מבנה התיקייה

```
helm/rick-morty-api/
├── Chart.yaml          # מטא-דאטה של ה-Chart
├── values.yaml         # ערכי ברירת מחדל
└── templates/          # תבניות
    ├── deployment.yaml
    ├── service.yaml
    └── ingress.yaml
```

## קובץ Chart.yaml

```yaml
apiVersion: v2                          # גרסת Helm Chart API
name: rick-morty-api                    # שם ה-Chart
description: A Helm chart for Rick and Morty Character API
type: application                       # סוג: application או library
version: 1.0.0                          # גרסת ה-Chart עצמו
appVersion: "1.0.0"                     # גרסת האפליקציה
maintainers:
  - name: DevOps Engineer
```

## קובץ values.yaml

```yaml
# Default values for rick-morty-api
# כל ערך כאן אפשר לדרוס בזמן install

replicaCount: 2                   # כמה replicas

image:
  repository: rick-morty-api      # שם ה-Image
  tag: latest                     # גרסה
  pullPolicy: IfNotPresent        # מתי למשוך

service:
  type: ClusterIP                 # סוג Service
  port: 80                        # פורט חיצוני
  targetPort: 5000                # פורט של Container

ingress:
  enabled: true                   # האם ליצור Ingress
  host: rick-morty.local          # ה-domain
  path: /

resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

healthcheck:
  path: /healthcheck
  initialDelaySeconds: 10
  periodSeconds: 30

env: {}                           # Environment variables
```

## תבניות (Templates)

**helm/rick-morty-api/templates/deployment.yaml:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Release.Name }}
  # ↑ TEMPLATE VARIABLE
  # {{ }} = Helm template syntax
  # .Release.Name = השם שנתת ב-helm install
  labels:
    app: {{ .Release.Name }}
    chart: {{ .Chart.Name }}-{{ .Chart.Version }}
    # .Chart.Name = מה-Chart.yaml
spec:
  replicas: {{ .Values.replicaCount }}
  # .Values = מ-values.yaml (או --set)
  
  selector:
    matchLabels:
      app: {{ .Release.Name }}
  
  template:
    metadata:
      labels:
        app: {{ .Release.Name }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          # יוצר: "rick-morty-api:latest"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - containerPort: {{ .Values.service.targetPort }}
          
          livenessProbe:
            httpGet:
              path: {{ .Values.healthcheck.path }}
              port: {{ .Values.service.targetPort }}
            initialDelaySeconds: {{ .Values.healthcheck.initialDelaySeconds }}
            periodSeconds: {{ .Values.healthcheck.periodSeconds }}
          
          readinessProbe:
            httpGet:
              path: {{ .Values.healthcheck.path }}
              port: {{ .Values.service.targetPort }}
            initialDelaySeconds: 5
            periodSeconds: 10
          
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
            # ↑ toYaml = ממיר dict ל-YAML
            # nindent 12 = מוסיף 12 רווחים (indentation)
          
          {{- if .Values.env }}
          # ↑ IF - רק אם יש env ב-values
          env:
            {{- range $key, $value := .Values.env }}
            # ↑ RANGE = loop על כל ה-env vars
            - name: {{ $key }}
              value: {{ $value | quote }}
              # quote = עוטף במרכאות
            {{- end }}
          {{- end }}
```

## פקודות Helm

```bash
# ═══════════════════════════════════════════════════════════════
# התקנה
# ═══════════════════════════════════════════════════════════════
helm install rick-morty ./helm/rick-morty-api
#            └────────┘ └────────────────────┘
#              שם         נתיב ל-Chart

# עם ערכים מותאמים
helm install rick-morty ./helm/rick-morty-api --set replicaCount=3

# ═══════════════════════════════════════════════════════════════
# שדרוג
# ═══════════════════════════════════════════════════════════════
helm upgrade rick-morty ./helm/rick-morty-api

# ═══════════════════════════════════════════════════════════════
# בדיקת תקינות
# ═══════════════════════════════════════════════════════════════
helm lint ./helm/rick-morty-api
# בודק שאין שגיאות ב-Chart

helm template ./helm/rick-morty-api
# מראה את ה-YAMLים שיווצרו (בלי להתקין)

# ═══════════════════════════════════════════════════════════════
# מחיקה
# ═══════════════════════════════════════════════════════════════
helm uninstall rick-morty

# ═══════════════════════════════════════════════════════════════
# רשימה
# ═══════════════════════════════════════════════════════════════
helm list
```

---

# 🔄 שלב 8: CI/CD Pipeline (GitHub Actions)

## מבנה הקובץ

```
.github/
└── workflows/
    └── ci-cd.yaml
```

## קובץ ci-cd.yaml המלא עם הסברים

```yaml
# ═══════════════════════════════════════════════════════════════
# HEADER - שם והגדרות בסיסיות
# ═══════════════════════════════════════════════════════════════
name: CI/CD Pipeline

on:
  push:
    branches: [main, master]      # רץ על push ל-main
  pull_request:
    branches: [main, master]      # רץ על PR
  workflow_dispatch:              # מאפשר הרצה ידנית מה-UI

env:
  IMAGE_NAME: rick-morty-api      # משתנה גלובלי

# ═══════════════════════════════════════════════════════════════
# JOB 1: BUILD & TEST
# ═══════════════════════════════════════════════════════════════
jobs:
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest        # רץ על Ubuntu
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        # ↑ מוריד את הקוד מ-GitHub
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
        # ↑ מתקין Python 3.11
      
      - name: Install dependencies
        run: |
          cd app
          pip install -r requirements.txt
        # ↑ מתקין את הספריות
      
      - name: Run script test
        run: |
          cd app
          python main.py
          echo "Script completed successfully!"
        # ↑ מריץ את הסקריפט - בודק שעובד
      
      - name: Upload CSV artifact
        uses: actions/upload-artifact@v4
        with:
          name: characters-csv
          path: app/output.csv
        # ↑ שומר את הקובץ כ-artifact (אפשר להוריד אחר כך)

  # ═══════════════════════════════════════════════════════════════
  # JOB 2: DOCKER BUILD
  # ═══════════════════════════════════════════════════════════════
  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: build-and-test         # רץ רק אחרי שהקודם הצליח
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        # ↑ מתקין Docker Buildx (build משופר)
      
      - name: Build Docker image
        run: |
          docker build -t ${{ env.IMAGE_NAME }}:${{ github.sha }} .
          docker build -t ${{ env.IMAGE_NAME }}:latest .
        # ↑ בונה עם שני tags: SHA של ה-commit + latest
      
      - name: Test Docker image
        run: |
          # מריץ container
          docker run -d -p 5000:5000 --name test-container ${{ env.IMAGE_NAME }}:latest
          sleep 10
          
          # בודק healthcheck
          curl -f http://localhost:5000/healthcheck || exit 1
          
          # בודק characters
          RESPONSE=$(curl -s http://localhost:5000/characters)
          COUNT=$(echo $RESPONSE | jq '.count')
          
          if [ "$COUNT" -gt 0 ]; then
            echo "API working! $COUNT characters"
          else
            exit 1
          fi
          
          docker stop test-container
          docker rm test-container

  # ═══════════════════════════════════════════════════════════════
  # JOB 3: KUBERNETES DEPLOY
  # ═══════════════════════════════════════════════════════════════
  deploy-k8s:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: docker-build           # רץ אחרי Docker build
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Create kind cluster
        uses: helm/kind-action@v1
        with:
          cluster_name: rick-morty-cluster
        # ↑ יוצר Kubernetes cluster זמני עם kind
      
      - name: Build and load image to kind
        run: |
          docker build -t ${{ env.IMAGE_NAME }}:latest .
          kind load docker-image ${{ env.IMAGE_NAME }}:latest --name rick-morty-cluster
        # ↑ טוען את ה-Image לתוך kind
      
      - name: Deploy to Kubernetes
        run: |
          kubectl apply -f yamls/deployment.yaml
          kubectl apply -f yamls/service.yaml
          
          # ממתין שה-deployment יהיה מוכן
          kubectl wait --for=condition=available --timeout=120s deployment/rick-morty-api
          
          kubectl get pods
          kubectl get services
      
      - name: Test Kubernetes deployment
        run: |
          # Port forward ברקע
          kubectl port-forward service/rick-morty-api-service 8080:80 &
          sleep 5
          
          # בודק endpoints
          curl -f http://localhost:8080/healthcheck || exit 1
          
          RESPONSE=$(curl -s http://localhost:8080/characters)
          COUNT=$(echo $RESPONSE | jq '.count')
          
          if [ "$COUNT" -gt 0 ]; then
            echo "K8s deployment working! $COUNT characters"
          fi

  # ═══════════════════════════════════════════════════════════════
  # JOB 4: HELM LINT
  # ═══════════════════════════════════════════════════════════════
  helm-lint:
    name: Helm Lint
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.12.0
      
      - name: Lint Helm chart
        run: |
          if [ -f "helm/rick-morty-api/Chart.yaml" ]; then
            helm lint helm/rick-morty-api
            echo "Helm lint passed!"
          fi
```

---

# 🔗 שלב 9: העלאה ל-GitHub

## הכנה ראשונית (פעם אחת)

```bash
# ═══════════════════════════════════════════════════════════════
# יצירת .gitignore
# ═══════════════════════════════════════════════════════════════
# צור קובץ .gitignore עם:
__pycache__/
*.pyc
*.pyo
.env
venv/
.venv/
*.egg-info/
dist/
build/
.DS_Store
*.log
.idea/
.vscode/

# ═══════════════════════════════════════════════════════════════
# אתחול Git
# ═══════════════════════════════════════════════════════════════
git init
# יוצר repository חדש בתיקייה

git add .
# מוסיף את כל הקבצים (חוץ מ-.gitignore)

git commit -m "Initial commit - Rick and Morty API"
# יוצר commit ראשון
```

## יצירת Repository ב-GitHub

1. היכנס ל-GitHub.com
2. לחץ על **New Repository**
3. שם: `rick-morty-devops`
4. **אל תסמן** Initialize with README
5. לחץ **Create Repository**

## חיבור והעלאה

```bash
# ═══════════════════════════════════════════════════════════════
# חיבור ל-GitHub
# ═══════════════════════════════════════════════════════════════
git remote add origin https://github.com/YOUR_USERNAME/rick-morty-devops.git
# origin = שם ברירת מחדל ל-remote
# מחליף YOUR_USERNAME בשם המשתמש שלך

# ═══════════════════════════════════════════════════════════════
# העלאה
# ═══════════════════════════════════════════════════════════════
git branch -M main
# משנה את שם ה-branch ל-main

git push -u origin main
# מעלה את הקוד ל-GitHub
# -u = מגדיר upstream (בפעם הבאה מספיק: git push)
```

## עבודה שוטפת

```bash
# ═══════════════════════════════════════════════════════════════
# שינויים חדשים
# ═══════════════════════════════════════════════════════════════
git status                    # בדוק מה השתנה
git add .                     # הוסף את כל השינויים
git commit -m "Add feature X" # צור commit
git push                      # העלה ל-GitHub

# ═══════════════════════════════════════════════════════════════
# משיכת שינויים (אם עבדת ממחשב אחר)
# ═══════════════════════════════════════════════════════════════
git pull                      # מושך שינויים מ-GitHub
```

## מתן הרשאות לבודק

1. בדף ה-Repository, לחץ על **Settings**
2. בצד שמאל: **Collaborators**
3. **Add people**
4. הכנס את כתובת המייל של הבודק
5. לחץ **Add**

---

# 📊 סיכום - מה עשינו ולמה

## טבלת הקבצים והמטרה שלהם

| # | קובץ | מטרה | משימה |
|---|------|------|-------|
| 1 | `app/requirements.txt` | רשימת ספריות | הכנה |
| 2 | `app/main.py` | סקריפט CSV | חובה |
| 3 | `app/api.py` | REST API | בונוס 1 |
| 4 | `Dockerfile` | הוראות בניית Image | בונוס 1 |
| 5 | `yamls/deployment.yaml` | איך להריץ Pods | בונוס 2 |
| 6 | `yamls/service.yaml` | חשיפה פנימית | בונוס 2 |
| 7 | `yamls/ingress.yaml` | חשיפה חיצונית | בונוס 2 |
| 8 | `helm/rick-morty-api/*` | Package Manager | בונוס 3 |
| 9 | `.github/workflows/ci-cd.yaml` | אוטומציה | בונוס 4 |
| 10 | `README.md` | תיעוד | כל המשימות |

## זרימת העבודה המלאה

```
┌─────────────────────────────────────────────────────────────────────┐
│                      DEVELOPMENT FLOW                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   1. כותבים קוד                                                     │
│      └── app/main.py, app/api.py                                    │
│                                                                      │
│   2. בודקים לוקלית                                                  │
│      └── python main.py / python api.py                             │
│                                                                      │
│   3. בונים Docker Image                                             │
│      └── docker build -t rick-morty-api .                           │
│                                                                      │
│   4. בודקים ב-Docker                                                │
│      └── docker run -p 5000:5000 rick-morty-api                     │
│      └── curl localhost:5000/healthcheck                            │
│                                                                      │
│   5. מעלים ל-Git                                                    │
│      └── git add . && git commit && git push                        │
│                                                                      │
│   6. CI/CD רץ אוטומטית                                              │
│      └── Build → Test → Docker → K8s → Helm Lint                    │
│                                                                      │
│   7. הכל ירוק? 🎉                                                   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

**טיפ אחרון לראיון:**
אל תפחד להגיד "אני לא יודע".
עדיף להגיד "אני לא בטוח, אבל הייתי בודק ככה..." מאשר להמציא תשובה.

---

**בהצלחה בראיון!** 🚀

</div>
