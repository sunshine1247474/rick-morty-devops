צריך <div dir="rtl" align="right">

# 📘 מדריך DevOps מקיף - הכנה לראיון עבודה

## פרויקט Rick and Morty API - מהקוד ועד לענן

---

# מבוא

מדריך זה נכתב עבור מי שמתכונן לראיון עבודה בתחום ה-DevOps.
המדריך עוקב אחרי פרויקט אמיתי, צעד אחר צעד, ומסביר כל מושג בצורה פשוטה.

**מה תלמד במדריך זה:**
- מה זה API ואיך עובדים איתו
- איך כותבים סקריפט ב-Python
- מה זה Docker ולמה הוא חשוב
- מה זה Kubernetes ואיך משתמשים בו
- מושגים שמראיינים אוהבים לשאול עליהם

---

# פרק 1: הבנת המשימה

## 1.1 מה התבקשנו לעשות?

קיבלנו תרגיל בית עם הדרישות הבאות:

**משימות חובה:**
1. לכתוב סקריפט שקורא נתונים מ-API
2. לסנן את הנתונים לפי קריטריונים מסוימים
3. לשמור את התוצאות לקובץ CSV
4. להעלות את הקוד ל-GitHub

**משימות בונוס:**
5. להפוך את הסקריפט לשירות עם Docker
6. לפרוס את השירות ב-Kubernetes
7. ליצור Helm Chart
8. לבנות CI/CD Pipeline

## 1.2 למה דווקא המשימות האלה?

המשימות האלה מייצגות את **מחזור החיים המלא** של אפליקציה:

</div>

```
קוד ← בדיקה ← אריזה ← פריסה ← ניטור
Code → Test → Package → Deploy → Monitor
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "תאר את מחזור החיים של אפליקציה מהפיתוח ועד הפרודקשן"

**תשובה טובה:** "האפליקציה עוברת מספר שלבים: כתיבת קוד, בדיקות אוטומטיות, אריזה לקונטיינר עם Docker, פריסה לסביבת Kubernetes, וניטור מתמשך. כל שלב מנוהל על ידי Pipeline אוטומטי."

---

# פרק 2: מה זה API?

## 2.1 הגדרה פשוטה

**API** (Application Programming Interface) = ממשק תכנות יישומים

בפשטות: זו הדרך שבה תוכנות מדברות אחת עם השנייה.

**דוגמה מהחיים:**
כשאתה מזמין אוכל דרך אפליקציה, האפליקציה שולחת בקשה ל-API של המסעדה.
ה-API מחזיר את התפריט, המחירים, וזמני המשלוח.

## 2.2 מה זה REST API?

**REST** (Representational State Transfer) = סגנון ארכיטקטוני לבניית API

**עקרונות REST:**

| עיקרון | הסבר |
|--------|------|
| Stateless | כל בקשה עומדת בפני עצמה |
| Client-Server | הפרדה בין הלקוח לשרת |
| Uniform Interface | ממשק אחיד ועקבי |
| Cacheable | ניתן לשמור תשובות במטמון |

## 2.3 שיטות HTTP

**שאלת ראיון נפוצה:** "מה ההבדל בין GET ל-POST?"

</div>

```
┌──────────┬────────────────────────────────────────┐
│  Method  │  שימוש                                 │
├──────────┼────────────────────────────────────────┤
│  GET     │  קבלת מידע (קריאה בלבד)              │
│  POST    │  יצירת משאב חדש                       │
│  PUT     │  עדכון משאב קיים (מחליף לגמרי)       │
│  PATCH   │  עדכון חלקי של משאב                  │
│  DELETE  │  מחיקת משאב                          │
└──────────┴────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 2.4 קודי תגובה HTTP

**שאלת ראיון נפוצה:** "מה המשמעות של קוד 404? ומה 500?"

</div>

```
┌──────────┬────────────────────────────────────────┐
│  קוד     │  משמעות                               │
├──────────┼────────────────────────────────────────┤
│  200     │  OK - הבקשה הצליחה                    │
│  201     │  Created - נוצר משאב חדש              │
│  400     │  Bad Request - בקשה שגויה            │
│  401     │  Unauthorized - לא מורשה             │
│  403     │  Forbidden - אסור (גם עם הרשאה)      │
│  404     │  Not Found - המשאב לא נמצא           │
│  500     │  Internal Server Error - שגיאת שרת   │
│  502     │  Bad Gateway - שגיאה בשרת ביניים     │
│  503     │  Service Unavailable - השירות לא זמין│
└──────────┴────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 2.5 ה-API שעבדנו איתו

**כתובת ה-API:** `https://rickandmortyapi.com/api/character`

**מה מקבלים בתגובה:**

</div>

```json
{
  "info": {
    "count": 826,
    "pages": 42,
    "next": "https://rickandmortyapi.com/api/character?page=2",
    "prev": null
  },
  "results": [
    {
      "id": 1,
      "name": "Rick Sanchez",
      "status": "Alive",
      "species": "Human",
      "origin": {
        "name": "Earth (C-137)"
      },
      "location": {
        "name": "Citadel of Ricks"
      },
      "image": "https://rickandmortyapi.com/api/character/avatar/1.jpeg"
    }
  ]
}
```

<div dir="rtl" align="right">

---

# פרק 3: כתיבת הסקריפט ב-Python

## 3.1 מה זה Python?

Python היא שפת תכנות פופולרית מאוד בעולם ה-DevOps בגלל:
- קלה ללמידה
- ספריות רבות (libraries)
- מתאימה לאוטומציה
- קהילה גדולה

## 3.2 מה זה Pagination?

**שאלת ראיון נפוצה:** "איך מטפלים ב-API שמחזיר הרבה נתונים?"

**Pagination** = חלוקת נתונים לעמודים

**למה צריך?**
- ה-API שלנו מחזיר 826 דמויות
- לא הגיוני להחזיר הכל בבקשה אחת
- לכן ה-API מחזיר 20 דמויות בכל עמוד = 42 עמודים

**איך מטפלים?**

</div>

```
בקשה ראשונה:
GET /character?page=1
    ↓
תגובה: 20 דמויות + לינק לעמוד הבא
    ↓
בקשה שנייה:
GET /character?page=2
    ↓
תגובה: 20 דמויות + לינק לעמוד הבא
    ↓
... וכך הלאה עד עמוד 42
```

<div dir="rtl" align="right">

## 3.3 הקוד שכתבנו - הסבר מלא

**קובץ: main.py**

</div>

```python
#!/usr/bin/env python3
"""
סקריפט לשליפת דמויות מ-Rick and Morty API
"""

# ייבוא ספריות
import requests  # לשליחת בקשות HTTP
import csv       # לכתיבה לקובץ CSV

# כתובת ה-API
API_BASE_URL = "https://rickandmortyapi.com/api/character"


def fetch_all_characters():
    """
    שולף את כל הדמויות מה-API.
    מטפל ב-Pagination אוטומטית.
    """
    all_characters = []  # רשימה ריקה לאחסון כל הדמויות
    url = API_BASE_URL   # מתחילים מהעמוד הראשון
    
    while url:  # כל עוד יש עמוד הבא
        response = requests.get(url)  # שולחים בקשת GET
        response.raise_for_status()   # אם יש שגיאה - זורקים exception
        data = response.json()        # ממירים את התגובה ל-JSON
        
        all_characters.extend(data['results'])  # מוסיפים את הדמויות לרשימה
        url = data['info']['next']  # מעדכנים ל-URL הבא (או None אם נגמר)
    
    return all_characters


def filter_characters(characters):
    """
    מסנן דמויות לפי הקריטריונים:
    - species = Human (אנושי)
    - status = Alive (חי)
    - origin = Earth (מכדור הארץ)
    """
    filtered = []
    
    for char in characters:
        # בודקים כל קריטריון
        is_human = char['species'] == 'Human'
        is_alive = char['status'] == 'Alive'
        is_from_earth = 'Earth' in char['origin']['name']
        
        # אם כל התנאים מתקיימים
        if is_human and is_alive and is_from_earth:
            filtered.append({
                'Name': char['name'],
                'Location': char['location']['name'],
                'Image': char['image']
            })
    
    return filtered


def write_to_csv(characters, filename='output.csv'):
    """
    כותב את הדמויות לקובץ CSV.
    """
    with open(filename, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=['Name', 'Location', 'Image'])
        writer.writeheader()  # כותב את כותרות העמודות
        writer.writerows(characters)  # כותב את כל השורות
    
    print(f"נכתבו {len(characters)} דמויות לקובץ {filename}")


def main():
    """
    הפונקציה הראשית - מריצה את כל התהליך.
    """
    print("שולף דמויות מה-API...")
    
    # שלב 1: שליפת כל הדמויות
    all_characters = fetch_all_characters()
    print(f"סה״כ דמויות: {len(all_characters)}")
    
    # שלב 2: סינון
    filtered = filter_characters(all_characters)
    print(f"דמויות שעברו סינון: {len(filtered)}")
    
    # שלב 3: כתיבה לקובץ
    write_to_csv(filtered)


# נקודת הכניסה לתוכנית
if __name__ == "__main__":
    main()
```

<div dir="rtl" align="right">

## 3.4 מושגים חשובים בקוד

**שאלת ראיון נפוצה:** "מה זה `if __name__ == "__main__"`?"

**תשובה:** זה בודק אם הקובץ רץ ישירות (ולא מיובא כמודול).
- אם מריצים `python main.py` → הקוד ב-if ירוץ
- אם עושים `import main` מקובץ אחר → הקוד ב-if לא ירוץ

**שאלת ראיון נפוצה:** "מה ההבדל בין append ל-extend?"

</div>

```python
# append - מוסיף אלמנט אחד
list1 = [1, 2, 3]
list1.append([4, 5])
# תוצאה: [1, 2, 3, [4, 5]]

# extend - מוסיף את האלמנטים של הרשימה
list2 = [1, 2, 3]
list2.extend([4, 5])
# תוצאה: [1, 2, 3, 4, 5]
```

<div dir="rtl" align="right">

---

# פרק 4: מה זה Docker?

## 4.1 הבעיה שלפני Docker

**המצב ההיסטורי:**

</div>

```
מפתח 1:              מפתח 2:              שרת Production:
─────────            ─────────            ────────────────
Python 3.9           Python 3.11          Python 3.8
Windows              Mac                  Linux
Flask 2.0            Flask 3.0            Flask 1.0

        "אצלי זה עובד!" - כולם אומרים
```

<div dir="rtl" align="right">

## 4.2 מה Docker פותר?

**Docker** יוצר "קופסה" (Container) שבתוכה יש את כל מה שהאפליקציה צריכה.

</div>

```
┌─────────────────────────────────────────────────────────┐
│                   Docker Container                       │
│  ┌───────────────────────────────────────────────────┐  │
│  │  מערכת הפעלה (Linux)                              │  │
│  │  Python 3.11                                      │  │
│  │  Flask 3.0                                        │  │
│  │  הקוד שלנו                                        │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                         │
     ┌───────────────────┼───────────────────┐
     ▼                   ▼                   ▼
 Developer           Developer            Server
 (Windows)           (Mac)                (Linux)

              עובד אצל כולם!
```

<div dir="rtl" align="right">

## 4.3 מושגי יסוד ב-Docker

**שאלת ראיון נפוצה:** "מה ההבדל בין Image ל-Container?"

| מושג | הסבר | משל |
|------|------|-----|
| **Image** | תבנית לקריאה בלבד | מתכון לעוגה |
| **Container** | מופע רץ של Image | העוגה עצמה |
| **Dockerfile** | קובץ הוראות לבניית Image | רשימת המצרכים והוראות |
| **Registry** | מאגר לאחסון Images | חנות מתכונים (Docker Hub) |

**שאלת ראיון נפוצה:** "מה ההבדל בין Container ל-Virtual Machine?"

</div>

```
Virtual Machine:                    Container:
────────────────                    ──────────

┌──────────────────┐               ┌──────────────────┐
│   Application    │               │   Application    │
├──────────────────┤               ├──────────────────┤
│   Guest OS       │               │   (No OS!)       │
│   (Full Linux)   │               │                  │
├──────────────────┤               ├──────────────────┤
│   Hypervisor     │               │  Docker Engine   │
├──────────────────┤               ├──────────────────┤
│   Host OS        │               │   Host OS        │
├──────────────────┤               ├──────────────────┤
│   Hardware       │               │   Hardware       │
└──────────────────┘               └──────────────────┘

גודל: GB                           גודל: MB
עלייה: דקות                        עלייה: שניות
```

<div dir="rtl" align="right">

## 4.4 ה-Dockerfile שלנו - שורה אחרי שורה

</div>

```dockerfile
# ═══════════════════════════════════════════════════════════════
# שורה 1: FROM - מאיזו תמונת בסיס להתחיל?
# ═══════════════════════════════════════════════════════════════
FROM python:3.11-slim
# python:3.11-slim = תמונה רשמית של Python גרסה 3.11
# slim = גרסה "רזה" - בלי extras מיותרים (קטנה יותר)

# ═══════════════════════════════════════════════════════════════
# שורה 2: WORKDIR - באיזו תיקייה לעבוד בתוך הקונטיינר?
# ═══════════════════════════════════════════════════════════════
WORKDIR /app
# יוצר תיקייה /app ועובר אליה
# כל הפקודות הבאות יתבצעו מתוך /app

# ═══════════════════════════════════════════════════════════════
# שורה 3-4: התקנת dependencies
# ═══════════════════════════════════════════════════════════════
COPY app/requirements.txt .
# מעתיק את קובץ הדרישות מהמחשב שלנו לתוך הקונטיינר

RUN pip install --no-cache-dir -r requirements.txt
# מתקין את הספריות (Flask, requests)
# --no-cache-dir = לא שומר cache (חוסך מקום)

# ═══════════════════════════════════════════════════════════════
# שורה 5: העתקת הקוד
# ═══════════════════════════════════════════════════════════════
COPY app/ .
# מעתיק את כל התיקייה app/ לתוך /app בקונטיינר

# ═══════════════════════════════════════════════════════════════
# שורה 6: EXPOSE - איזה פורט האפליקציה מאזינה?
# ═══════════════════════════════════════════════════════════════
EXPOSE 5000
# מסמן שהאפליקציה מאזינה על פורט 5000
# הערה: זה רק תיעוד! לא באמת פותח פורט

# ═══════════════════════════════════════════════════════════════
# שורה 7: CMD - מה להריץ כשהקונטיינר עולה?
# ═══════════════════════════════════════════════════════════════
CMD ["python", "api.py"]
# מריץ את הפקודה: python api.py
```

<div dir="rtl" align="right">

## 4.5 Docker Layer Caching

**שאלת ראיון נפוצה:** "למה חשוב סדר הפקודות ב-Dockerfile?"

כל שורה ב-Dockerfile יוצרת **Layer** (שכבה).
Docker שומר את השכבות במטמון.
אם שכבה לא השתנתה, Docker משתמש בגרסה השמורה.

**למה קודם מעתיקים requirements.txt ורק אחר כך את הקוד?**

</div>

```
Build ראשון:                    Build שני (שינוי בקוד):
────────────                    ────────────────────────

Layer 1: FROM python      →    Layer 1: FROM python      [CACHED]
Layer 2: COPY requirements →   Layer 2: COPY requirements [CACHED]
Layer 3: RUN pip install  →    Layer 3: RUN pip install  [CACHED]
Layer 4: COPY app/        →    Layer 4: COPY app/        [REBUILD]
Layer 5: CMD              →    Layer 5: CMD              [REBUILD]

זמן: 60 שניות                   זמן: 5 שניות!
```

<div dir="rtl" align="right">

אם היינו מעתיקים קודם את הקוד, כל שינוי קטן היה גורם להתקנה מחדש של כל הספריות!

## 4.6 פקודות Docker חיוניות

**שאלת ראיון נפוצה:** "תראה לי את פקודות Docker הבסיסיות"

</div>

```bash
# ═══════════════════════════════════════════════════════════════
# בניית Image
# ═══════════════════════════════════════════════════════════════
docker build -t rick-morty-api .
#        │    └─────────────────┘ └┘
#        │           שם             הקובץ נמצא בתיקייה הנוכחית
#        └── build = בנה image

# ═══════════════════════════════════════════════════════════════
# הרצת Container
# ═══════════════════════════════════════════════════════════════
docker run -d -p 5000:5000 --name my-api rick-morty-api
#          │  └──────────┘ └──────────┘ └─────────────┘
#          │  port mapping   שם          שם ה-image
#          │  host:container
#          └── detached (ברקע)

# ═══════════════════════════════════════════════════════════════
# הצגת Containers רצים
# ═══════════════════════════════════════════════════════════════
docker ps
# מציג רק containers פעילים

docker ps -a
# מציג את כל ה-containers (גם עצורים)

# ═══════════════════════════════════════════════════════════════
# צפייה בלוגים
# ═══════════════════════════════════════════════════════════════
docker logs my-api
# מציג את הלוגים של הקונטיינר

docker logs -f my-api
# מציג לוגים בזמן אמת (follow)

# ═══════════════════════════════════════════════════════════════
# כניסה לתוך Container
# ═══════════════════════════════════════════════════════════════
docker exec -it my-api /bin/bash
#           │││
#           │└┴── interactive + tty (טרמינל אינטראקטיבי)
#           └── execute = הרץ פקודה

# ═══════════════════════════════════════════════════════════════
# עצירה ומחיקה
# ═══════════════════════════════════════════════════════════════
docker stop my-api     # עוצר את הקונטיינר
docker rm my-api       # מוחק את הקונטיינר
docker rmi rick-morty-api  # מוחק את ה-image
```

<div dir="rtl" align="right">

---

# פרק 5: מה זה Kubernetes?

## 5.1 למה צריך Kubernetes?

**המצב עם Docker בלבד:**

</div>

```
┌─────────────────┐
│   Container     │  ← אם נופל - אף אחד לא מרים אותו
│   rick-morty    │  ← אם יש עומס - אין אפשרות להוסיף עותקים
│                 │  ← אין חלוקת עומסים
└─────────────────┘
```

<div dir="rtl" align="right">

**מה Kubernetes פותר:**

</div>

```
┌──────────────────────────────────────────────────────────┐
│                  Kubernetes Cluster                       │
│                                                          │
│   ┌─────────┐  ┌─────────┐  ┌─────────┐                 │
│   │  Pod 1  │  │  Pod 2  │  │  Pod 3  │  ← Scaling      │
│   │   API   │  │   API   │  │   API   │    אוטומטי     │
│   └─────────┘  └─────────┘  └─────────┘                 │
│        │            │            │                       │
│        └────────────┼────────────┘                       │
│                     │                                    │
│              Load Balancing                              │
│              חלוקת עומסים                               │
│                                                          │
│   + Self Healing - אם Pod נופל, קם חדש אוטומטית        │
│   + Rolling Updates - עדכונים בלי downtime             │
│   + Service Discovery - Pods מוצאים אחד את השני        │
└──────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 5.2 מושגי יסוד ב-Kubernetes

**שאלת ראיון נפוצה:** "מה זה Pod?"

| מושג | הסבר | משל |
|------|------|-----|
| **Cluster** | קבוצת שרתים שמנהלים יחד | עיר שלמה |
| **Node** | שרת בודד בקלאסטר | בניין בעיר |
| **Pod** | יחידת ההרצה הקטנה ביותר. מכיל Container אחד או יותר | דירה בבניין |
| **Deployment** | מגדיר איך להריץ Pods (כמה עותקים, איזה image) | חוזה שכירות |
| **Service** | חושף Pods לתקשורת. מאפשר Load Balancing | דלפק קבלה |
| **Ingress** | חושף שירותים לעולם החיצוני עם domain | כתובת הבניין |

## 5.3 הקבצים שיצרנו ומה הם עושים

</div>

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  deployment.yaml ──▶ service.yaml ──▶ ingress.yaml              │
│                                                                  │
│       "מה"              "איך"           "איפה"                   │
│       להריץ             להגיע           לחשוף                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 5.4 Deployment - הסבר מלא

**קובץ: yamls/deployment.yaml**

</div>

```yaml
apiVersion: apps/v1       # גרסת ה-API של Kubernetes
kind: Deployment          # סוג המשאב
metadata:
  name: rick-morty-api    # שם הפריסה
  labels:
    app: rick-morty-api   # תוויות לזיהוי

spec:
  replicas: 2             # כמה עותקים (Pods) להריץ
  
  selector:
    matchLabels:
      app: rick-morty-api # לאילו Pods הפריסה שייכת
  
  template:               # תבנית ליצירת Pod
    metadata:
      labels:
        app: rick-morty-api
    spec:
      containers:
      - name: rick-morty-api
        image: rick-morty-api:latest  # איזה Docker Image
        ports:
        - containerPort: 5000         # איזה פורט

        # ═══════════════════════════════════════════════════════
        # Liveness Probe - בדיקת חיים
        # אם נכשל: Kubernetes יעשה restart ל-Pod
        # ═══════════════════════════════════════════════════════
        livenessProbe:
          httpGet:
            path: /healthcheck
            port: 5000
          initialDelaySeconds: 10   # המתן 10 שניות לפני בדיקה ראשונה
          periodSeconds: 30         # בדוק כל 30 שניות

        # ═══════════════════════════════════════════════════════
        # Readiness Probe - בדיקת מוכנות
        # אם נכשל: לא ישלחו traffic ל-Pod הזה
        # ═══════════════════════════════════════════════════════
        readinessProbe:
          httpGet:
            path: /healthcheck
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 10

        # ═══════════════════════════════════════════════════════
        # Resource Limits - הגבלת משאבים
        # ═══════════════════════════════════════════════════════
        resources:
          requests:         # מינימום מובטח
            memory: "64Mi"  # 64 מגה זיכרון
            cpu: "100m"     # 0.1 CPU (100 millicores)
          limits:           # מקסימום מותר
            memory: "128Mi"
            cpu: "200m"
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "מה ההבדל בין Liveness Probe ל-Readiness Probe?"

| Probe | מטרה | מה קורה אם נכשל |
|-------|------|-----------------|
| **Liveness** | לבדוק אם האפליקציה חיה | Restart ל-Container |
| **Readiness** | לבדוק אם האפליקציה מוכנה | לא שולחים traffic |

**דוגמה:** 
- אפליקציה עלתה אבל עדיין טוענת נתונים
- Liveness יעבור (היא חיה)
- Readiness ייכשל (היא לא מוכנה לקבל בקשות)

## 5.5 Service - הסבר מלא

**קובץ: yamls/service.yaml**

</div>

```yaml
apiVersion: v1
kind: Service
metadata:
  name: rick-morty-api-service
  labels:
    app: rick-morty-api

spec:
  type: ClusterIP         # סוג השירות (ראה טבלה למטה)
  ports:
  - port: 80              # הפורט שהשירות חושף
    targetPort: 5000      # הפורט של ה-Container
    protocol: TCP
  selector:
    app: rick-morty-api   # לאילו Pods לנתב (לפי labels)
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "מה ההבדל בין סוגי Service?"

| סוג | נגישות | שימוש |
|-----|--------|-------|
| **ClusterIP** | רק מתוך הקלאסטר | שירותים פנימיים |
| **NodePort** | דרך פורט על כל Node | פיתוח ובדיקות |
| **LoadBalancer** | דרך Load Balancer חיצוני | פרודקשן בענן |

## 5.6 Ingress - הסבר מלא

**קובץ: yamls/ingress.yaml**

</div>

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: rick-morty-api-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /

spec:
  ingressClassName: nginx    # איזה Ingress Controller
  rules:
  - host: rick-morty.local   # ה-domain
    http:
      paths:
      - path: /              # הנתיב
        pathType: Prefix
        backend:
          service:
            name: rick-morty-api-service  # לאיזה Service לנתב
            port:
              number: 80
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "מה ההבדל בין Service ל-Ingress?"

| רכיב | תפקיד |
|------|-------|
| **Service** | חשיפה פנימית + Load Balancing בין Pods |
| **Ingress** | חשיפה חיצונית + ניתוב לפי domain/path + SSL |

## 5.7 פקודות kubectl חיוניות

**שאלת ראיון נפוצה:** "איך בודקים מצב של Pods בקלאסטר?"

</div>

```bash
# ═══════════════════════════════════════════════════════════════
# הצגת משאבים
# ═══════════════════════════════════════════════════════════════
kubectl get pods              # הצג את כל ה-Pods
kubectl get pods -o wide      # הצג עם מידע נוסף (IP, Node)
kubectl get services          # הצג את כל ה-Services
kubectl get deployments       # הצג את כל ה-Deployments
kubectl get ingress           # הצג את כל ה-Ingresses
kubectl get all               # הצג הכל

# ═══════════════════════════════════════════════════════════════
# יישום קבצי YAML
# ═══════════════════════════════════════════════════════════════
kubectl apply -f deployment.yaml   # יישם קובץ בודד
kubectl apply -f yamls/            # יישם כל הקבצים בתיקייה

# ═══════════════════════════════════════════════════════════════
# מידע מפורט
# ═══════════════════════════════════════════════════════════════
kubectl describe pod <pod-name>    # מידע מפורט על Pod
kubectl logs <pod-name>            # לוגים של Pod
kubectl logs -f <pod-name>         # לוגים בזמן אמת

# ═══════════════════════════════════════════════════════════════
# ניפוי באגים
# ═══════════════════════════════════════════════════════════════
kubectl exec -it <pod-name> -- /bin/bash   # כניסה ל-Pod
kubectl port-forward svc/my-service 8080:80 # העברת פורט

# ═══════════════════════════════════════════════════════════════
# מחיקה
# ═══════════════════════════════════════════════════════════════
kubectl delete -f deployment.yaml  # מחק לפי קובץ
kubectl delete pod <pod-name>      # מחק Pod ספציפי
```

<div dir="rtl" align="right">

---

# פרק 6: הזרימה המלאה - איך הכל מתחבר

## 6.1 תרשים מקיף

</div>

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              התמונה הגדולה                                   │
└─────────────────────────────────────────────────────────────────────────────┘

                    משתמש מהאינטרנט
                          │
                          │ HTTP Request
                          │ http://rick-morty.local/characters
                          ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Kubernetes Cluster                                  │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           INGRESS                                       │ │
│  │                                                                         │ │
│  │  1. מקבל את הבקשה                                                       │ │
│  │  2. בודק את ה-host (rick-morty.local)                                  │ │
│  │  3. בודק את ה-path (/)                                                 │ │
│  │  4. מעביר ל-Service המתאים                                             │ │
│  │                                                                         │ │
│  └────────────────────────────────────┬───────────────────────────────────┘ │
│                                       │                                      │
│  ┌────────────────────────────────────┼───────────────────────────────────┐ │
│  │                           SERVICE                                       │ │
│  │                                    │                                    │ │
│  │  1. מקבל את הבקשה מ-Ingress       │                                    │ │
│  │  2. מחפש Pods עם התווית המתאימה   │                                    │ │
│  │  3. מפזר עומסים (Load Balance)     │                                    │ │
│  │  4. מעביר ל-Pod שנבחר             │                                    │ │
│  │                                    │                                    │ │
│  │                    ┌───────────────┴───────────────┐                    │ │
│  │                    │                               │                    │ │
│  └────────────────────┼───────────────────────────────┼────────────────────┘ │
│                       │                               │                      │
│          ┌────────────┴─────────────┐    ┌───────────┴────────────┐         │
│          ▼                          ▼    ▼                        ▼         │
│  ┌───────────────┐          ┌───────────────┐          ┌───────────────┐    │
│  │     POD 1     │          │     POD 2     │          │     POD N     │    │
│  │ ┌───────────┐ │          │ ┌───────────┐ │          │ ┌───────────┐ │    │
│  │ │ Container │ │          │ │ Container │ │          │ │ Container │ │    │
│  │ │           │ │          │ │           │ │          │ │           │ │    │
│  │ │  api.py   │ │          │ │  api.py   │ │          │ │  api.py   │ │    │
│  │ │  Flask    │ │          │ │  Flask    │ │          │ │  Flask    │ │    │
│  │ │  :5000    │ │          │ │  :5000    │ │          │ │  :5000    │ │    │
│  │ │           │ │          │ │           │ │          │ │           │ │    │
│  │ └───────────┘ │          │ └───────────┘ │          │ └───────────┘ │    │
│  └───────────────┘          └───────────────┘          └───────────────┘    │
│          │                          │                          │            │
│          │                          │                          │            │
│          └──────────────────────────┴──────────────────────────┘            │
│                                     │                                        │
│                           DEPLOYMENT                                        │
│                      (מנהל את כל ה-Pods)                                    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      │ HTTP Request
                                      ▼
                         ┌─────────────────────────┐
                         │  Rick and Morty API     │
                         │  rickandmortyapi.com    │
                         └─────────────────────────┘
```

<div dir="rtl" align="right">

## 6.2 מה קורה כשמשתמש שולח בקשה?

**שלב 1: Ingress**
- מקבל בקשה ל-`rick-morty.local/characters`
- בודק את כללי הניתוב
- מעביר ל-Service `rick-morty-api-service` על פורט 80

**שלב 2: Service**
- מקבל את הבקשה
- מוצא את כל ה-Pods עם `app: rick-morty-api`
- בוחר Pod (Round Robin / Random)
- מעביר את הבקשה לפורט 5000 של ה-Pod

**שלב 3: Pod**
- ה-Container מקבל את הבקשה
- Flask מזהה את הנתיב `/characters`
- הקוד קורא מ-Rick and Morty API
- מסנן את הדמויות
- מחזיר JSON

**שלב 4: חזרה**
- התגובה עוברת: Pod ← Service ← Ingress ← משתמש

---

# פרק 7: שאלות ראיון נפוצות - סיכום

## 7.1 שאלות על API

| שאלה | תשובה |
|------|-------|
| מה זה REST API? | ארכיטקטורה לתקשורת בין מערכות המבוססת על HTTP |
| מה ההבדל בין GET ל-POST? | GET לקריאה, POST ליצירה |
| מה זה Status Code 500? | שגיאה בצד השרת |
| איך מטפלים ב-Pagination? | קוראים עמוד-עמוד עד שאין next |

## 7.2 שאלות על Docker

| שאלה | תשובה |
|------|-------|
| מה ההבדל בין Image ל-Container? | Image = תבנית, Container = מופע רץ |
| למה Docker ולא VM? | יותר קל, מהיר, וצורך פחות משאבים |
| מה עושה EXPOSE? | מתעד איזה פורט האפליקציה מאזינה (לא פותח באמת) |
| מה ההבדל בין CMD ל-ENTRYPOINT? | CMD ניתן לדריסה, ENTRYPOINT קבוע |

## 7.3 שאלות על Kubernetes

| שאלה | תשובה |
|------|-------|
| מה זה Pod? | יחידת ההרצה הקטנה ביותר, מכיל Container אחד או יותר |
| מה ההבדל בין Deployment ל-Pod? | Deployment מנהל Pods (replicas, updates) |
| מתי משתמשים ב-ClusterIP? | לשירותים פנימיים בלבד |
| מה עושה Liveness Probe? | בודק אם האפליקציה חיה. אם לא - restart |

---

# פרק 8: מבנה הפרויקט הסופי

</div>

```
rick-morty-devops/
│
├── app/                          # קוד האפליקציה
│   ├── main.py                   # סקריפט שמייצר CSV
│   ├── api.py                    # שרת REST API
│   ├── requirements.txt          # ספריות Python נדרשות
│   └── output.csv                # קובץ הפלט
│
├── yamls/                        # קבצי Kubernetes
│   ├── deployment.yaml           # הגדרת הפריסה
│   ├── service.yaml              # הגדרת השירות
│   └── ingress.yaml              # הגדרת הכניסה
│
├── Dockerfile                    # הוראות לבניית Docker Image
├── .gitignore                    # קבצים להתעלמות ב-Git
└── README.md                     # תיעוד הפרויקט
```

<div dir="rtl" align="right">

---

# פרק 9: מפת הקשרים - איך הכל מתחבר

## 9.1 המפה הגדולה - כל הפרויקט במבט אחד

</div>

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│                          🗺️ MINDMAP - מפת הפרויקט המלאה                                │
│                                                                                         │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                         │
│                                ┌─────────────────────┐                                  │
│                                │   🎯 המשימה שלנו   │                                  │
│                                │  Rick & Morty API   │                                  │
│                                └──────────┬──────────┘                                  │
│                                           │                                             │
│                ┌──────────────────────────┼──────────────────────────┐                  │
│                │                          │                          │                  │
│                ▼                          ▼                          ▼                  │
│     ┌─────────────────┐       ┌─────────────────┐       ┌─────────────────┐            │
│     │  📊 DATA        │       │  🔧 CODE        │       │  🚀 DEPLOY      │            │
│     │  מאיפה המידע?   │       │  איך מעבדים?    │       │  איך מריצים?    │            │
│     └────────┬────────┘       └────────┬────────┘       └────────┬────────┘            │
│              │                         │                         │                      │
│              ▼                         ▼                         ▼                      │
│ ┌─────────────────────────┐  ┌─────────────────────────┐  ┌─────────────────────────┐  │
│ │ rickandmortyapi.com     │  │ Python Scripts          │  │ Docker + Kubernetes     │  │
│ │ └─▶ 826 דמויות         │  │ └─▶ main.py (CSV)       │  │ └─▶ Container           │  │
│ │ └─▶ 42 עמודים          │  │ └─▶ api.py (REST)       │  │ └─▶ Pods                │  │
│ │ └─▶ JSON format        │  │ └─▶ סינון + עיבוד       │  │ └─▶ Services            │  │
│ └─────────────────────────┘  └─────────────────────────┘  └─────────────────────────┘  │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 9.2 זרימת הנתונים - השרשרת המלאה

</div>

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│                          📡 THE CHAIN - שרשרת הבקשה                                     │
│                                                                                         │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                         │
│   User Request                                                                          │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  INGRESS (rick-morty.local)                                                      │  │
│   │  • בודק host ו-path                                                              │  │
│   │  • מעביר לשירות המתאים                                                           │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  SERVICE (finds pods by label, load balance)                                     │  │
│   │  • מוצא את ה-Pods לפי label                                                      │  │
│   │  • מפזר עומסים בין ה-Pods                                                        │  │
│   │  • ממיר port 80 → 5000                                                          │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  POD (runs container from image)                                                 │  │
│   │  • מריץ Container מה-Docker Image                                                │  │
│   │  • liveness + readiness probes בודקים אותו                                       │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  CONTAINER (runs api.py on port 5000)                                            │  │
│   │  • Python + Flask                                                                │  │
│   │  • מאזין על port 5000                                                            │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  FLASK (handles /characters route)                                               │  │
│   │  • מזהה את הנתיב /characters                                                     │  │
│   │  • קורא לפונקציה המתאימה                                                         │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  PYTHON CODE (calls external API, filters data)                                  │  │
│   │  • שולח בקשות ל-Rick & Morty API                                                 │  │
│   │  • מטפל ב-Pagination (42 עמודים)                                                 │  │
│   │  • מסנן: Human + Alive + Earth                                                   │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  RICK & MORTY API (External)                                                     │  │
│   │  • 826 דמויות ב-42 עמודים                                                        │  │
│   │  • מחזיר JSON                                                                    │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  FILTER (109 characters remain)                                                  │  │
│   │  species == "Human" ✓                                                            │  │
│   │  status == "Alive" ✓                                                             │  │
│   │  origin contains "Earth" ✓                                                       │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   JSON Response back to User                                                            │
│   {"count": 109, "characters": [...]}                                                   │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 9.3 מפת הקבצים - מי תלוי במי?

</div>

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│                      📁 FILE DEPENDENCIES - תלויות בין קבצים                           │
│                                                                                         │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                         │
│   requirements.txt                                                                      │
│        │                                                                                │
│        │ pip install                                                                    │
│        ▼                                                                                │
│   ┌─────────────┐                         ┌─────────────┐                               │
│   │  main.py    │                         │   api.py    │                               │
│   │  imports:   │                         │  imports:   │                               │
│   │  - requests │                         │  - requests │                               │
│   │  - csv      │                         │  - flask    │                               │
│   │             │                         │             │                               │
│   │  OUTPUT:    │                         │  ENDPOINTS: │                               │
│   │  output.csv │                         │ /characters │                               │
│   └─────────────┘                         │ /healthcheck│                               │
│                                           └──────┬──────┘                               │
│                                                  │                                      │
│                                                  │ runs                                 │
│                                                  ▼                                      │
│                                           ┌─────────────┐                               │
│                                           │ Dockerfile  │                               │
│                                           │ CMD api.py  │                               │
│                                           └──────┬──────┘                               │
│                                                  │                                      │
│                                                  │ creates                              │
│                                                  ▼                                      │
│                                           ┌─────────────┐                               │
│                                           │Docker Image │                               │
│                                           │rick-morty-api                               │
│                                           └──────┬──────┘                               │
│                                                  │                                      │
│                          ┌───────────────────────┼───────────────────────┐              │
│                          │                       │                       │              │
│                          ▼                       ▼                       ▼              │
│                  ┌───────────────┐      ┌───────────────┐      ┌───────────────┐        │
│                  │deployment.yaml│      │ service.yaml  │      │ ingress.yaml  │        │
│                  │               │      │               │      │               │        │
│                  │ image: rick-  │      │ selector:     │      │ backend:      │        │
│                  │ morty-api     │◀─────│ app: rick-    │◀─────│ service:      │        │
│                  │               │      │ morty-api     │      │ rick-morty    │        │
│                  │ labels:       │──────▶               │      │               │        │
│                  │ app: rick-    │      │               │      │               │        │
│                  │ morty-api     │      │               │      │               │        │
│                  │               │      │               │      │               │        │
│                  │ probes:       │      │               │      │               │        │
│                  │ /healthcheck──┼──────▶ calls api.py endpoint                │        │
│                  └───────────────┘      └───────────────┘      └───────────────┘        │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 9.4 סיכום כל הקשרים

| # | מה | מתחבר ל | איך |
|---|-----|---------|-----|
| 1 | requirements.txt | Python files | pip install |
| 2 | main.py / api.py | Rick & Morty API | requests.get() |
| 3 | api.py | Port 5000 | Flask app.run() |
| 4 | Dockerfile | api.py | CMD ["python", "api.py"] |
| 5 | deployment.yaml | Docker Image | image: rick-morty-api |
| 6 | deployment.yaml | Pods | labels: app: rick-morty-api |
| 7 | service.yaml | Pods | selector: app: rick-morty-api |
| 8 | service.yaml | Container | port: 80 → targetPort: 5000 |
| 9 | ingress.yaml | Service | backend: service |
| 10 | Probes | api.py | httpGet: /healthcheck |

---

# סיכום

**מה למדנו:**

1. **API** - איך לקרוא נתונים משירות חיצוני
2. **Python** - איך לכתוב סקריפט שמעבד נתונים
3. **Docker** - איך לארוז אפליקציה לקונטיינר
4. **Kubernetes** - איך לפרוס ולנהל אפליקציה בענן

**מה הפרויקט מדגים:**
- הבנה של מחזור חיים של אפליקציה
- יכולת לכתוב קוד נקי ומתועד
- ידע ב-Containerization
- הבנה של Orchestration

---

# חלק ב׳: שאלות ראיון DevOps - מדריך מקיף

---

## פרק 10: AWS VPC - כל מה שצריך לדעת

### ❓ "מה זה VPC?"

**VPC** (Virtual Private Cloud) = רשת וירטואלית פרטית בענן AWS.

זה כמו לבנות את הרשת הפרטית שלך בתוך AWS - אתה מחליט:
- איזה טווח כתובות IP (CIDR)
- איך לחלק ל-Subnets
- מי יכול לגשת למה
- איך תנועה נכנסת ויוצאת

### ❓ "מה ההבדל בין Subnet פרטי לציבורי?"

| מאפיין | Public Subnet | Private Subnet |
|--------|---------------|----------------|
| גישה לאינטרנט | ישירה דרך IGW | רק דרך NAT Gateway |
| IP ציבורי | יש | אין |
| Route Table | מצביע ל-IGW | מצביע ל-NAT |
| שימוש | Web servers, Load Balancers | Databases, Internal services |

### ❓ "מהו Internet Gateway?"

**Internet Gateway (IGW)** = שער שמאפשר תקשורת בין VPC לאינטרנט.
- מאפשר לשרתים ב-Public Subnet לצאת ולהיכנס מהאינטרנט
- Highly Available - AWS מנהל אותו
- חינמי (משלמים רק על Data Transfer)

### ❓ "מהו NAT Gateway?"

**NAT Gateway** = מאפשר לשרתים ב-Private Subnet לצאת לאינטרנט בלי להיחשף.
- יציאה בלבד - אין אפשרות להיכנס מבחוץ
- יושב ב-Public Subnet
- עולה כסף (לפי שעה + Data)

### ❓ "מהי טכנולוגיית Private Link?"

**Private Link / VPC Endpoints** = גישה לשירותי AWS בלי לעבור דרך האינטרנט.

**שני סוגים:**
- **Interface Endpoint** - ENI בתוך ה-VPC. עובד עם רוב השירותים.
- **Gateway Endpoint** - רק ל-S3 ו-DynamoDB. חינמי!

---

## פרק 11: AWS IAM - זהויות והרשאות

### ❓ "מה ההבדל בין IAM Role ל-IAM User?"

| מאפיין | IAM User | IAM Role |
|--------|----------|----------|
| מיועד ל | אנשים (בני אדם) | שירותים / אפליקציות |
| אימות | Username + Password | Assume Role (זמני) |
| תוקף | קבוע עד שמוחקים | זמני (credentials מתחלפים) |
| דוגמה | מפתח שנכנס ל-Console | EC2 שניגש ל-S3 |

### ❓ "מה ההבדל בין IAM Policy ל-Resource Based Policy?"

| סוג | IAM Policy | Resource Based Policy |
|-----|------------|----------------------|
| מוצמד ל | User / Group / Role | משאב (S3 Bucket, SQS) |
| מגדיר | "מה המשתמש יכול לעשות" | "מי יכול לגשת למשאב" |
| Cross-Account | דורש Assume Role | ישיר |

---

## פרק 12: AWS Storage

### ❓ "מה ההבדל בין EBS ל-EFS?"

| מאפיין | EBS | EFS |
|--------|-----|-----|
| סוג | Block Storage (דיסק) | File Storage (NFS) |
| חיבור | EC2 אחד בלבד | מרובה EC2 |
| Scaling | ידני | אוטומטי |
| מחיר | זול יותר | יקר יותר |
| שימוש | Database, Boot | Shared files |

### ❓ "מה זה S3?"

**S3** (Simple Storage Service) = Object Storage.
- **Unlimited** - אין הגבלה
- **Durability** - 99.999999999%
- **Storage Classes** - Standard, IA, Glacier
- **שימושים:** Backup, Static website, Data lake

---

## פרק 13: AWS Compute

### ❓ "מה ההבדל בין On-Demand, Reserved, Spot, Dedicated?"

| סוג | מאפיין | הנחה | שימוש |
|-----|--------|------|-------|
| **On-Demand** | לפי שימוש | 0% | Dev, Testing |
| **Reserved** | התחייבות 1-3 שנים | עד 72% | Production |
| **Spot** | קיבולת עודפת | עד 90% | Batch jobs |
| **Dedicated** | שרת פיזי שלם | תלוי | Compliance |

### ❓ "מה זה Lambda?"

**Lambda** = Serverless compute.
- Event-driven
- Pay per use
- Auto-scale
- Max 15 minutes

### ❓ "איזה שירות מתזמן טריגרים של Lambda?"

**Amazon EventBridge** - Cron, Rate, Event patterns

---

## פרק 14: Load Balancing, DNS, CDN

### ❓ "אילו סוגי Load Balancer יש?"

| סוג | שכבה | שימוש |
|-----|------|-------|
| **ALB** | Layer 7 | Web apps, Microservices |
| **NLB** | Layer 4 | High performance |
| **GLB** | Layer 3 | Security appliances |

### ❓ "מה ההבדל בין ניתוב Geolocation, Latency, Weight?"

| סוג | לוגיקה | שימוש |
|-----|--------|-------|
| **Geolocation** | לפי מיקום | תוכן מותאם למדינה |
| **Latency** | לפי זמן תגובה | ביצועים מיטביים |
| **Weighted** | לפי אחוזים | A/B testing |

### ❓ "מה זה CloudFront?"

**CloudFront** = CDN של AWS.
- מפיץ תוכן ל-Edge Locations
- מוריד Latency
- Caching
- SSL/TLS מובנה

### ❓ "האם SSL חינם? מהו ACM?"

**ACM** = AWS Certificate Manager. **חינם!**
- חידוש אוטומטי
- עובד עם: ALB, CloudFront, API Gateway

---

## פרק 15: Databases

### ❓ "מה ההבדל בין DB רלציוני ללא-רלציוני?"

| מאפיין | SQL | NoSQL |
|--------|-----|-------|
| מבנה | טבלאות | Documents, Key-Value |
| Schema | קבוע | גמיש |
| Scaling | Vertical | Horizontal |
| AWS | RDS, Aurora | DynamoDB |

### ❓ "מה זה Redis?"

**Redis** = In-memory key-value store.
- מהיר מאוד
- Caching
- Session storage
- **AWS:** ElastiCache for Redis

### ❓ "מה ההבדל בין Standby ל-Primary DB?"

| סוג | תפקיד |
|-----|-------|
| **Primary** | Write + Read |
| **Standby** | רק גיבוי - Failover אוטומטי |
| **Read Replica** | רק Read |

---

## פרק 16: Kubernetes מתקדם

### ❓ "מהו Namespace?"

**Namespace** = חלוקה לוגית של הקלאסטר.
- מפריד בין סביבות
- מאפשר Resource Quotas

### ❓ "מה ההבדל בין Deployment ל-ReplicaSet?"

| מאפיין | ReplicaSet | Deployment |
|--------|------------|------------|
| Rolling Updates | ❌ | ✅ |
| Rollback | ❌ | ✅ |
| שימוש | נדיר | תמיד! |

### ❓ "מה זה Ingress ו-Ingress Controller?"

| רכיב | תפקיד |
|------|-------|
| **Ingress** | YAML שמגדיר חוקי ניתוב |
| **Ingress Controller** | התוכנה שאוכפת (NGINX) |

### ❓ "מהו Sidecar, Init, Application Container?"

| סוג | מתי רץ | תפקיד |
|-----|--------|-------|
| **Init** | לפני Main | הכנות |
| **Application** | אחרי Init | האפליקציה |
| **Sidecar** | במקביל | עזר (Logging) |

### ❓ "מה זה Probe? Liveness?"

| Probe | שואל | אם נכשל |
|-------|------|---------|
| **Liveness** | "אתה חי?" | Restart |
| **Readiness** | "אתה מוכן?" | No traffic |

### ❓ "מהו Service Account?"

**Service Account** = זהות עבור Pods.
- תקשורת עם K8s API
- RBAC permissions
- קישור ל-AWS IAM (IRSA)

### ❓ "איך מתבצע Autoscale?"

- **HPA** - מוסיף Pods לפי metrics
- **VPA** - משנה Resources
- **Cluster Autoscaler** - מוסיף Nodes

### ❓ "מה זה PVC?"

**PVC** = Persistent Volume Claim = בקשה לאחסון.
- **PV** = האחסון הפיזי
- **PVC** = הבקשה
- **StorageClass** = סוג האחסון

---

## פרק 17: סוגי Workloads

### ❓ "StatefulSet vs DaemonSet vs Deployment?"

| סוג | תפקיד | דוגמה |
|-----|-------|-------|
| **Deployment** | Stateless, Pods זהים | Web servers |
| **StatefulSet** | Stateful, זהות קבועה | Databases |
| **DaemonSet** | Pod על כל Node | Logging agent |

### ❓ "סוגי Services?"

| סוג | נגישות |
|-----|--------|
| **ClusterIP** | רק מתוך הקלאסטר |
| **NodePort** | Port על כל Node |
| **LoadBalancer** | Cloud LB חיצוני |

### ❓ "4 סוגי פריסות?"

| סוג | איך עובד |
|-----|----------|
| **Rolling Update** | מחליף בהדרגה |
| **Recreate** | מוחק הכל → מעלה חדש |
| **Blue-Green** | סביבה חדשה → Switch |
| **Canary** | % קטן מהמשתמשים |

### ❓ "מהו Istio?"

**Istio** = Service Mesh.
- Traffic Management
- Security (mTLS)
- Observability

---

## פרק 18: Helm

### ❓ "מה זה Helm?"

**Helm** = Package manager לקוברנטיס.
- **Charts** - חבילות מוכנות
- **Templating** - YAMLים דינמיים
- **Values** - קובץ הגדרות
- **Releases** - ניהול גרסאות

### ❓ "מה זה Helm Lint?"

`helm lint` = בודק תקינות Chart לפני התקנה.

### ❓ "מה זה _helpers.tpl?"

קובץ עם פונקציות לשימוש חוזר בתוך Chart.

---

## פרק 19: CI/CD

### ❓ "מה זה CI ו-CD?"

| מונח | משמעות | מה כולל |
|------|--------|---------|
| **CI** | Continuous Integration | Build, Test, Lint |
| **CD** | Continuous Delivery | פריסה אוטומטית |

### ❓ "GitHub Actions vs Jenkins?"

| מאפיין | GitHub Actions | Jenkins |
|--------|----------------|---------|
| התקנה | מובנה (SaaS) | Self-hosted |
| תחזוקה | GitHub | אתה |
| גמישות | טובה | מקסימלית |

### ❓ "מה זה Artifact?"

**Artifact** = תוצר Build: Docker Image, JAR, Binary

### ❓ "Test vs Stage vs Prod?"

| סביבה | מטרה |
|-------|------|
| **Dev/Test** | בדיקות מפתחים |
| **Staging** | Pre-production |
| **Production** | משתמשים אמיתיים |

---

## פרק 20: Terraform

### ❓ "מהו Drift?"

**Drift** = פער בין State למצב האמיתי. קורה כששינו ידנית.

### ❓ "עריכת שם Bucket - מה יקרה?"

**ימחק את הישן ויצור חדש!** (immutable)

### ❓ "מה זה Terraform Validate?"

בודק תקינות קבצי .tf (לא מול הענן).

### ❓ "איפה לשמור State?"

**Remote Backend** - S3 + DynamoDB locking. לא ב-Git!

### ❓ "מה זה Workspace?"

State נפרד לאותו קוד (dev, staging, prod).

### ❓ "מהו Module?"

קבוצת Resources לשימוש חוזר (כמו פונקציה).

### ❓ "CloudFormation vs Terraform?"

| מאפיין | CloudFormation | Terraform |
|--------|----------------|-----------|
| ספק | AWS בלבד | Multi-cloud |
| שפה | JSON/YAML | HCL |
| State | AWS מנהל | אתה מנהל |

---

## פרק 21: Architecture

### ❓ "Microservices vs Monolith?"

| Monolith | Microservices |
|----------|---------------|
| אפליקציה אחת | שירותים קטנים |
| פשוט להתחיל | קשה לנהל |
| קשה לסקייל חלקים | כל שירות נפרד |

### ❓ "מה זה Decoupled Services?"

שירותים לא תלויים ישירות - תקשורת דרך Queue/Events.

### ❓ "מתי EC2 ומתי Kubernetes?"

| EC2 | Kubernetes |
|-----|------------|
| אפליקציה פשוטה | Microservices |
| צוות קטן | צוות עם ידע K8s |
| Stateful legacy | Cloud Native |

---

## פרק 22: Monitoring

### ❓ "מה זה Prometheus?"

מערכת Monitoring - Pull-based, Time-series, PromQL.

### ❓ "מה זה Grafana?"

כלי Visualization - Dashboards, Alerts.

### ❓ "מהו NGINX?"

Web server / Reverse Proxy / Load Balancer / Ingress Controller.

---

## פרק 23: API & HTTP

### ❓ "קודים 2xx, 3xx, 4xx, 5xx?"

| סדרה | משמעות |
|------|--------|
| **2xx** | הצלחה |
| **3xx** | Redirect |
| **4xx** | שגיאת Client |
| **5xx** | שגיאת Server |

### ❓ "4 סוגי קריאות API?"

GET (Read), POST (Create), PUT (Update), DELETE (Delete)

### ❓ "REST vs SOAP?"

| REST | SOAP |
|------|------|
| JSON | XML |
| קל | כבד |
| Modern | Enterprise |

---

## פרק 24: תרחישים

### תרחיש: הקמת אתר E-Commerce

**שאלות לשאול:**
1. גאוגרפיה - ישראל או גלובלי?
2. עדכניות מוצרים - לעיתים רחוקות? Redis
3. כמות כניסות - Scaling planning

### תרחיש: קמפיין חגים (10K → 40K)

1. Auto Scaling לפי CPU
2. Read Replicas
3. Redis Caching
4. Pre-warming

### תרחיש: שדרוג K8s Cluster

1. Control Plane קודם
2. בדיקת תקינות
3. Worker Nodes אחד-אחד

### תרחיש: Pods ב-Error

1. `kubectl describe pod`
2. `kubectl logs`
3. בדיקת: Image, Permissions, Resources

### תרחיש: Traffic מ-ALB לK8s

- ALB: Public Subnet, SG 80/443
- K8s: SG Referencing, Ingress

### תרחיש: K8s בלי אינטרנט

- Private Registry (ECR + Endpoint)
- Golden AMI
- Private Link

---

## פרק 25: Docker מתקדם

### ❓ "מה זה Multi-Stage Build?"

**Multi-Stage Build** = בניית Image במספר שלבים.

**למה?**
- Image קטן יותר
- אבטחה - פחות כלים
- הפרדה בין build ל-runtime

```dockerfile
# Stage 1: Build
FROM node:18 AS builder
WORKDIR /app
RUN npm run build

# Stage 2: Production
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
# מ-800MB ל-50MB!
```

### ❓ "מה זה Volumes ו-Bind Mounts?"

| סוג | מה זה | שימוש |
|-----|-------|-------|
| **Volume** | Docker מנהל | Production - DB |
| **Bind Mount** | תיקייה מהמחשב | Dev - קוד |
| **tmpfs** | זיכרון בלבד | Sensitive data |

### ❓ "מה זה Docker Compose?"

כלי להרצת מספר Containers יחד. קובץ YAML אחד, פקודה אחת.

### ❓ "Docker Networking Types?"

| Type | תיאור |
|------|-------|
| **bridge** | ברירת מחדל - מבודד |
| **host** | רשת של ה-host |
| **none** | ללא רשת |
| **overlay** | בין hosts |

### ❓ "Container Restart Policies?"

| Policy | התנהגות |
|--------|---------|
| `no` | לא מפעיל מחדש |
| `always` | תמיד |
| `on-failure` | רק ב-error |
| `unless-stopped` | תמיד חוץ מאם עצרת |

---

## פרק 26: Kubernetes Scheduling

### ❓ "Labels ו-Selectors?"

**Labels** = תגיות key-value על Resources.
**Selectors** = בחירת Resources לפי Labels.

### ❓ "Taints ו-Tolerations?"

**Taint** = "רעל" על Node - דוחה Pods.
**Toleration** = "חיסון" ל-Pod - מאפשר לו לרוץ.

*משל: שלט "כניסה אסורה" (Taint), אישור מיוחד (Toleration)*

### ❓ "Node Selector vs Node Affinity?"

| מושג | תיאור | גמישות |
|------|-------|--------|
| **Node Selector** | label פשוט | equality בלבד |
| **Node Affinity** | תנאים מורכבים | In, NotIn, Gt, Lt |

### ❓ "Pod Affinity vs Anti-Affinity?"

**Affinity** = "רוצה ליד Pod מסוים" (Web + Cache)
**Anti-Affinity** = "רוצה רחוק מ-Pod" (DB replicas - HA)

---

## פרק 27: Kubernetes Configuration

### ❓ "מה זה ConfigMap?"

אחסון configuration לא-רגיש: env vars, files.

### ❓ "מה זה Secret?"

אחסון רגיש (base64): passwords, API keys, certs.
⚠️ base64 ≠ הצפנה! להשתמש עם Vault.

### ❓ "Rolling Update ו-Rollback?"

**Rolling Update** = עדכון הדרגתי ללא downtime.
**Rollback** = חזרה לגרסה קודמת.

```bash
kubectl rollout undo deployment/myapp
kubectl rollout undo deployment/myapp --to-revision=2
```

---

## פרק 28: K8s Networking

### ❓ "מה זה CNI?"

**CNI** = Container Network Interface. Plugins: Calico, Flannel, Weave, AWS VPC CNI.

### ❓ "מה זה CoreDNS?"

DNS פנימי של הקלאסטר. מתרגם: `my-service.namespace.svc.cluster.local`

### ❓ "מה זה Network Policy?"

Firewall ברמת Pod. קובע איזה Traffic מותר Ingress/Egress.

---

## פרק 29: Jenkins

### ❓ "Freestyle vs Pipeline?"

| מאפיין | Freestyle | Pipeline |
|--------|-----------|----------|
| הגדרה | GUI | קוד (Jenkinsfile) |
| Git | ❌ | ✅ |
| שימוש | פשוט | CI/CD מלא |

### ❓ "Jenkins Agents/Slaves?"

**Master** = מנהל, מתזמן
**Agent** = מבצע העבודה

### ❓ "הרצה ידנית בין שלבים?"

כן! עם `input` step:
```groovy
input message: 'Deploy?', ok: 'Deploy!'
```

### ❓ "Jenkins Parameters?"

משתנים שהמשתמש מזין: string, choice, boolean.

---

## פרק 30: Security & Best Practices

### ❓ "מה זה SG Referencing?"

התייחסות ל-Security Group במקום CIDR.
**יתרון:** יותר מאובטח, יותר דינמי.

### ❓ "OIDC בין GitHub ל-AWS?"

אימות בלי Access Keys!
1. Identity Provider ב-AWS
2. IAM Role עם Trust Policy
3. `aws-actions/configure-aws-credentials`

### ❓ "GitHub vs GitLab?"

| מאפיין | GitHub | GitLab |
|--------|--------|--------|
| CI/CD | Actions | מובנה יותר |
| Self-hosted | יקר | Community חינם |

### ❓ "Vertical vs Horizontal Scaling?"

| Vertical | Horizontal |
|----------|------------|
| יותר כח למכונה | יותר מכונות |
| יש גבול | כמעט ללא גבול |
| DBs | Stateless |

---

---

# 📚 מילון מושגים מפורט - A-Z

> **חיפוש מהיר:** Ctrl+F ← הקלד את המושג
> 
> **סגנון:** כל הסבר כתוב כאילו אתה עונה בראיון אמיתי

---

## 🐳 Docker - מושגים מרכזיים

---

### Multi-Stage Build

**"מה זה Multi-Stage Build?"**

אז תראה, כשאנחנו בונים Docker Image רגיל, הבעיה היא שה-Image הסופי מכיל את **כל מה שהיה צריך בשביל לבנות** את האפליקציה, לא רק את מה שצריך בשביל **להריץ** אותה.

**הבעיה בפירוט:**

נגיד שאני בונה אפליקציית Node.js:
- בשביל **לבנות (Build)** - אני צריך: Node.js מלא, npm, כל ה-devDependencies, TypeScript compiler, Webpack, כלי בדיקה...
- בשביל **להריץ (Runtime)** - אני צריך רק: Node.js רזה + קבצי ה-JavaScript המקומפלים

**בלי Multi-Stage:**
```dockerfile
FROM node:18
WORKDIR /app
COPY package*.json ./
RUN npm install          # כולל devDependencies!
COPY . .
RUN npm run build        # מקמפל TypeScript
CMD ["node", "dist/index.js"]

# התוצאה: Image של 800MB-1GB!
# למה? כי יש בפנים: node_modules מלא, קוד מקור, build tools
```

**עם Multi-Stage:**
```dockerfile
# שלב 1: BUILD - כל מה שצריך לבנייה
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
# בנקודה הזו יש לנו תיקיית dist/ עם הקוד המקומפל

# שלב 2: RUNTIME - רק מה שצריך להרצה
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
CMD ["node", "dist/index.js"]

# התוצאה: Image של 100-150MB!
```

**מה קרה פה?**

| שלב | מה יש בו | מה קורה לו |
|-----|----------|-------------|
| **builder** | Node מלא, npm, קוד מקור, devDeps | נזרק בסוף! |
| **final** | Node-alpine רזה + dist + prod deps | זה מה שנשאר |

**הפקודה `COPY --from=builder`** - זה הקסם! היא מעתיקה קבצים **משלב קודם** לשלב הנוכחי. אנחנו לוקחים רק את התוצר (dist/) ולא את כל הזבל.

**למה זה חשוב בעולם האמיתי:**

1. **גודל Image:**
   - קטן יותר = מהיר יותר ל-pull
   - קטן יותר = פחות עלות אחסון
   - קטן יותר = פריסה מהירה יותר

2. **אבטחה:**
   - פחות כלים = פחות פגיעויות (vulnerabilities)
   - אין compiler בProduction = תוקף לא יכול לקמפל קוד זדוני
   - Surface area קטן יותר

3. **הפרדת אחריות:**
   - Build environment ≠ Runtime environment
   - מה שצריך למפתח ≠ מה שצריך ב-Production

**דוגמה נוספת - Python:**
```dockerfile
# BUILD
FROM python:3.11 AS builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --user -r requirements.txt
COPY . .

# RUNTIME
FROM python:3.11-slim
WORKDIR /app
COPY --from=builder /root/.local /root/.local
COPY --from=builder /app .
ENV PATH=/root/.local/bin:$PATH
CMD ["python", "app.py"]
```

**שאלת המשך בראיון:** "מתי לא להשתמש ב-Multi-Stage?"
- כשה-Image כבר קטן
- כש-Build וRuntime זהים (Python scripts פשוטים)
- כשצריך debug tools ב-Production (לא מומלץ, אבל קורה)

---

### Docker Volumes vs Bind Mounts

**"מה ההבדל בין Volume ל-Bind Mount?"**

שניהם פותרים את אותה בעיה: **Containers הם ephemeral** - כשהם נמחקים, המידע שבתוכם נמחק. אבל הם עובדים אחרת:

**Bind Mount:**
- אתה אומר לDocker: "קח את התיקייה הזו מהמחשב שלי ותכניס אותה לContainer"
- **אתה שולט** על המיקום
- שינויים בקוד על המחשב → נראים מיד ב-Container

```bash
docker run -v /home/user/mycode:/app myimage
#           ↑ תיקייה שלך       ↑ בתוך Container
```

**Volume:**
- אתה אומר לDocker: "תנהל לי אחסון, אני לא רוצה לדעת איפה"
- **Docker שולט** על המיקום
- המידע נשאר גם אחרי שה-Container נמחק

```bash
docker run -v mydata:/app/data myimage
#           ↑ שם שDocker מנהל
```

**מתי מה:**

| מצב | מה להשתמש | למה |
|-----|-----------|-----|
| **Development** | Bind Mount | רוצה לערוך קוד ולראות שינויים |
| **Production - DB** | Volume | Docker מנהל, גיבוי קל |
| **Production - Logs** | Volume | נשאר אחרי restart |
| **CI/CD** | בדרך כלל כלום | Containers חד-פעמיים |

**דוגמה מעשית - Development:**
```yaml
# docker-compose.yml
services:
  web:
    build: .
    volumes:
      - ./src:/app/src    # Bind mount - קוד שלי
      - node_modules:/app/node_modules  # Volume - npm packages

volumes:
  node_modules:  # Docker מנהל
```

---

### Docker Networking

**"תסביר Docker Networking"**

כשיש לך כמה Containers שצריכים לדבר אחד עם השני, Docker מספק כמה אפשרויות:

**Bridge (ברירת מחדל):**
- רשת פרטית וירטואלית
- Containers יכולים לדבר אחד עם השני **בשם**
- מבודד מהעולם החיצון (אלא אם עושים port mapping)

```bash
docker network create mynet
docker run --network mynet --name db postgres
docker run --network mynet --name web myapp
# web יכול לפנות ל-db:5432
```

**Host:**
- Container משתמש ברשת של המכונה המארחת
- אין בידוד
- ביצועים מקסימליים (אין NAT)

```bash
docker run --network host nginx
# nginx מאזין ישירות על port 80 של המכונה
```

**None:**
- אין רשת בכלל
- בידוד מלא
- לcontainers שלא צריכים תקשורת

| Network | בידוד | ביצועים | שימוש |
|---------|-------|---------|-------|
| Bridge | גבוה | טוב | רוב המקרים |
| Host | אין | מעולה | High performance |
| None | מלא | N/A | Security, batch jobs |

---

### Container Restart Policies

**"מה קורה כש-Container קורס?"**

Docker יכול להפעיל אותו מחדש אוטומטית - אתה מגדיר מדיניות:

| Policy | מה קורה | מתי להשתמש |
|--------|---------|-------------|
| `no` | לא מפעיל מחדש | ברירת מחדל, development |
| `always` | תמיד מפעיל מחדש | Production services |
| `on-failure` | רק אם יצא עם error | Batch jobs |
| `unless-stopped` | כמו always, אלא אם עצרת ידנית | Production |

```bash
docker run --restart=always nginx
```

**בDocker Compose:**
```yaml
services:
  web:
    image: nginx
    restart: unless-stopped
```

**למה `unless-stopped` ולא `always`?**
- `always` יפעיל מחדש גם אחרי reboot של המכונה
- `unless-stopped` יזכור שעצרת ידנית ולא יפעיל

---

## ☁️ AWS - Amazon Web Services

---

### ACM (AWS Certificate Manager)

**"מה זה ACM?"**

ACM זה שירות שמנהל תעודות SSL/TLS עבורך. הדבר הכי חשוב לדעת: **זה חינם** לשירותי AWS.

**למה זה משנה:**
- תעודת SSL מחברות כמו DigiCert עולה $200-400 בשנה
- ACM = חינם + חידוש אוטומטי

**מגבלה חשובה:**
ACM לא עובד ישירות עם EC2. אם יש לך EC2 שמריץ web server, אתה צריך לשים ALB מקדימה ולהצמיד את התעודה ל-ALB.

```
Users → ALB (SSL Termination כאן, עם ACM) → EC2 (HTTP רגיל)
```

**עובד עם:** ALB, CloudFront, API Gateway, Elastic Beanstalk
**לא עובד עם:** EC2 ישירות, On-premises

---

### ALB (Application Load Balancer)

**"מה זה ALB ומתי להשתמש בו?"**

ALB זה Load Balancer שעובד ברמת **Layer 7** - כלומר הוא מבין HTTP/HTTPS. זה מאפשר לו לעשות דברים חכמים:

**Path-Based Routing:**
נגיד שיש לך אפליקציה עם כמה microservices:
```
https://myapp.com/api/users  → Users Service
https://myapp.com/api/orders → Orders Service  
https://myapp.com/static     → S3 Bucket
```
ALB יכול לנתב לפי ה-path. זה אומר שאתה צריך **Load Balancer אחד** לכל האפליקציה.

**Host-Based Routing:**
```
api.myapp.com    → Backend Service
www.myapp.com    → Frontend Service
admin.myapp.com  → Admin Service
```
גם פה - ALB אחד, הוא מנתב לפי ה-hostname.

**ALB vs NLB - מתי מה:**

| שאלה | ALB | NLB |
|------|-----|-----|
| הפרוטוקול? | HTTP/HTTPS | TCP/UDP/TLS |
| צריך routing חכם? | ✅ כן | ❌ לא יודע |
| צריך WebSocket? | ✅ כן | ✅ כן |
| חשיבות ביצועים קריטית? | טוב | **מעולה** |
| Gaming/IoT? | לא מתאים | ✅ מושלם |
| IP קבוע? | ❌ לא | ✅ כן (Elastic IP) |

**כלל אצבע:**
- Web application? → **ALB**
- צריך ultra-low latency? → **NLB**
- לא בטוח? → **ALB** (יותר גמיש)

---

### Auto Scaling Group (ASG)

**מה זה:** קבוצת EC2 instances שגדלה וקטנה אוטומטית.

**הגדרות:**
- **Minimum:** מינימום instances (לא יורד מזה)
- **Maximum:** מקסימום instances (לא עולה מזה)
- **Desired:** כמות רצויה נוכחית

**Scaling Policies:**
| סוג | איך עובד |
|-----|----------|
| Target Tracking | "שמור על 70% CPU" |
| Step Scaling | "אם CPU > 80% הוסף 2" |
| Scheduled | "בשעה 9 בבוקר הוסף 5" |

**דוגמה:**
```
Min: 2, Max: 10, Desired: 4
CPU > 70% → Desired: 6
CPU < 30% → Desired: 3
```

---

### CloudFront

**מה זה:** CDN (Content Delivery Network) של AWS.

**איך עובד:**
1. משתמש מבקש קובץ
2. CloudFront בודק אם יש ב-Edge Location הקרוב
3. אם יש (Cache Hit) → מחזיר מיד
4. אם אין (Cache Miss) → מביא מה-Origin, שומר, מחזיר

**יתרונות:**
- Latency נמוך (200+ Edge Locations)
- DDoS protection מובנה
- SSL/TLS חינם
- עובד עם S3, ALB, EC2, או כל HTTP server

**TTL (Time To Live):**
- קובע כמה זמן לשמור ב-cache
- ברירת מחדל: 24 שעות

---

### CloudWatch

**מה זה:** שירות Monitoring וLogging של AWS.

**רכיבים:**

| רכיב | תפקיד |
|------|-------|
| **Metrics** | מדדים (CPU, Memory, Custom) |
| **Logs** | לוגים מכל שירות |
| **Alarms** | התראות על סף מסוים |
| **Dashboards** | גרפים ויזואליים |
| **Events/EventBridge** | תגובה לאירועים |

**Metrics חשובים ל-EC2:**
- CPUUtilization
- NetworkIn/Out
- DiskReadOps/WriteOps
- StatusCheckFailed

---

### CloudTrail

**מה זה:** מתעד כל פעולת API ב-AWS account.

**שימושים:**
- Security audit
- Compliance
- Troubleshooting

**מה נרשם:**
- מי עשה (User/Role)
- מה עשה (API call)
- מתי (Timestamp)
- מאיפה (IP address)

---

### Decoupled Services

**"מה זה Decoupled Services ולמה זה חשוב?"**

תחשוב על זה ככה: יש לך שני שירותים - A ו-B.

**Tightly Coupled (הבעיה):**
```
User → Service A → Service B → Database
```
מה קורה אם Service B קורס?
- Service A תקוע - מחכה לתשובה שלא תבוא
- User מקבל error
- כל השרשרת נופלת

זה כמו שרשרת דומינו - אחד נופל, כולם נופלים.

**Decoupled (הפתרון):**
```
User → Service A → [Queue] → Service B → Database
```
מה קורה עכשיו אם Service B קורס?
- Service A שולח הודעה ל-Queue ומחזיר "OK" ל-User
- ההודעה יושבת ב-Queue ומחכה
- כש-Service B חוזר לעבוד, הוא מעבד את ההודעות
- **שום מידע לא אבד!**

**דוגמה מהחיים האמיתיים:**

נגיד שיש לך אתר E-commerce:
```
User מזמין → Order Service → [SQS Queue] → Email Service
                                        → Inventory Service
                                        → Analytics Service
```

למה זה טוב?
1. **User מקבל תשובה מיידית** - "ההזמנה התקבלה"
2. **כל שירות עובד בקצב שלו** - Email יכול לקחת 5 שניות, לא משנה
3. **אם Email Service קרס** - ההודעות מחכות, ישלחו כשיחזור
4. **Scaling עצמאי** - הרבה הזמנות? תגדיל רק את Order Service

**שירותי AWS:**
- **SQS** - Queue פשוט (הודעה אחת למקבל אחד)
- **SNS** - Pub/Sub (הודעה אחת להרבה מקבלים)
- **EventBridge** - Events מורכבים עם routing

**שאלת המשך:** "מה החיסרון?"
- **Complexity** - יותר רכיבים לנהל
- **Eventual Consistency** - המידע לא מתעדכן מיידית
- **Debugging קשה יותר** - קשה לעקוב אחרי flow

---

### EBS (Elastic Block Store)

**מה זה:** דיסק וירטואלי ל-EC2.

**סוגים:**

| סוג | IOPS | שימוש |
|-----|------|-------|
| gp3 | עד 16,000 | General purpose (הכי נפוץ) |
| io2 | עד 64,000 | High performance DB |
| st1 | עד 500 | Big data, throughput |
| sc1 | עד 250 | Cold data, archive |

**מאפיינים:**
- מחובר ל-EC2 אחד בלבד
- באותו AZ בלבד!
- Snapshots לגיבוי (נשמרים ב-S3)

---

### EFS (Elastic File System)

**מה זה:** NFS מנוהל - file system משותף.

**הבדל מ-EBS:**

| מאפיין | EBS | EFS |
|--------|-----|-----|
| חיבור | EC2 אחד | מרובה EC2 |
| AZ | אחד | Cross-AZ |
| Scaling | ידני | אוטומטי |
| פרוטוקול | Block | NFS |
| מחיר | זול יותר | יקר יותר |

**שימושים:**
- Shared application files
- CMS content
- Development environments

---

### IAM (Identity and Access Management)

**מה זה:** ניהול זהויות והרשאות ב-AWS.

**רכיבים:**

| רכיב | מה זה | דוגמה |
|------|-------|-------|
| **User** | זהות לאדם | john@company.com |
| **Group** | קבוצת Users | "Developers" |
| **Role** | זהות לשירות | EC2 שניגש ל-S3 |
| **Policy** | מסמך הרשאות | מה מותר/אסור |

**IAM User vs IAM Role:**

| מאפיין | User | Role |
|--------|------|------|
| מיועד ל | אנשים | שירותים |
| אימות | Password/Keys | Assume Role |
| תוקף | קבוע | זמני |
| Best Practice | לאנשים | לאוטומציה |

**IAM Policy vs Resource Policy:**

| מאפיין | IAM Policy | Resource Policy |
|--------|------------|-----------------|
| מוצמד ל | User/Group/Role | המשאב עצמו |
| שואל | "מה User יכול?" | "מי יכול לגשת?" |
| Cross-Account | דורש Assume | ישיר |

---

### Internet Gateway (IGW)

**מה זה:** שער שמחבר VPC לאינטרנט.

**מאפיינים:**
- Horizontally scaled, redundant, HA
- AWS מנהל - אין לך מה לדאוג
- חינמי (משלמים Data Transfer)
- אחד ל-VPC

**חובה בשביל:**
- EC2 עם Public IP יוכל לצאת לאינטרנט
- תנועה נכנסת מהאינטרנט

---

### Lambda

**מה זה:** Serverless compute - מריץ קוד בלי שרתים.

**מאפיינים:**
- Event-driven
- Pay per millisecond
- Auto-scale (עד אלפי executions במקביל)
- תומך: Python, Node.js, Java, Go, .NET

**מגבלות:**
| מגבלה | ערך |
|-------|-----|
| Timeout | 15 דקות |
| Memory | 128MB - 10GB |
| Package size | 250MB |
| /tmp storage | 512MB (או 10GB עם EFS) |

**Triggers נפוצים:**
- API Gateway
- S3 events
- EventBridge (cron)
- SQS
- DynamoDB Streams

**מתזמן:** EventBridge
```
cron(0 2 * * ? *)  # כל יום ב-2 בלילה
rate(5 minutes)    # כל 5 דקות
```

---

### NAT Gateway

**מה זה:** מאפשר ל-Private Subnet לצאת לאינטרנט.

**איך עובד:**
```
Private EC2 → NAT Gateway (Public Subnet) → IGW → Internet
```

**מאפיינים:**
- יציאה בלבד! אי אפשר להיכנס דרכו
- יושב ב-Public Subnet
- עלות: ~$0.045/שעה + Data processing
- HA באותו AZ (צריך NAT לכל AZ ל-HA מלא)

**שימושים:**
- EC2 ב-Private Subnet צריך לעדכן packages
- Lambda ב-VPC צריך גישה לאינטרנט
- ECS tasks צריכים למשוך images

---

### Private Link / VPC Endpoint

**מה זה:** גישה לשירותי AWS בלי אינטרנט.

**שני סוגים:**

| סוג | מה זה | עלות | שירותים |
|-----|-------|------|---------|
| **Interface** | ENI בתוך VPC | בתשלום | רוב השירותים |
| **Gateway** | Route Table | חינם! | S3, DynamoDB בלבד |

**יתרונות:**
- אבטחה: Traffic לא יוצא מ-AWS
- ביצועים: Latency נמוך
- עלות: חוסך NAT Gateway

**דוגמה - ECR בלי אינטרנט:**
```
צריך 3 Interface Endpoints:
- com.amazonaws.region.ecr.api
- com.amazonaws.region.ecr.dkr
- com.amazonaws.region.s3 (Gateway - חינם)
```

---

### RDS (Relational Database Service)

**מה זה:** בסיס נתונים מנוהל.

**מנועים נתמכים:**
MySQL, PostgreSQL, MariaDB, Oracle, SQL Server, Aurora

**Multi-AZ:**
- Standby ב-AZ אחר
- Failover אוטומטי (1-2 דקות)
- Standby לא נגיש לקריאה!

**Read Replica:**
- עותק לקריאה
- נגיש לקריאה
- Async replication

| מאפיין | Multi-AZ | Read Replica |
|--------|----------|--------------|
| מטרה | HA | ביצועים |
| נגיש? | לא | כן |
| Sync | Synchronous | Async |
| Failover | אוטומטי | ידני |

---

### Route 53

**מה זה:** שירות DNS של AWS.

**סוגי ניתוב:**

| סוג | לוגיקה | שימוש | דוגמה |
|-----|--------|-------|-------|
| **Simple** | IP אחד | Basic | אתר פשוט |
| **Weighted** | לפי אחוזים | A/B Testing | 90% v1, 10% v2 |
| **Latency** | לפי מהירות | Global users | Region הכי מהיר |
| **Geolocation** | לפי מיקום | Compliance | ישראל → il-central |
| **Failover** | Primary/Secondary | DR | אם Primary נופל |
| **Multivalue** | כמה IPs | Simple LB | 8 IPs רנדומלי |

---

### S3 (Simple Storage Service)

**מה זה:** Object Storage ללא הגבלה.

**מאפיינים:**
- Objects (לא קבצים רגילים)
- 99.999999999% Durability (11 תשיעיות)
- Max object size: 5TB
- Versioning
- Encryption (SSE-S3, SSE-KMS, SSE-C)

**Storage Classes:**

| Class | זמינות | Min Duration | שימוש |
|-------|--------|--------------|-------|
| Standard | מיידי | אין | גישה תכופה |
| Standard-IA | מיידי | 30 יום | גישה לא תכופה |
| One Zone-IA | מיידי | 30 יום | פחות קריטי |
| Glacier Instant | מיידי | 90 יום | ארכיון + גישה מהירה |
| Glacier Flexible | דקות-שעות | 90 יום | ארכיון |
| Glacier Deep | 12-48 שעות | 180 יום | ארכיון ארוך |

---

### Security Group (SG)

**מה זה:** Firewall וירטואלי ברמת Instance.

**מאפיינים:**
- **Stateful:** אם נכנס, יוצא אוטומטית
- Default: All inbound denied, All outbound allowed
- רק Allow rules (אין Deny)

**SG Referencing:**
במקום CIDR, אפשר להתייחס ל-SG אחר:
```
Inbound: Allow from sg-alb-12345 (רק ALB יכול)
```
**יותר מאובטח מ:** `Allow 10.0.0.0/16`

---

### Subnet

**מה זה:** חלוקה של VPC.

**Public vs Private:**

| מאפיין | Public | Private |
|--------|--------|---------|
| Route לאינטרנט | IGW ישיר | דרך NAT |
| Public IP | כן | לא |
| מה שמים | ALB, Bastion, NAT | DB, App servers |

**CIDR דוגמה:**
```
VPC: 10.0.0.0/16 (65,536 IPs)
├── Public: 10.0.1.0/24 (256 IPs)
├── Public: 10.0.2.0/24 (256 IPs)
├── Private: 10.0.10.0/24 (256 IPs)
└── Private: 10.0.11.0/24 (256 IPs)
```

---

### VPC (Virtual Private Cloud)

**מה זה:** רשת וירטואלית פרטית שלך ב-AWS.

**רכיבים:**
- **CIDR Block:** טווח IPs
- **Subnets:** חלוקות
- **Route Tables:** לאן לשלוח traffic
- **IGW:** גישה לאינטרנט
- **NAT:** יציאה לאינטרנט מ-Private
- **Security Groups:** Firewall

---

## ☸️ Kubernetes - מושגים מפורטים

---

### ConfigMap

**מה זה:** אחסון configuration לא-רגיש.

**שימושים:**
- Environment variables
- Configuration files
- Command-line arguments

**יצירה:**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  DATABASE_HOST: "db.example.com"
  LOG_LEVEL: "debug"
  config.json: |
    {"feature_flag": true}
```

**שימוש ב-Pod:**
```yaml
env:
  - name: DATABASE_HOST
    valueFrom:
      configMapKeyRef:
        name: app-config
        key: DATABASE_HOST
```

---

### DaemonSet

**מה זה:** מבטיח שPod אחד רץ על כל Node.

**שימושים:**
- Logging agents (Fluentd)
- Monitoring agents (Prometheus Node Exporter)
- Storage daemons
- Network plugins

**הבדל מ-Deployment:**
| Deployment | DaemonSet |
|------------|-----------|
| X replicas איפשהו | Pod אחד על כל Node |
| Scheduler מחליט | Node = Pod |

---

### Deployment Strategies - 4 אסטרטגיות פריסה

**"תסביר את אסטרטגיות הפריסה בקוברנטיס"**

כשאתה רוצה לעדכן אפליקציה מגרסה 1 לגרסה 2, יש כמה דרכים לעשות את זה. לכל אחת יתרונות וחסרונות.

---

**1. Rolling Update (ברירת מחדל)**

**מה קורה:**
```
התחלה:  [v1] [v1] [v1] [v1]    ← 4 Pods של v1, משרתים users
שלב 1:  [v1] [v1] [v1] [v2]    ← הורדנו Pod אחד, העלינו v2
שלב 2:  [v1] [v1] [v2] [v2]    ← עוד אחד
שלב 3:  [v1] [v2] [v2] [v2]    ← עוד אחד
סיום:   [v2] [v2] [v2] [v2]    ← הושלם!
```

**למה זה ברירת המחדל:**
- ✅ **Zero Downtime** - תמיד יש Pods שעובדים
- ✅ **Rollback מהיר** - `kubectl rollout undo`
- ✅ **לא צריך משאבים נוספים** (כמעט)

**⚠️ החיסרון:**
**שתי גרסאות רצות במקביל!** במהלך העדכון, חלק מה-users מקבלים v1 וחלק v2. אם יש breaking change ב-API, זו בעיה.

**הגדרות חשובות:**
```yaml
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1        # כמה Pods להוסיף מעל הרצוי (או %)
      maxUnavailable: 0  # כמה Pods יכולים להיות למטה (או %)
```

| הגדרה | משמעות | דוגמה (4 replicas) |
|-------|--------|-------------------|
| maxSurge: 1 | אפשר להוסיף 1 מעל | יכול להיות 5 Pods זמנית |
| maxUnavailable: 0 | אף אחד לא למטה | תמיד לפחות 4 עובדים |

**מתי להשתמש:** רוב המקרים! אלא אם יש סיבה ספציפית לא.

---

**2. Recreate**

**מה קורה:**
```
התחלה:  [v1] [v1] [v1] [v1]    ← 4 Pods של v1
שלב 1:  [  ] [  ] [  ] [  ]    ← מוחק את כולם!
שלב 2:  [v2] [v2] [v2] [v2]    ← מעלה את כולם
```

**למה זה קיים:**
- ✅ **אף פעם אין שתי גרסאות** - רק v1 או רק v2
- ✅ **פשוט** - אין מצבי ביניים

**❌ החיסרון הגדול:**
**יש Downtime!** בזמן שמוחקים v1 ומעלים v2, האפליקציה לא זמינה.

**מתי להשתמש:**
- **Database migrations** שדורשות schema ספציפי
- **אפליקציות Stateful** שלא יכולות לרוץ ב-2 גרסאות
- **Legacy apps** שלא תוכננו ל-rolling updates

```yaml
spec:
  strategy:
    type: Recreate
```

---

**3. Blue-Green Deployment**

**מה זה:**
מחזיקים **שתי סביבות זהות** - Blue (נוכחי) ו-Green (חדש). מחליפים traffic במכה אחת.

**איך זה עובד:**
```
שלב 1: Blue Live, Green מוכן
┌─────────────────┐     ┌─────────────────┐
│  Blue (v1)      │ ←── │   Load Balancer │ ←── Users
│  [v1][v1][v1]   │     │                 │
└─────────────────┘     └─────────────────┘
┌─────────────────┐
│  Green (v2)     │     (מוכן, לא מקבל traffic)
│  [v2][v2][v2]   │
└─────────────────┘

שלב 2: Switch!
┌─────────────────┐
│  Blue (v1)      │     (Standby)
│  [v1][v1][v1]   │
└─────────────────┘
┌─────────────────┐     ┌─────────────────┐
│  Green (v2)     │ ←── │   Load Balancer │ ←── Users
│  [v2][v2][v2]   │     │                 │
└─────────────────┘     └─────────────────┘
```

**יתרונות:**
- ✅ **Zero Downtime** - Switch הוא מיידי
- ✅ **Instant Rollback** - פשוט להחזיר ל-Blue
- ✅ **אפשר לבדוק Green לפני Switch** - QA על הסביבה החדשה

**❌ חסרונות:**
- **כפול משאבים!** צריך לשלם על שתי סביבות
- **Database?** איך שתי גרסאות עובדות עם אותו DB?

**מתי להשתמש:**
- **Mission critical apps** שצריכים rollback מיידי
- **Major version upgrades**
- כשיש budget למשאבים כפולים

---

**4. Canary Deployment**

**מה זה:**
משחררים גרסה חדשה ל**אחוז קטן** מהמשתמשים, בודקים שהכל בסדר, ואז מגדילים בהדרגה.

**שם:** קנרית - כמו הציפורים שהכניסו למכרות פחם. אם הציפור מתה, יש גז רעיל.

**איך זה עובד:**
```
שלב 1: 5% traffic ל-v2
         95%
Users ─────────→ [v1] [v1] [v1] [v1] [v1] [v1] [v1] [v1] [v1]
      └──5%───→ [v2]

מנטרים: Error rate? Latency? User complaints?

שלב 2: הכל טוב? מגדילים ל-25%
         75%
Users ─────────→ [v1] [v1] [v1] [v1] [v1] [v1] [v1]
      └─25%──→ [v2] [v2] [v2]

שלב 3: עדיין טוב? 100%
Users ─────────→ [v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2]
```

**יתרונות:**
- ✅ **בדיקה ב-Production** עם users אמיתיים
- ✅ **סיכון מינימלי** - אם יש בעיה, רק 5% נפגעו
- ✅ **אפשר להשוות metrics** בין v1 ו-v2 בזמן אמת

**❌ חסרונות:**
- **מורכב לנהל** - צריך כלים (Istio, Flagger, Argo Rollouts)
- **לוקח זמן** - לא instant
- **Stateful apps** - קשה כשיש sessions

**מתי להשתמש:**
- **Features חדשים ומסוכנים**
- **שינויי UI משמעותיים**
- **High traffic apps** שאי אפשר לבדוק ב-staging

---

**סיכום - מתי מה:**

| אסטרטגיה | Downtime | Rollback | משאבים | מורכבות | מתי |
|----------|----------|----------|--------|---------|-----|
| **Rolling** | אין | מהיר | רגיל | פשוט | ברירת מחדל |
| **Recreate** | יש! | מהיר | רגיל | פשוט | Legacy, DB migrations |
| **Blue-Green** | אין | מיידי | כפול | בינוני | Mission critical |
| **Canary** | אין | מהיר | קצת יותר | מורכב | High risk features |

---

### HPA (Horizontal Pod Autoscaler)

**מה זה:** Auto-scaling של Pods לפי metrics.

**איך עובד:**
1. מודד CPU/Memory/Custom metrics
2. משווה ל-target (למשל 70%)
3. מחשב כמה Pods צריך
4. מוסיף/מוריד Pods

**הגדרה:**
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: my-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

---

### Ingress & Ingress Controller

**Ingress (Resource):**
מסמך YAML שמגדיר חוקי ניתוב.

**Ingress Controller (Software):**
התוכנה שקוראת את ה-Ingress ומבצעת בפועל.

**Controllers נפוצים:**
- NGINX Ingress Controller
- Traefik
- HAProxy
- AWS ALB Ingress Controller

**דוגמת Ingress:**
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /users
        pathType: Prefix
        backend:
          service:
            name: users-service
            port:
              number: 80
      - path: /orders
        pathType: Prefix
        backend:
          service:
            name: orders-service
            port:
              number: 80
```

---

### Namespace

**מה זה:** חלוקה לוגית של הקלאסטר.

**שימושים:**
- הפרדה בין סביבות: dev, staging, prod
- הפרדה בין צוותים
- Resource Quotas
- Network Policies

**Default Namespaces:**
| Namespace | תפקיד |
|-----------|--------|
| default | ברירת מחדל |
| kube-system | רכיבי K8s (CoreDNS, etc.) |
| kube-public | משאבים ציבוריים |

**פקודות:**
```bash
kubectl get namespaces
kubectl create namespace dev
kubectl get pods -n production
kubectl get pods --all-namespaces
```

---

### Node Affinity & Pod Affinity

**Node Selector (פשוט):**
```yaml
nodeSelector:
  disktype: ssd
```

**Node Affinity (מתקדם):**
```yaml
affinity:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
      - matchExpressions:
        - key: disktype
          operator: In
          values: [ssd, nvme]
```

**Pod Affinity:**
"רוץ על Node שיש עליו Pod עם label מסוים"
שימוש: Web server ליד Cache

**Pod Anti-Affinity:**
"רוץ על Node שאין עליו Pod עם label מסוים"
שימוש: DB replicas על Nodes שונים (HA)

---

### Probes - בדיקות בריאות

**3 סוגי Probes:**

| Probe | שואל | אם נכשל | מתי לבדוק |
|-------|------|---------|-----------|
| **Liveness** | "אתה חי?" | Restart | כל הזמן |
| **Readiness** | "אתה מוכן?" | לא שולחים traffic | כל הזמן |
| **Startup** | "עלית?" | ממתינים | רק בהתחלה |

**סוגי בדיקות:**
- **httpGet:** GET request ל-endpoint
- **tcpSocket:** בדיקת port פתוח
- **exec:** הרצת command

**דוגמה:**
```yaml
livenessProbe:
  httpGet:
    path: /healthcheck
    port: 8080
  initialDelaySeconds: 10
  periodSeconds: 30
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 10
```

---

### PVC (Persistent Volume Claim)

**מה זה:** בקשה לאחסון קבוע.

**3 רכיבים:**
| רכיב | מה זה | מי יוצר |
|------|-------|---------|
| **PV** | האחסון הפיזי | Admin / Dynamic |
| **PVC** | הבקשה | Developer |
| **StorageClass** | סוג האחסון | Admin |

**דוגמה:**
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: gp2
```

**Access Modes:**
- **ReadWriteOnce (RWO):** Node אחד
- **ReadOnlyMany (ROX):** הרבה Nodes קריאה
- **ReadWriteMany (RWX):** הרבה Nodes כתיבה

---

### Secret

**מה זה:** אחסון מידע רגיש.

**סוגים:**
- Opaque (ברירת מחדל)
- kubernetes.io/tls
- kubernetes.io/dockerconfigjson

**⚠️ חשוב:** base64 ≠ הצפנה!
לאבטחה אמיתית: External Secrets, Vault, Sealed Secrets

**יצירה:**
```bash
kubectl create secret generic db-secret \
  --from-literal=username=admin \
  --from-literal=password=secret123
```

---

### Service - סוגים בפירוט

**"תסביר את סוגי ה-Services בקוברנטיס"**

Service בקוברנטיס פותר בעיה פשוטה: **Pods הם זמניים**. הם קמים, נופלים, מקבלים IP חדש. אז איך שירות אחר מוצא אותם? דרך Service שנותן כתובת קבועה.

---

**1. ClusterIP (ברירת מחדל)**

**מה זה:** כתובת IP פנימית בתוך הקלאסטר.

**איך זה עובד:**
```
Pod A רוצה לדבר עם Pod B
        ↓
Pod A → ClusterIP Service → Pod B (או כמה Pods)
        ↑
   IP קבוע: 10.96.0.15
```

**למה צריך:**
- Pods יכולים להחליף IP
- Service = כתובת קבועה שתמיד מצביעה על Pods הנכונים

**דוגמה:**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-backend  # ← זה השם שמשתמשים בו!
spec:
  type: ClusterIP   # ברירת מחדל, אפשר לא לכתוב
  selector:
    app: backend    # ← מוצא Pods עם label זה
  ports:
  - port: 80        # ← Port של ה-Service
    targetPort: 8080 # ← Port של ה-Pod
```

**איך ניגשים:**
```bash
# מתוך Pod אחר בקלאסטר:
curl http://my-backend         # עובד!
curl http://my-backend.default # עם namespace
curl http://my-backend.default.svc.cluster.local # full DNS
```

**מתי להשתמש:** כל שירות פנימי - databases, caches, microservices

---

**2. NodePort**

**"מה זה NodePort ולמה לא להשתמש בו בProduction?"**

**מה זה:** פותח Port על **כל Node** בקלאסטר. מאפשר גישה מבחוץ.

**איך זה עובד:**
```
User מבחוץ
    ↓
http://192.168.1.10:30080   ← IP של Node כלשהו + NodePort
    ↓
NodePort Service (port 30080 על כל Node)
    ↓
Pod (port 8080)
```

**דוגמה:**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-web
spec:
  type: NodePort
  selector:
    app: web
  ports:
  - port: 80           # Port פנימי של Service
    targetPort: 8080   # Port של Pod
    nodePort: 30080    # Port חיצוני (30000-32767)
```

**⚠️ למה לא לProduction:**

| בעיה | הסבר |
|------|------|
| **צריך לדעת IP של Node** | מה אם Node קורס? צריך לשנות IP |
| **טווח מוגבל** | רק 30000-32767 (לא 80/443!) |
| **אין Load Balancing חכם** | Traffic מגיע לNode ספציפי |
| **אבטחה** | כל Node חשוף לעולם |

**מתי כן להשתמש:**
- Development מקומי
- Testing
- On-premises בלי Cloud LB
- Debugging

---

**3. LoadBalancer**

**"מה זה LoadBalancer Service?"**

**מה זה:** מבקש מCloud Provider ליצור Load Balancer אמיתי.

**איך זה עובד ב-AWS:**
```
User מבחוץ
    ↓
https://my-app-123456.us-east-1.elb.amazonaws.com ← AWS יוצר ALB/NLB
    ↓
LoadBalancer Service
    ↓
Pods
```

**דוגמה:**
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-web
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"  # או alb
spec:
  type: LoadBalancer
  selector:
    app: web
  ports:
  - port: 80
    targetPort: 8080
```

**מה קורה בפועל:**
1. K8s רואה `type: LoadBalancer`
2. שולח בקשה ל-Cloud Provider
3. AWS יוצר ALB/NLB
4. מקבלים External IP/DNS

**יתרונות:**
- כתובת אחת קבועה
- Load Balancing אמיתי
- SSL termination
- Health checks

**חיסרון:** עלות! כל Service = עוד Load Balancer = עוד $20/חודש

**פתרון:** Ingress - Load Balancer אחד לכל השירותים

---

**4. ExternalName**

**"מה זה ExternalName?"**

**מה זה:** DNS alias לשירות **מחוץ** לקלאסטר.

**למה צריך:**
נגיד שיש לך Database ב-RDS (מחוץ לK8s). במקום שכל Pod יכיר את `my-db.123456.us-east-1.rds.amazonaws.com`, אתה יוצר:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-database
spec:
  type: ExternalName
  externalName: my-db.123456.us-east-1.rds.amazonaws.com
```

**עכשיו Pods יכולים:**
```bash
# במקום הכתובת הארוכה:
psql -h my-database -U admin
```

**יתרון:** אם כתובת ה-RDS משתנה, משנים במקום אחד (Service) ולא בכל Pod.

---

**סיכום - מתי מה:**

| סוג | נגישות | שימוש |
|-----|--------|-------|
| **ClusterIP** | רק פנימי | Microservices, DBs |
| **NodePort** | מבחוץ (לא מומלץ) | Dev, Testing |
| **LoadBalancer** | מבחוץ (Cloud LB) | Production |
| **ExternalName** | DNS alias | שירותים חיצוניים |

---

### Service Account

**מה זה:** זהות עבור Pods (לא בני אדם).

**שימושים:**
- גישה ל-Kubernetes API
- RBAC permissions
- קישור ל-AWS IAM (IRSA)

**דוגמה:**
```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-app-sa
---
# Pod שמשתמש ב-SA
spec:
  serviceAccountName: my-app-sa
```

---

### StatefulSet

**מה זה:** כמו Deployment אבל ל-Stateful apps.

**הבדלים מ-Deployment:**

| מאפיין | Deployment | StatefulSet |
|--------|------------|-------------|
| שמות Pods | רנדומלי (abc123) | סדרתי (pod-0, pod-1) |
| סדר יצירה | מקבילי | סדרתי |
| PVC | משותף | לכל Pod בנפרד |
| DNS | Service | Pod-specific |

**שימושים:**
- Databases (MySQL, PostgreSQL)
- Message queues (Kafka, RabbitMQ)
- Distributed systems (Elasticsearch)

---

### Taints & Tolerations

**"מה זה Taints ו-Tolerations?"**

בוא נחשוב על זה ככה: יש לך Cluster עם 10 Nodes, ואחד מהם יש לו GPU יקר. אתה לא רוצה ש-Pods רגילים יתפסו את ה-Node הזה - אתה רוצה לשמור אותו ל-Machine Learning jobs.

**Taint (על Node) = "שלט אזהרה":**
```bash
kubectl taint nodes gpu-node gpu=true:NoSchedule
```
זה כמו לשים שלט על הדלת: "רק מי שיש לו אישור מיוחד יכול להיכנס!"

**Toleration (על Pod) = "האישור המיוחד":**
```yaml
tolerations:
- key: "gpu"
  operator: "Equal"
  value: "true"
  effect: "NoSchedule"
```
זה כמו להגיד: "יש לי אישור, אני יכול להיכנס למרות השלט"

**3 סוגי Effects:**

| Effect | מה קורה | משל |
|--------|---------|-----|
| **NoSchedule** | Pods חדשים לא יתוזמנו לפה | "אסור להיכנס" |
| **PreferNoSchedule** | ינסה לא לשים, אבל אם אין ברירה... | "עדיף לא להיכנס" |
| **NoExecute** | גם Pods קיימים יפונו! | "כולם החוצה!" |

**דוגמה מעשית:**
- Taint על Nodes עם SSD: `storage=ssd:NoSchedule`
- רק Databases (שיש להם Toleration) יתוזמנו לשם

**⚠️ חשוב להבין:**
- Taint **דוחה** Pods
- Toleration **לא מושך** - הוא רק מאפשר
- גם עם Toleration, ה-Pod לא בהכרח יגיע לNode הזה

**לעומת Node Affinity:**
- Taints = "אל תבוא" (דחייה)
- Affinity = "בוא לפה" (משיכה)

לתוצאה מדויקת, משתמשים **בשניהם יחד**!

---

## 🔧 CI/CD & DevOps Tools

---

### Artifact

**מה זה:** תוצר של תהליך Build.

**דוגמאות:**
- Docker Image
- JAR/WAR file
- Compiled binary
- npm package
- Test reports
- Helm chart

**איפה שומרים:**
- Docker Registry (ECR, Docker Hub)
- Artifactory / Nexus
- S3
- GitHub Packages

---

### CI vs CD

**"מה זה CI/CD?"**

בוא נתחיל מהבעיה: פעם, מפתחים היו כותבים קוד שבועות, ואז ביום שישי מנסים למזג הכל ביחד. התוצאה? קטסטרופה. "Merge Hell". באגים שנוצרו לפני שבועיים מתגלים רק עכשיו.

**CI (Continuous Integration) פותר את זה:**
"כל פעם שמישהו עושה commit, המערכת אוטומטית בודקת שהקוד תקין"

מה קורה ב-CI:
```
Developer pushes code
    ↓
✓ Code checkout
✓ Install dependencies
✓ Run linting (בדיקת סגנון קוד)
✓ Run unit tests
✓ Run integration tests
✓ Security scan
    ↓
אם הכל עבר → ✅ מותר למזג
אם משהו נכשל → ❌ המפתח מתקן מיד
```

**למה זה טוב?**
- באגים מתגלים **מיד** - קל לתקן
- כולם רואים את סטטוס הקוד
- אין "Merge Hell"

**CD (Continuous Delivery / Deployment):**
"אחרי ש-CI עבר, הקוד מגיע אוטומטית לסביבות"

```
CI עבר בהצלחה
    ↓
Package (Docker build)
    ↓
Deploy to Dev → Deploy to Staging → Deploy to Prod
```

**ההבדל הקטן:**
- **Continuous Delivery** = פריסה אוטומטית עד Staging, Prod ידני
- **Continuous Deployment** = פריסה אוטומטית גם ל-Prod

**שלבי Pipeline מלא:**
```
┌─────────────────────────────────────────────────────────────────┐
│ CI (Continuous Integration)                                      │
├─────────────────────────────────────────────────────────────────┤
│ 1. Source      ← git clone, checkout branch                     │
│ 2. Install     ← npm install, pip install                       │
│ 3. Lint        ← eslint, flake8 (בדיקת סגנון)                   │
│ 4. Test        ← Unit tests, Integration tests                  │
│ 5. Security    ← Dependency scan, SAST                          │
├─────────────────────────────────────────────────────────────────┤
│ CD (Continuous Delivery)                                         │
├─────────────────────────────────────────────────────────────────┤
│ 6. Package     ← Docker build, Create artifact                  │
│ 7. Deploy Dev  ← Push to dev environment                        │
│ 8. Deploy Stg  ← Push to staging                                │
│ 9. Deploy Prod ← Push to production (ידני או אוטומטי)           │
│ 10. Verify     ← Health checks, Smoke tests                     │
└─────────────────────────────────────────────────────────────────┘
```

**שאלת המשך נפוצה:** "מה קורה אם Test נכשל?"
**תשובה:** ה-Pipeline נעצר. הקוד לא מגיע לשום מקום עד שמתקנים. זו הנקודה!

---

### GitHub Actions vs Jenkins

| מאפיין | GitHub Actions | Jenkins |
|--------|----------------|---------|
| סוג | SaaS (מנוהל) | Self-hosted |
| תחזוקה | GitHub | אתה |
| קובץ | YAML | Groovy |
| Marketplace | Actions | Plugins |
| עלות | דקות חינם + תשלום | חינם + שרתים |
| למידה | קל | מורכב יותר |
| גמישות | טובה | מקסימלית |

---

### Helm

**"מה זה Helm ולמה צריך אותו?"**

תארי לעצמך שיש לך אפליקציה עם 10 קבצי YAML - Deployment, Service, ConfigMap, Secret, Ingress... עכשיו תצטרך לפרוס את זה ב-3 סביבות: dev, staging, prod.

**בלי Helm:**
- 30 קבצי YAML (10 לכל סביבה)
- כל שינוי צריך לעדכן ב-3 מקומות
- Hardcoded values בכל מקום
- אין version control על הפריסות

**עם Helm:**
- קבצי template עם משתנים `{{ .Values.replicas }}`
- קובץ `values.yaml` לכל סביבה
- פקודה אחת לפריסה
- Rollback בלחיצת כפתור

**Helm הוא כמו apt/yum לקוברנטיס - Package Manager.**

**מבנה Chart:**
```
mychart/
├── Chart.yaml           # מטא-דאטה: שם, גרסה, תיאור
├── values.yaml          # ערכי ברירת מחדל
├── values-prod.yaml     # ערכים ל-Production
├── templates/
│   ├── deployment.yaml  # {{ .Values.replicas }}
│   ├── service.yaml     # {{ .Values.service.type }}
│   └── _helpers.tpl     # פונקציות לשימוש חוזר
└── charts/              # dependencies (sub-charts)
```

**דוגמה מעשית:**
```yaml
# values.yaml (Dev)
replicas: 1
image:
  tag: latest
resources:
  memory: 256Mi

# values-prod.yaml (Production)
replicas: 5
image:
  tag: v1.2.3
resources:
  memory: 2Gi
```

```yaml
# templates/deployment.yaml
spec:
  replicas: {{ .Values.replicas }}
  template:
    spec:
      containers:
      - name: app
        image: myapp:{{ .Values.image.tag }}
        resources:
          limits:
            memory: {{ .Values.resources.memory }}
```

**פקודות חשובות:**
```bash
# התקנה
helm install myapp ./mychart

# התקנה עם values מותאמים
helm install myapp ./mychart -f values-prod.yaml

# עדכון
helm upgrade myapp ./mychart

# רשימת releases
helm list

# rollback לגרסה קודמת
helm rollback myapp 1

# מחיקה
helm uninstall myapp

# בדיקת תקינות
helm lint ./mychart
```

**helm lint:**
בודק את ה-Chart **לפני** שמתקינים:
- Syntax errors
- Best practices
- Missing required fields

**_helpers.tpl:**
קובץ עם פונקציות לשימוש חוזר:
```yaml
{{- define "mychart.fullname" -}}
{{ .Release.Name }}-{{ .Chart.Name }}
{{- end }}
```
עכשיו אפשר להשתמש: `{{ include "mychart.fullname" . }}`

**למה זה שימושי?** כי אם שם האפליקציה מופיע ב-10 מקומות, אתה מגדיר פעם אחת ומשתמש בכל מקום.

---

### Terraform

**"מה זה Terraform?"**

Terraform זה **Infrastructure as Code** - במקום ללחוץ בConsole של AWS, אתה כותב קוד שמתאר את התשתית שאתה רוצה. Terraform קורא את הקוד ויוצר את המשאבים בענן.

**למה זה טוב?**
- **Version Control** - הקוד ב-Git, רואים היסטוריה
- **Reproducible** - אותו קוד = אותה תשתית
- **Review** - Pull Request על שינויי תשתית
- **Multi-cloud** - AWS, GCP, Azure מאותו קוד

---

**"מה זה State?"**

State זה קובץ שטרפורם שומר, שמתאר **מה קיים באמת** בענן.

למה צריך? כי Terraform צריך לדעת:
- מה כבר נוצר
- מה צריך ליצור
- מה צריך לעדכן
- מה צריך למחוק

```
terraform.tfstate = "תמונת מצב" של התשתית
```

**איפה לשמור State?**

❌ **לא מקומית** - כי:
- חברי צוות לא רואים
- אין backup
- אפשר למחוק בטעות

❌ **לא ב-Git** - כי:
- מכיל מידע רגיש (passwords, keys)
- conflicts בין חברי צוות

✅ **Remote Backend (S3 + DynamoDB):**
```hcl
terraform {
  backend "s3" {
    bucket         = "my-terraform-state"
    key            = "prod/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "terraform-locks"  # Locking!
    encrypt        = true
  }
}
```
- **S3** = שומר את ה-State
- **DynamoDB** = Locking (מונע שני אנשים לעבוד במקביל)

---

**"מה זה Drift?"**

Drift = מצב שבו מה שכתוב ב-State **לא תואם** למה שקיים באמת בענן.

**איך זה קורה?**
- מישהו שינה משהו ידנית בConsole
- תהליך אחר עדכן את המשאב
- AWS שינה משהו אוטומטית

**איך מזהים?**
```bash
terraform plan
# יראה את ההבדלים
```

**איך מתקנים?**
```bash
terraform apply
# יחזיר את הענן למצב שמתואר בקוד
```

---

**"אם אני משנה שם של S3 Bucket בקוד, מה יקרה?"**

**ימחק את ה-Bucket הישן וייצור חדש!**

למה? כי שם של Bucket הוא **immutable** - לא ניתן לשינוי.

Terraform יבצע:
1. Destroy (מחיקה)
2. Create (יצירה חדשה)

**⚠️ זהירות:** כל הנתונים ב-Bucket יימחקו!

**פתרון:** `terraform state mv` או lifecycle rules

---

**"מה זה terraform validate?"**

בודק שהקוד **תקין מבחינת syntax** - לפני שפונים לענן בכלל.

```bash
terraform validate
# בודק: types, required arguments, syntax
# לא בודק: האם המשאבים קיימים בענן
```

**לעומת `terraform plan`:**
| validate | plan |
|----------|------|
| בודק קוד בלבד | בודק מול הענן |
| מהיר | לוקח זמן |
| Offline | צריך credentials |

---

**"מה זה Workspace?"**

Workspace = **States נפרדים לאותו קוד**

```bash
terraform workspace new dev
terraform workspace new staging
terraform workspace new prod

terraform workspace select prod
terraform apply  # משתמש ב-prod.tfstate
```

**למה זה שימושי?**
אותו קוד Terraform, סביבות שונות:
- dev = משאבים קטנים
- prod = משאבים גדולים

**אלטרנטיבה:** תיקיות נפרדות (יותר ברור, פחות טעויות)

---

**"מה זה Module?"**

Module = **קוד לשימוש חוזר**, כמו פונקציה.

במקום לכתוב את אותו קוד של VPC 10 פעמים:
```hcl
module "vpc" {
  source = "./modules/vpc"
  
  cidr_block = "10.0.0.0/16"
  name       = "production"
}
```

**Module Registry:** יש מודולים מוכנים מהקהילה
```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "3.0.0"
}
```

---

**"מה ההבדל בין CloudFormation ל-Terraform?"**

| מאפיין | CloudFormation | Terraform |
|--------|----------------|-----------|
| **ספק** | AWS בלבד | Multi-cloud |
| **שפה** | JSON/YAML | HCL (קריא יותר) |
| **State** | AWS מנהל | אתה מנהל |
| **Drift Detection** | מובנה | `terraform plan` |
| **למידה** | קל ל-AWS | יותר גמיש |

**מתי מה?**
- רק AWS + צוות קטן → CloudFormation
- Multi-cloud / צוות גדול → Terraform

**שינוי שם Bucket:** ימחק וייצור חדש! (immutable)

---

## 📊 Monitoring

---

### Prometheus

**מה זה:** מערכת Monitoring ואיסוף Metrics.

**מאפיינים:**
- Pull-based (מושך metrics מכל target)
- Time-series database
- PromQL (שפת שאילתות)
- AlertManager לnרשות

**דוגמת PromQL:**
```
# CPU usage
rate(container_cpu_usage_seconds_total[5m])

# Memory
container_memory_usage_bytes
```

---

### Grafana

**מה זה:** כלי Visualization.

**מאפיינים:**
- Dashboards יפים
- מתחבר להרבה data sources
- Alerting
- Open source

---

### NGINX

**מה זה:** Web server רב-תכליתי.

**תפקידים:**
| תפקיד | הסבר |
|-------|------|
| Web Server | מגיש קבצים סטטיים |
| Reverse Proxy | מעביר ל-backend |
| Load Balancer | מפזר עומסים |
| Ingress Controller | בקוברנטיס |

---

## 🎯 תרחישים מלאים

---

### תרחיש: הקמת אתר E-Commerce

**שאלות לשאול:**

1. **גאוגרפיה**
   - ישראל בלבד → Region il-central-1
   - גלובלי → CloudFront

2. **עדכניות מוצרים**
   - לעיתים רחוקות → Redis caching
   - תכופות → פחות cache, יותר DB reads

3. **כמות כניסות**
   - לפי זה: sizing של instances ו-DB
   - Auto Scaling policies

**ארכיטקטורה:**
```
Users → CloudFront → ALB → EKS/EC2 (ASG)
                          ↓
                    RDS Aurora + ElastiCache
```

---

### תרחיש: קמפיין חגים (10K→40K)

**בעיה:** עומס צפוי x4

**פתרון:**

1. **Auto Scaling**
   - Target: CPU 70%
   - Max instances מספיק גבוה

2. **Database**
   - Read Replicas
   - Connection pooling

3. **Caching**
   - Redis/ElastiCache
   - CloudFront TTL

4. **Pre-warming**
   - הגדל capacity מראש
   - Load testing

---

### תרחיש: שדרוג K8s Cluster

**שלבים:**

1. **Control Plane קודם**
   - חייב להיות ≤2 versions מ-Workers
   - AWS EKS עושה אוטומטי

2. **בדיקה**
   ```bash
   kubectl get nodes
   kubectl get pods --all-namespaces
   ```

3. **Worker Nodes**
   - אחד-אחד
   - drain → upgrade → uncordon

4. **חזור על התהליך**
   - Max 2 minor versions בפעם

---

### תרחיש: Pods ב-ERROR

**שלב 1 - High Level:**
```bash
kubectl describe pod <name>
```
בודק: Events, Conditions, State

**שלב 2 - Application Level:**
```bash
kubectl logs <name>
kubectl logs <name> --previous  # אם קרס
```

**סיבות נפוצות:**

| Status | סיבה | פתרון |
|--------|------|-------|
| ImagePullBackOff | אין גישה ל-Registry | בדוק credentials |
| CrashLoopBackOff | App קורס | בדוק logs |
| OOMKilled | חוסר זיכרון | הגדל limits |
| Pending | אין resources | הוסף Nodes |

---

### תרחיש: Traffic ALB → K8s

**ברמת ALB:**
- Public Subnet
- SG: Inbound 80, 443 from 0.0.0.0/0
- Redirect HTTP → HTTPS
- Optional: WAF

**ברמת K8s:**
- SG Referencing (רק ALB SG)
- Ingress resource
- Ingress Controller (NGINX)

---

### תרחיש: K8s בלי אינטרנט

**בעיות:**
- לא יכול Pull images
- לא יכול להתקין packages

**פתרונות:**
1. **Private Registry**
   - ECR + VPC Endpoints
   
2. **Golden AMI**
   - Images מותקנים מראש
   
3. **Private Link**
   - Interface Endpoints לשירותי AWS

---

### תרחיש: DB Scaling ללא Downtime

**Aurora:**
- Auto Scaling אוטומטי
- Cross-Region reads

**RDS - Vertical:**
1. צור Standby ב-AZ אחר
2. Modify את ה-Standby (הוסף resources)
3. Failover (30-60 שניות)

**RDS - Horizontal:**
1. הוסף Read Replicas
2. Application routing:
   - SELECT → Replicas
   - INSERT/UPDATE → Master

**טיפ:** RDS Proxy מחזיק connections בזמן failover

---

**טיפ אחרון לראיון:**
אל תפחד להגיד "אני לא יודע".
עדיף להגיד "אני לא בטוח, אבל הייתי בודק ככה..." מאשר להמציא תשובה.

---

**בהצלחה בראיון!** 🚀

</div>
