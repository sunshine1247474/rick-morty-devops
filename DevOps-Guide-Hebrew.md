צריך <div dir="rtl" align="right">

# 📘 מדריך DevOps מקיף - הכנה לראיון עבודה

## פרויקט Rick and Morty API - מהקוד ועד לענן

---

# מבוא

מדריך זה נכתב עבור מי שמתכונן לראיון עבודה בתחום ה-DevOps.
המדריך עוקב אחרי פרויקט אמיתי, צעד אחר צעד, ומסביר כל מושג בצורה פשוטה.

**מה תלמד במדריך זה:**
- מה זה API ואיך עובדים איתו
- איך כותבים סקריפט ב-Python
- מה זה Docker ולמה הוא חשוב
- מה זה Kubernetes ואיך משתמשים בו
- מושגים שמראיינים אוהבים לשאול עליהם

---

# פרק 1: הבנת המשימה

## 1.1 מה התבקשנו לעשות?

קיבלנו תרגיל בית עם הדרישות הבאות:

**משימות חובה:**
1. לכתוב סקריפט שקורא נתונים מ-API
2. לסנן את הנתונים לפי קריטריונים מסוימים
3. לשמור את התוצאות לקובץ CSV
4. להעלות את הקוד ל-GitHub

**משימות בונוס:**
5. להפוך את הסקריפט לשירות עם Docker
6. לפרוס את השירות ב-Kubernetes
7. ליצור Helm Chart
8. לבנות CI/CD Pipeline

## 1.2 למה דווקא המשימות האלה?

המשימות האלה מייצגות את **מחזור החיים המלא** של אפליקציה:

</div>

```
קוד ← בדיקה ← אריזה ← פריסה ← ניטור
Code → Test → Package → Deploy → Monitor
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "תאר את מחזור החיים של אפליקציה מהפיתוח ועד הפרודקשן"

**תשובה טובה:** "האפליקציה עוברת מספר שלבים: כתיבת קוד, בדיקות אוטומטיות, אריזה לקונטיינר עם Docker, פריסה לסביבת Kubernetes, וניטור מתמשך. כל שלב מנוהל על ידי Pipeline אוטומטי."

---

# פרק 2: מה זה API?

## 2.1 הגדרה פשוטה

**API** (Application Programming Interface) = ממשק תכנות יישומים

בפשטות: זו הדרך שבה תוכנות מדברות אחת עם השנייה.

**דוגמה מהחיים:**
כשאתה מזמין אוכל דרך אפליקציה, האפליקציה שולחת בקשה ל-API של המסעדה.
ה-API מחזיר את התפריט, המחירים, וזמני המשלוח.

## 2.2 מה זה REST API?

**REST** (Representational State Transfer) = סגנון ארכיטקטוני לבניית API

**עקרונות REST:**

| עיקרון | הסבר |
|--------|------|
| Stateless | כל בקשה עומדת בפני עצמה |
| Client-Server | הפרדה בין הלקוח לשרת |
| Uniform Interface | ממשק אחיד ועקבי |
| Cacheable | ניתן לשמור תשובות במטמון |

## 2.3 שיטות HTTP

**שאלת ראיון נפוצה:** "מה ההבדל בין GET ל-POST?"

</div>

```
┌──────────┬────────────────────────────────────────┐
│  Method  │  שימוש                                 │
├──────────┼────────────────────────────────────────┤
│  GET     │  קבלת מידע (קריאה בלבד)              │
│  POST    │  יצירת משאב חדש                       │
│  PUT     │  עדכון משאב קיים (מחליף לגמרי)       │
│  PATCH   │  עדכון חלקי של משאב                  │
│  DELETE  │  מחיקת משאב                          │
└──────────┴────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 2.4 קודי תגובה HTTP

**שאלת ראיון נפוצה:** "מה המשמעות של קוד 404? ומה 500?"

</div>

```
┌──────────┬────────────────────────────────────────┐
│  קוד     │  משמעות                               │
├──────────┼────────────────────────────────────────┤
│  200     │  OK - הבקשה הצליחה                    │
│  201     │  Created - נוצר משאב חדש              │
│  400     │  Bad Request - בקשה שגויה            │
│  401     │  Unauthorized - לא מורשה             │
│  403     │  Forbidden - אסור (גם עם הרשאה)      │
│  404     │  Not Found - המשאב לא נמצא           │
│  500     │  Internal Server Error - שגיאת שרת   │
│  502     │  Bad Gateway - שגיאה בשרת ביניים     │
│  503     │  Service Unavailable - השירות לא זמין│
└──────────┴────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 2.5 ה-API שעבדנו איתו

**כתובת ה-API:** `https://rickandmortyapi.com/api/character`

**מה מקבלים בתגובה:**

</div>

```json
{
  "info": {
    "count": 826,
    "pages": 42,
    "next": "https://rickandmortyapi.com/api/character?page=2",
    "prev": null
  },
  "results": [
    {
      "id": 1,
      "name": "Rick Sanchez",
      "status": "Alive",
      "species": "Human",
      "origin": {
        "name": "Earth (C-137)"
      },
      "location": {
        "name": "Citadel of Ricks"
      },
      "image": "https://rickandmortyapi.com/api/character/avatar/1.jpeg"
    }
  ]
}
```

<div dir="rtl" align="right">

---

# פרק 3: כתיבת הסקריפט ב-Python

## 3.1 מה זה Python?

Python היא שפת תכנות פופולרית מאוד בעולם ה-DevOps בגלל:
- קלה ללמידה
- ספריות רבות (libraries)
- מתאימה לאוטומציה
- קהילה גדולה

## 3.2 מה זה Pagination?

**שאלת ראיון נפוצה:** "איך מטפלים ב-API שמחזיר הרבה נתונים?"

**Pagination** = חלוקת נתונים לעמודים

**למה צריך?**
- ה-API שלנו מחזיר 826 דמויות
- לא הגיוני להחזיר הכל בבקשה אחת
- לכן ה-API מחזיר 20 דמויות בכל עמוד = 42 עמודים

**איך מטפלים?**

</div>

```
בקשה ראשונה:
GET /character?page=1
    ↓
תגובה: 20 דמויות + לינק לעמוד הבא
    ↓
בקשה שנייה:
GET /character?page=2
    ↓
תגובה: 20 דמויות + לינק לעמוד הבא
    ↓
... וכך הלאה עד עמוד 42
```

<div dir="rtl" align="right">

## 3.3 הקוד שכתבנו - הסבר מלא

**קובץ: main.py**

</div>

```python
#!/usr/bin/env python3
"""
סקריפט לשליפת דמויות מ-Rick and Morty API
"""

# ייבוא ספריות
import requests  # לשליחת בקשות HTTP
import csv       # לכתיבה לקובץ CSV

# כתובת ה-API
API_BASE_URL = "https://rickandmortyapi.com/api/character"


def fetch_all_characters():
    """
    שולף את כל הדמויות מה-API.
    מטפל ב-Pagination אוטומטית.
    """
    all_characters = []  # רשימה ריקה לאחסון כל הדמויות
    url = API_BASE_URL   # מתחילים מהעמוד הראשון
    
    while url:  # כל עוד יש עמוד הבא
        response = requests.get(url)  # שולחים בקשת GET
        response.raise_for_status()   # אם יש שגיאה - זורקים exception
        data = response.json()        # ממירים את התגובה ל-JSON
        
        all_characters.extend(data['results'])  # מוסיפים את הדמויות לרשימה
        url = data['info']['next']  # מעדכנים ל-URL הבא (או None אם נגמר)
    
    return all_characters


def filter_characters(characters):
    """
    מסנן דמויות לפי הקריטריונים:
    - species = Human (אנושי)
    - status = Alive (חי)
    - origin = Earth (מכדור הארץ)
    """
    filtered = []
    
    for char in characters:
        # בודקים כל קריטריון
        is_human = char['species'] == 'Human'
        is_alive = char['status'] == 'Alive'
        is_from_earth = 'Earth' in char['origin']['name']
        
        # אם כל התנאים מתקיימים
        if is_human and is_alive and is_from_earth:
            filtered.append({
                'Name': char['name'],
                'Location': char['location']['name'],
                'Image': char['image']
            })
    
    return filtered


def write_to_csv(characters, filename='output.csv'):
    """
    כותב את הדמויות לקובץ CSV.
    """
    with open(filename, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=['Name', 'Location', 'Image'])
        writer.writeheader()  # כותב את כותרות העמודות
        writer.writerows(characters)  # כותב את כל השורות
    
    print(f"נכתבו {len(characters)} דמויות לקובץ {filename}")


def main():
    """
    הפונקציה הראשית - מריצה את כל התהליך.
    """
    print("שולף דמויות מה-API...")
    
    # שלב 1: שליפת כל הדמויות
    all_characters = fetch_all_characters()
    print(f"סה״כ דמויות: {len(all_characters)}")
    
    # שלב 2: סינון
    filtered = filter_characters(all_characters)
    print(f"דמויות שעברו סינון: {len(filtered)}")
    
    # שלב 3: כתיבה לקובץ
    write_to_csv(filtered)


# נקודת הכניסה לתוכנית
if __name__ == "__main__":
    main()
```

<div dir="rtl" align="right">

## 3.4 מושגים חשובים בקוד

**שאלת ראיון נפוצה:** "מה זה `if __name__ == "__main__"`?"

**תשובה:** זה בודק אם הקובץ רץ ישירות (ולא מיובא כמודול).
- אם מריצים `python main.py` → הקוד ב-if ירוץ
- אם עושים `import main` מקובץ אחר → הקוד ב-if לא ירוץ

**שאלת ראיון נפוצה:** "מה ההבדל בין append ל-extend?"

</div>

```python
# append - מוסיף אלמנט אחד
list1 = [1, 2, 3]
list1.append([4, 5])
# תוצאה: [1, 2, 3, [4, 5]]

# extend - מוסיף את האלמנטים של הרשימה
list2 = [1, 2, 3]
list2.extend([4, 5])
# תוצאה: [1, 2, 3, 4, 5]
```

<div dir="rtl" align="right">

---

# פרק 4: מה זה Docker?

## 4.1 הבעיה שלפני Docker

**המצב ההיסטורי:**

</div>

```
מפתח 1:              מפתח 2:              שרת Production:
─────────            ─────────            ────────────────
Python 3.9           Python 3.11          Python 3.8
Windows              Mac                  Linux
Flask 2.0            Flask 3.0            Flask 1.0

        "אצלי זה עובד!" - כולם אומרים
```

<div dir="rtl" align="right">

## 4.2 מה Docker פותר?

**Docker** יוצר "קופסה" (Container) שבתוכה יש את כל מה שהאפליקציה צריכה.

</div>

```
┌─────────────────────────────────────────────────────────┐
│                   Docker Container                       │
│  ┌───────────────────────────────────────────────────┐  │
│  │  מערכת הפעלה (Linux)                              │  │
│  │  Python 3.11                                      │  │
│  │  Flask 3.0                                        │  │
│  │  הקוד שלנו                                        │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                         │
     ┌───────────────────┼───────────────────┐
     ▼                   ▼                   ▼
 Developer           Developer            Server
 (Windows)           (Mac)                (Linux)

              עובד אצל כולם!
```

<div dir="rtl" align="right">

## 4.3 מושגי יסוד ב-Docker

**שאלת ראיון נפוצה:** "מה ההבדל בין Image ל-Container?"

| מושג | הסבר | משל |
|------|------|-----|
| **Image** | תבנית לקריאה בלבד | מתכון לעוגה |
| **Container** | מופע רץ של Image | העוגה עצמה |
| **Dockerfile** | קובץ הוראות לבניית Image | רשימת המצרכים והוראות |
| **Registry** | מאגר לאחסון Images | חנות מתכונים (Docker Hub) |

**שאלת ראיון נפוצה:** "מה ההבדל בין Container ל-Virtual Machine?"

</div>

```
Virtual Machine:                    Container:
────────────────                    ──────────

┌──────────────────┐               ┌──────────────────┐
│   Application    │               │   Application    │
├──────────────────┤               ├──────────────────┤
│   Guest OS       │               │   (No OS!)       │
│   (Full Linux)   │               │                  │
├──────────────────┤               ├──────────────────┤
│   Hypervisor     │               │  Docker Engine   │
├──────────────────┤               ├──────────────────┤
│   Host OS        │               │   Host OS        │
├──────────────────┤               ├──────────────────┤
│   Hardware       │               │   Hardware       │
└──────────────────┘               └──────────────────┘

גודל: GB                           גודל: MB
עלייה: דקות                        עלייה: שניות
```

<div dir="rtl" align="right">

## 4.4 ה-Dockerfile שלנו - שורה אחרי שורה

</div>

```dockerfile
# ═══════════════════════════════════════════════════════════════
# שורה 1: FROM - מאיזו תמונת בסיס להתחיל?
# ═══════════════════════════════════════════════════════════════
FROM python:3.11-slim
# python:3.11-slim = תמונה רשמית של Python גרסה 3.11
# slim = גרסה "רזה" - בלי extras מיותרים (קטנה יותר)

# ═══════════════════════════════════════════════════════════════
# שורה 2: WORKDIR - באיזו תיקייה לעבוד בתוך הקונטיינר?
# ═══════════════════════════════════════════════════════════════
WORKDIR /app
# יוצר תיקייה /app ועובר אליה
# כל הפקודות הבאות יתבצעו מתוך /app

# ═══════════════════════════════════════════════════════════════
# שורה 3-4: התקנת dependencies
# ═══════════════════════════════════════════════════════════════
COPY app/requirements.txt .
# מעתיק את קובץ הדרישות מהמחשב שלנו לתוך הקונטיינר

RUN pip install --no-cache-dir -r requirements.txt
# מתקין את הספריות (Flask, requests)
# --no-cache-dir = לא שומר cache (חוסך מקום)

# ═══════════════════════════════════════════════════════════════
# שורה 5: העתקת הקוד
# ═══════════════════════════════════════════════════════════════
COPY app/ .
# מעתיק את כל התיקייה app/ לתוך /app בקונטיינר

# ═══════════════════════════════════════════════════════════════
# שורה 6: EXPOSE - איזה פורט האפליקציה מאזינה?
# ═══════════════════════════════════════════════════════════════
EXPOSE 5000
# מסמן שהאפליקציה מאזינה על פורט 5000
# הערה: זה רק תיעוד! לא באמת פותח פורט

# ═══════════════════════════════════════════════════════════════
# שורה 7: CMD - מה להריץ כשהקונטיינר עולה?
# ═══════════════════════════════════════════════════════════════
CMD ["python", "api.py"]
# מריץ את הפקודה: python api.py
```

<div dir="rtl" align="right">

## 4.5 Docker Layer Caching

**שאלת ראיון נפוצה:** "למה חשוב סדר הפקודות ב-Dockerfile?"

כל שורה ב-Dockerfile יוצרת **Layer** (שכבה).
Docker שומר את השכבות במטמון.
אם שכבה לא השתנתה, Docker משתמש בגרסה השמורה.

**למה קודם מעתיקים requirements.txt ורק אחר כך את הקוד?**

</div>

```
Build ראשון:                    Build שני (שינוי בקוד):
────────────                    ────────────────────────

Layer 1: FROM python      →    Layer 1: FROM python      [CACHED]
Layer 2: COPY requirements →   Layer 2: COPY requirements [CACHED]
Layer 3: RUN pip install  →    Layer 3: RUN pip install  [CACHED]
Layer 4: COPY app/        →    Layer 4: COPY app/        [REBUILD]
Layer 5: CMD              →    Layer 5: CMD              [REBUILD]

זמן: 60 שניות                   זמן: 5 שניות!
```

<div dir="rtl" align="right">

אם היינו מעתיקים קודם את הקוד, כל שינוי קטן היה גורם להתקנה מחדש של כל הספריות!

## 4.6 פקודות Docker חיוניות

**שאלת ראיון נפוצה:** "תראה לי את פקודות Docker הבסיסיות"

</div>

```bash
# ═══════════════════════════════════════════════════════════════
# בניית Image
# ═══════════════════════════════════════════════════════════════
docker build -t rick-morty-api .
#        │    └─────────────────┘ └┘
#        │           שם             הקובץ נמצא בתיקייה הנוכחית
#        └── build = בנה image

# ═══════════════════════════════════════════════════════════════
# הרצת Container
# ═══════════════════════════════════════════════════════════════
docker run -d -p 5000:5000 --name my-api rick-morty-api
#          │  └──────────┘ └──────────┘ └─────────────┘
#          │  port mapping   שם          שם ה-image
#          │  host:container
#          └── detached (ברקע)

# ═══════════════════════════════════════════════════════════════
# הצגת Containers רצים
# ═══════════════════════════════════════════════════════════════
docker ps
# מציג רק containers פעילים

docker ps -a
# מציג את כל ה-containers (גם עצורים)

# ═══════════════════════════════════════════════════════════════
# צפייה בלוגים
# ═══════════════════════════════════════════════════════════════
docker logs my-api
# מציג את הלוגים של הקונטיינר

docker logs -f my-api
# מציג לוגים בזמן אמת (follow)

# ═══════════════════════════════════════════════════════════════
# כניסה לתוך Container
# ═══════════════════════════════════════════════════════════════
docker exec -it my-api /bin/bash
#           │││
#           │└┴── interactive + tty (טרמינל אינטראקטיבי)
#           └── execute = הרץ פקודה

# ═══════════════════════════════════════════════════════════════
# עצירה ומחיקה
# ═══════════════════════════════════════════════════════════════
docker stop my-api     # עוצר את הקונטיינר
docker rm my-api       # מוחק את הקונטיינר
docker rmi rick-morty-api  # מוחק את ה-image
```

<div dir="rtl" align="right">

---

# פרק 5: מה זה Kubernetes?

## 5.1 למה צריך Kubernetes?

**המצב עם Docker בלבד:**

</div>

```
┌─────────────────┐
│   Container     │  ← אם נופל - אף אחד לא מרים אותו
│   rick-morty    │  ← אם יש עומס - אין אפשרות להוסיף עותקים
│                 │  ← אין חלוקת עומסים
└─────────────────┘
```

<div dir="rtl" align="right">

**מה Kubernetes פותר:**

</div>

```
┌──────────────────────────────────────────────────────────┐
│                  Kubernetes Cluster                       │
│                                                          │
│   ┌─────────┐  ┌─────────┐  ┌─────────┐                 │
│   │  Pod 1  │  │  Pod 2  │  │  Pod 3  │  ← Scaling      │
│   │   API   │  │   API   │  │   API   │    אוטומטי     │
│   └─────────┘  └─────────┘  └─────────┘                 │
│        │            │            │                       │
│        └────────────┼────────────┘                       │
│                     │                                    │
│              Load Balancing                              │
│              חלוקת עומסים                               │
│                                                          │
│   + Self Healing - אם Pod נופל, קם חדש אוטומטית        │
│   + Rolling Updates - עדכונים בלי downtime             │
│   + Service Discovery - Pods מוצאים אחד את השני        │
└──────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 5.2 מושגי יסוד ב-Kubernetes

**שאלת ראיון נפוצה:** "מה זה Pod?"

| מושג | הסבר | משל |
|------|------|-----|
| **Cluster** | קבוצת שרתים שמנהלים יחד | עיר שלמה |
| **Node** | שרת בודד בקלאסטר | בניין בעיר |
| **Pod** | יחידת ההרצה הקטנה ביותר. מכיל Container אחד או יותר | דירה בבניין |
| **Deployment** | מגדיר איך להריץ Pods (כמה עותקים, איזה image) | חוזה שכירות |
| **Service** | חושף Pods לתקשורת. מאפשר Load Balancing | דלפק קבלה |
| **Ingress** | חושף שירותים לעולם החיצוני עם domain | כתובת הבניין |

## 5.3 הקבצים שיצרנו ומה הם עושים

</div>

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│  deployment.yaml ──▶ service.yaml ──▶ ingress.yaml              │
│                                                                  │
│       "מה"              "איך"           "איפה"                   │
│       להריץ             להגיע           לחשוף                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 5.4 Deployment - הסבר מלא

**קובץ: yamls/deployment.yaml**

</div>

```yaml
apiVersion: apps/v1       # גרסת ה-API של Kubernetes
kind: Deployment          # סוג המשאב
metadata:
  name: rick-morty-api    # שם הפריסה
  labels:
    app: rick-morty-api   # תוויות לזיהוי

spec:
  replicas: 2             # כמה עותקים (Pods) להריץ
  
  selector:
    matchLabels:
      app: rick-morty-api # לאילו Pods הפריסה שייכת
  
  template:               # תבנית ליצירת Pod
    metadata:
      labels:
        app: rick-morty-api
    spec:
      containers:
      - name: rick-morty-api
        image: rick-morty-api:latest  # איזה Docker Image
        ports:
        - containerPort: 5000         # איזה פורט

        # ═══════════════════════════════════════════════════════
        # Liveness Probe - בדיקת חיים
        # אם נכשל: Kubernetes יעשה restart ל-Pod
        # ═══════════════════════════════════════════════════════
        livenessProbe:
          httpGet:
            path: /healthcheck
            port: 5000
          initialDelaySeconds: 10   # המתן 10 שניות לפני בדיקה ראשונה
          periodSeconds: 30         # בדוק כל 30 שניות

        # ═══════════════════════════════════════════════════════
        # Readiness Probe - בדיקת מוכנות
        # אם נכשל: לא ישלחו traffic ל-Pod הזה
        # ═══════════════════════════════════════════════════════
        readinessProbe:
          httpGet:
            path: /healthcheck
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 10

        # ═══════════════════════════════════════════════════════
        # Resource Limits - הגבלת משאבים
        # ═══════════════════════════════════════════════════════
        resources:
          requests:         # מינימום מובטח
            memory: "64Mi"  # 64 מגה זיכרון
            cpu: "100m"     # 0.1 CPU (100 millicores)
          limits:           # מקסימום מותר
            memory: "128Mi"
            cpu: "200m"
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "מה ההבדל בין Liveness Probe ל-Readiness Probe?"

| Probe | מטרה | מה קורה אם נכשל |
|-------|------|-----------------|
| **Liveness** | לבדוק אם האפליקציה חיה | Restart ל-Container |
| **Readiness** | לבדוק אם האפליקציה מוכנה | לא שולחים traffic |

**דוגמה:** 
- אפליקציה עלתה אבל עדיין טוענת נתונים
- Liveness יעבור (היא חיה)
- Readiness ייכשל (היא לא מוכנה לקבל בקשות)

## 5.5 Service - הסבר מלא

**קובץ: yamls/service.yaml**

</div>

```yaml
apiVersion: v1
kind: Service
metadata:
  name: rick-morty-api-service
  labels:
    app: rick-morty-api

spec:
  type: ClusterIP         # סוג השירות (ראה טבלה למטה)
  ports:
  - port: 80              # הפורט שהשירות חושף
    targetPort: 5000      # הפורט של ה-Container
    protocol: TCP
  selector:
    app: rick-morty-api   # לאילו Pods לנתב (לפי labels)
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "מה ההבדל בין סוגי Service?"

**תשובה מלאה לראיון:**

"Service פותר בעיה מרכזית: Pods הם זמניים, ה-IP שלהם משתנה. Service נותן כתובת קבועה."

**4 סוגי Services בפירוט:**

| סוג | איך עובד | נגישות | מתי להשתמש |
|-----|----------|--------|------------|
| **ClusterIP** | IP פנימי קבוע | רק מתוך הקלאסטר | Backend → DB, Microservices פנימיים |
| **NodePort** | פותח Port (30000-32767) על כל Node | `NodeIP:Port` | Dev/Testing, On-prem בלי Cloud LB |
| **LoadBalancer** | יוצר Cloud LB (ALB, GCP LB) | External IP יציב | **Production!** |
| **ExternalName** | DNS alias לשירות חיצוני | N/A | גישה ל-RDS, APIs חיצוניים |

**NodePort - למה לא ל-Production:**
- Port לא סטנדרטי (לא 80/443)
- צריך לדעת IP של Node ספציפי
- אם Node נופל - אין גישה דרכו
- אין Health checks ברמת ה-LB

**LoadBalancer - מה קורה מאחורי הקלעים:**
```
User → Cloud LB → NodePort → ClusterIP → Pods
       (34.1.2.3)   (מוסתר)    (מוסתר)
```
LoadBalancer "בונה" על שני הסוגים האחרים!

## 5.6 Ingress - הסבר מלא

**קובץ: yamls/ingress.yaml**

</div>

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: rick-morty-api-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /

spec:
  ingressClassName: nginx    # איזה Ingress Controller
  rules:
  - host: rick-morty.local   # ה-domain
    http:
      paths:
      - path: /              # הנתיב
        pathType: Prefix
        backend:
          service:
            name: rick-morty-api-service  # לאיזה Service לנתב
            port:
              number: 80
```

<div dir="rtl" align="right">

**שאלת ראיון נפוצה:** "מה ההבדל בין Service ל-Ingress?"

| רכיב | תפקיד |
|------|-------|
| **Service** | חשיפה פנימית + Load Balancing בין Pods |
| **Ingress** | חשיפה חיצונית + ניתוב לפי domain/path + SSL |

## 5.7 פקודות kubectl חיוניות

**שאלת ראיון נפוצה:** "איך בודקים מצב של Pods בקלאסטר?"

</div>

```bash
# ═══════════════════════════════════════════════════════════════
# הצגת משאבים
# ═══════════════════════════════════════════════════════════════
kubectl get pods              # הצג את כל ה-Pods
kubectl get pods -o wide      # הצג עם מידע נוסף (IP, Node)
kubectl get services          # הצג את כל ה-Services
kubectl get deployments       # הצג את כל ה-Deployments
kubectl get ingress           # הצג את כל ה-Ingresses
kubectl get all               # הצג הכל

# ═══════════════════════════════════════════════════════════════
# יישום קבצי YAML
# ═══════════════════════════════════════════════════════════════
kubectl apply -f deployment.yaml   # יישם קובץ בודד
kubectl apply -f yamls/            # יישם כל הקבצים בתיקייה

# ═══════════════════════════════════════════════════════════════
# מידע מפורט
# ═══════════════════════════════════════════════════════════════
kubectl describe pod <pod-name>    # מידע מפורט על Pod
kubectl logs <pod-name>            # לוגים של Pod
kubectl logs -f <pod-name>         # לוגים בזמן אמת

# ═══════════════════════════════════════════════════════════════
# ניפוי באגים
# ═══════════════════════════════════════════════════════════════
kubectl exec -it <pod-name> -- /bin/bash   # כניסה ל-Pod
kubectl port-forward svc/my-service 8080:80 # העברת פורט

# ═══════════════════════════════════════════════════════════════
# מחיקה
# ═══════════════════════════════════════════════════════════════
kubectl delete -f deployment.yaml  # מחק לפי קובץ
kubectl delete pod <pod-name>      # מחק Pod ספציפי
```

<div dir="rtl" align="right">

---

# פרק 6: הזרימה המלאה - איך הכל מתחבר

## 6.1 תרשים מקיף

</div>

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              התמונה הגדולה                                   │
└─────────────────────────────────────────────────────────────────────────────┘

                    משתמש מהאינטרנט
                          │
                          │ HTTP Request
                          │ http://rick-morty.local/characters
                          ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                          Kubernetes Cluster                                  │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                           INGRESS                                       │ │
│  │                                                                         │ │
│  │  1. מקבל את הבקשה                                                       │ │
│  │  2. בודק את ה-host (rick-morty.local)                                  │ │
│  │  3. בודק את ה-path (/)                                                 │ │
│  │  4. מעביר ל-Service המתאים                                             │ │
│  │                                                                         │ │
│  └────────────────────────────────────┬───────────────────────────────────┘ │
│                                       │                                      │
│  ┌────────────────────────────────────┼───────────────────────────────────┐ │
│  │                           SERVICE                                       │ │
│  │                                    │                                    │ │
│  │  1. מקבל את הבקשה מ-Ingress       │                                    │ │
│  │  2. מחפש Pods עם התווית המתאימה   │                                    │ │
│  │  3. מפזר עומסים (Load Balance)     │                                    │ │
│  │  4. מעביר ל-Pod שנבחר             │                                    │ │
│  │                                    │                                    │ │
│  │                    ┌───────────────┴───────────────┐                    │ │
│  │                    │                               │                    │ │
│  └────────────────────┼───────────────────────────────┼────────────────────┘ │
│                       │                               │                      │
│          ┌────────────┴─────────────┐    ┌───────────┴────────────┐         │
│          ▼                          ▼    ▼                        ▼         │
│  ┌───────────────┐          ┌───────────────┐          ┌───────────────┐    │
│  │     POD 1     │          │     POD 2     │          │     POD N     │    │
│  │ ┌───────────┐ │          │ ┌───────────┐ │          │ ┌───────────┐ │    │
│  │ │ Container │ │          │ │ Container │ │          │ │ Container │ │    │
│  │ │           │ │          │ │           │ │          │ │           │ │    │
│  │ │  api.py   │ │          │ │  api.py   │ │          │ │  api.py   │ │    │
│  │ │  Flask    │ │          │ │  Flask    │ │          │ │  Flask    │ │    │
│  │ │  :5000    │ │          │ │  :5000    │ │          │ │  :5000    │ │    │
│  │ │           │ │          │ │           │ │          │ │           │ │    │
│  │ └───────────┘ │          │ └───────────┘ │          │ └───────────┘ │    │
│  └───────────────┘          └───────────────┘          └───────────────┘    │
│          │                          │                          │            │
│          │                          │                          │            │
│          └──────────────────────────┴──────────────────────────┘            │
│                                     │                                        │
│                           DEPLOYMENT                                        │
│                      (מנהל את כל ה-Pods)                                    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      │ HTTP Request
                                      ▼
                         ┌─────────────────────────┐
                         │  Rick and Morty API     │
                         │  rickandmortyapi.com    │
                         └─────────────────────────┘
```

<div dir="rtl" align="right">

## 6.2 מה קורה כשמשתמש שולח בקשה?

**שלב 1: Ingress**
- מקבל בקשה ל-`rick-morty.local/characters`
- בודק את כללי הניתוב
- מעביר ל-Service `rick-morty-api-service` על פורט 80

**שלב 2: Service**
- מקבל את הבקשה
- מוצא את כל ה-Pods עם `app: rick-morty-api`
- בוחר Pod (Round Robin / Random)
- מעביר את הבקשה לפורט 5000 של ה-Pod

**שלב 3: Pod**
- ה-Container מקבל את הבקשה
- Flask מזהה את הנתיב `/characters`
- הקוד קורא מ-Rick and Morty API
- מסנן את הדמויות
- מחזיר JSON

**שלב 4: חזרה**
- התגובה עוברת: Pod ← Service ← Ingress ← משתמש

---

# פרק 7: שאלות ראיון נפוצות - סיכום

## 7.1 שאלות על API

| שאלה | תשובה |
|------|-------|
| מה זה REST API? | ארכיטקטורה לתקשורת בין מערכות המבוססת על HTTP |
| מה ההבדל בין GET ל-POST? | GET לקריאה, POST ליצירה |
| מה זה Status Code 500? | שגיאה בצד השרת |
| איך מטפלים ב-Pagination? | קוראים עמוד-עמוד עד שאין next |

## 7.2 שאלות על Docker

| שאלה | תשובה |
|------|-------|
| מה ההבדל בין Image ל-Container? | Image = תבנית, Container = מופע רץ |
| למה Docker ולא VM? | יותר קל, מהיר, וצורך פחות משאבים |
| מה עושה EXPOSE? | מתעד איזה פורט האפליקציה מאזינה (לא פותח באמת) |
| מה ההבדל בין CMD ל-ENTRYPOINT? | CMD ניתן לדריסה, ENTRYPOINT קבוע |

## 7.3 שאלות על Kubernetes

| שאלה | תשובה |
|------|-------|
| מה זה Pod? | יחידת ההרצה הקטנה ביותר, מכיל Container אחד או יותר |
| מה ההבדל בין Deployment ל-Pod? | Deployment מנהל Pods (replicas, updates) |
| מתי משתמשים ב-ClusterIP? | לשירותים פנימיים בלבד |
| מה עושה Liveness Probe? | בודק אם האפליקציה חיה. אם לא - restart |

---

# פרק 8: מבנה הפרויקט הסופי

</div>

```
rick-morty-devops/
│
├── app/                          # קוד האפליקציה
│   ├── main.py                   # סקריפט שמייצר CSV
│   ├── api.py                    # שרת REST API
│   ├── requirements.txt          # ספריות Python נדרשות
│   └── output.csv                # קובץ הפלט
│
├── yamls/                        # קבצי Kubernetes
│   ├── deployment.yaml           # הגדרת הפריסה
│   ├── service.yaml              # הגדרת השירות
│   └── ingress.yaml              # הגדרת הכניסה
│
├── Dockerfile                    # הוראות לבניית Docker Image
├── .gitignore                    # קבצים להתעלמות ב-Git
└── README.md                     # תיעוד הפרויקט
```

<div dir="rtl" align="right">

---

# פרק 9: מפת הקשרים - איך הכל מתחבר

## 9.1 המפה הגדולה - כל הפרויקט במבט אחד

</div>

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│                          🗺️ MINDMAP - מפת הפרויקט המלאה                                │
│                                                                                         │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                         │
│                                ┌─────────────────────┐                                  │
│                                │   🎯 המשימה שלנו   │                                  │
│                                │  Rick & Morty API   │                                  │
│                                └──────────┬──────────┘                                  │
│                                           │                                             │
│                ┌──────────────────────────┼──────────────────────────┐                  │
│                │                          │                          │                  │
│                ▼                          ▼                          ▼                  │
│     ┌─────────────────┐       ┌─────────────────┐       ┌─────────────────┐            │
│     │  📊 DATA        │       │  🔧 CODE        │       │  🚀 DEPLOY      │            │
│     │  מאיפה המידע?   │       │  איך מעבדים?    │       │  איך מריצים?    │            │
│     └────────┬────────┘       └────────┬────────┘       └────────┬────────┘            │
│              │                         │                         │                      │
│              ▼                         ▼                         ▼                      │
│ ┌─────────────────────────┐  ┌─────────────────────────┐  ┌─────────────────────────┐  │
│ │ rickandmortyapi.com     │  │ Python Scripts          │  │ Docker + Kubernetes     │  │
│ │ └─▶ 826 דמויות         │  │ └─▶ main.py (CSV)       │  │ └─▶ Container           │  │
│ │ └─▶ 42 עמודים          │  │ └─▶ api.py (REST)       │  │ └─▶ Pods                │  │
│ │ └─▶ JSON format        │  │ └─▶ סינון + עיבוד       │  │ └─▶ Services            │  │
│ └─────────────────────────┘  └─────────────────────────┘  └─────────────────────────┘  │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 9.2 זרימת הנתונים - השרשרת המלאה

</div>

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│                          📡 THE CHAIN - שרשרת הבקשה                                     │
│                                                                                         │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                         │
│   User Request                                                                          │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  INGRESS (rick-morty.local)                                                      │  │
│   │  • בודק host ו-path                                                              │  │
│   │  • מעביר לשירות המתאים                                                           │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  SERVICE (finds pods by label, load balance)                                     │  │
│   │  • מוצא את ה-Pods לפי label                                                      │  │
│   │  • מפזר עומסים בין ה-Pods                                                        │  │
│   │  • ממיר port 80 → 5000                                                          │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  POD (runs container from image)                                                 │  │
│   │  • מריץ Container מה-Docker Image                                                │  │
│   │  • liveness + readiness probes בודקים אותו                                       │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  CONTAINER (runs api.py on port 5000)                                            │  │
│   │  • Python + Flask                                                                │  │
│   │  • מאזין על port 5000                                                            │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  FLASK (handles /characters route)                                               │  │
│   │  • מזהה את הנתיב /characters                                                     │  │
│   │  • קורא לפונקציה המתאימה                                                         │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  PYTHON CODE (calls external API, filters data)                                  │  │
│   │  • שולח בקשות ל-Rick & Morty API                                                 │  │
│   │  • מטפל ב-Pagination (42 עמודים)                                                 │  │
│   │  • מסנן: Human + Alive + Earth                                                   │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  RICK & MORTY API (External)                                                     │  │
│   │  • 826 דמויות ב-42 עמודים                                                        │  │
│   │  • מחזיר JSON                                                                    │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │  FILTER (109 characters remain)                                                  │  │
│   │  species == "Human" ✓                                                            │  │
│   │  status == "Alive" ✓                                                             │  │
│   │  origin contains "Earth" ✓                                                       │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│        │                                                                                │
│        ▼                                                                                │
│   JSON Response back to User                                                            │
│   {"count": 109, "characters": [...]}                                                   │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 9.3 מפת הקבצים - מי תלוי במי?

</div>

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                                                                         │
│                      📁 FILE DEPENDENCIES - תלויות בין קבצים                           │
│                                                                                         │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                         │
│   requirements.txt                                                                      │
│        │                                                                                │
│        │ pip install                                                                    │
│        ▼                                                                                │
│   ┌─────────────┐                         ┌─────────────┐                               │
│   │  main.py    │                         │   api.py    │                               │
│   │  imports:   │                         │  imports:   │                               │
│   │  - requests │                         │  - requests │                               │
│   │  - csv      │                         │  - flask    │                               │
│   │             │                         │             │                               │
│   │  OUTPUT:    │                         │  ENDPOINTS: │                               │
│   │  output.csv │                         │ /characters │                               │
│   └─────────────┘                         │ /healthcheck│                               │
│                                           └──────┬──────┘                               │
│                                                  │                                      │
│                                                  │ runs                                 │
│                                                  ▼                                      │
│                                           ┌─────────────┐                               │
│                                           │ Dockerfile  │                               │
│                                           │ CMD api.py  │                               │
│                                           └──────┬──────┘                               │
│                                                  │                                      │
│                                                  │ creates                              │
│                                                  ▼                                      │
│                                           ┌─────────────┐                               │
│                                           │Docker Image │                               │
│                                           │rick-morty-api                               │
│                                           └──────┬──────┘                               │
│                                                  │                                      │
│                          ┌───────────────────────┼───────────────────────┐              │
│                          │                       │                       │              │
│                          ▼                       ▼                       ▼              │
│                  ┌───────────────┐      ┌───────────────┐      ┌───────────────┐        │
│                  │deployment.yaml│      │ service.yaml  │      │ ingress.yaml  │        │
│                  │               │      │               │      │               │        │
│                  │ image: rick-  │      │ selector:     │      │ backend:      │        │
│                  │ morty-api     │◀─────│ app: rick-    │◀─────│ service:      │        │
│                  │               │      │ morty-api     │      │ rick-morty    │        │
│                  │ labels:       │──────▶               │      │               │        │
│                  │ app: rick-    │      │               │      │               │        │
│                  │ morty-api     │      │               │      │               │        │
│                  │               │      │               │      │               │        │
│                  │ probes:       │      │               │      │               │        │
│                  │ /healthcheck──┼──────▶ calls api.py endpoint                │        │
│                  └───────────────┘      └───────────────┘      └───────────────┘        │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

<div dir="rtl" align="right">

## 9.4 סיכום כל הקשרים

| # | מה | מתחבר ל | איך |
|---|-----|---------|-----|
| 1 | requirements.txt | Python files | pip install |
| 2 | main.py / api.py | Rick & Morty API | requests.get() |
| 3 | api.py | Port 5000 | Flask app.run() |
| 4 | Dockerfile | api.py | CMD ["python", "api.py"] |
| 5 | deployment.yaml | Docker Image | image: rick-morty-api |
| 6 | deployment.yaml | Pods | labels: app: rick-morty-api |
| 7 | service.yaml | Pods | selector: app: rick-morty-api |
| 8 | service.yaml | Container | port: 80 → targetPort: 5000 |
| 9 | ingress.yaml | Service | backend: service |
| 10 | Probes | api.py | httpGet: /healthcheck |

---

# סיכום

**מה למדנו:**

1. **API** - איך לקרוא נתונים משירות חיצוני
2. **Python** - איך לכתוב סקריפט שמעבד נתונים
3. **Docker** - איך לארוז אפליקציה לקונטיינר
4. **Kubernetes** - איך לפרוס ולנהל אפליקציה בענן

**מה הפרויקט מדגים:**
- הבנה של מחזור חיים של אפליקציה
- יכולת לכתוב קוד נקי ומתועד
- ידע ב-Containerization
- הבנה של Orchestration

---

# חלק ב׳: שאלות ראיון DevOps - מדריך מקיף

---

## פרק 10: AWS VPC - כל מה שצריך לדעת

### ❓ "מה זה VPC?"

**VPC** (Virtual Private Cloud) = רשת וירטואלית פרטית בענן AWS.

זה כמו לבנות את הרשת הפרטית שלך בתוך AWS - אתה מחליט:
- איזה טווח כתובות IP (CIDR)
- איך לחלק ל-Subnets
- מי יכול לגשת למה
- איך תנועה נכנסת ויוצאת

### ❓ "מה ההבדל בין Subnet פרטי לציבורי?"

| מאפיין | Public Subnet | Private Subnet |
|--------|---------------|----------------|
| גישה לאינטרנט | ישירה דרך IGW | רק דרך NAT Gateway |
| IP ציבורי | יש | אין |
| Route Table | מצביע ל-IGW | מצביע ל-NAT |
| שימוש | Web servers, Load Balancers | Databases, Internal services |

### ❓ "מהו Internet Gateway?"

**Internet Gateway (IGW)** = שער שמאפשר תקשורת בין VPC לאינטרנט.
- מאפשר לשרתים ב-Public Subnet לצאת ולהיכנס מהאינטרנט
- Highly Available - AWS מנהל אותו
- חינמי (משלמים רק על Data Transfer)

### ❓ "מהו NAT Gateway?"

**NAT Gateway** = מאפשר לשרתים ב-Private Subnet לצאת לאינטרנט בלי להיחשף.
- יציאה בלבד - אין אפשרות להיכנס מבחוץ
- יושב ב-Public Subnet
- עולה כסף (לפי שעה + Data)

### ❓ "מהי טכנולוגיית Private Link?"

**Private Link / VPC Endpoints** = גישה לשירותי AWS בלי לעבור דרך האינטרנט.

**שני סוגים:**
- **Interface Endpoint** - ENI בתוך ה-VPC. עובד עם רוב השירותים.
- **Gateway Endpoint** - רק ל-S3 ו-DynamoDB. חינמי!

---

## פרק 11: AWS IAM - זהויות והרשאות

### ❓ "מה ההבדל בין IAM Role ל-IAM User?"

| מאפיין | IAM User | IAM Role |
|--------|----------|----------|
| מיועד ל | אנשים (בני אדם) | שירותים / אפליקציות |
| אימות | Username + Password | Assume Role (זמני) |
| תוקף | קבוע עד שמוחקים | זמני (credentials מתחלפים) |
| דוגמה | מפתח שנכנס ל-Console | EC2 שניגש ל-S3 |

### ❓ "מה ההבדל בין IAM Policy ל-Resource Based Policy?"

| סוג | IAM Policy | Resource Based Policy |
|-----|------------|----------------------|
| מוצמד ל | User / Group / Role | משאב (S3 Bucket, SQS) |
| מגדיר | "מה המשתמש יכול לעשות" | "מי יכול לגשת למשאב" |
| Cross-Account | דורש Assume Role | ישיר |

---

## פרק 12: AWS Storage

### ❓ "מה ההבדל בין EBS ל-EFS?"

| מאפיין | EBS | EFS |
|--------|-----|-----|
| סוג | Block Storage (דיסק) | File Storage (NFS) |
| חיבור | EC2 אחד בלבד | מרובה EC2 |
| Scaling | ידני | אוטומטי |
| מחיר | זול יותר | יקר יותר |
| שימוש | Database, Boot | Shared files |

### ❓ "מה זה S3?"

**S3** (Simple Storage Service) = Object Storage.
- **Unlimited** - אין הגבלה
- **Durability** - 99.999999999%
- **Storage Classes** - Standard, IA, Glacier
- **שימושים:** Backup, Static website, Data lake

---

## פרק 13: AWS Compute

### ❓ "מה ההבדל בין On-Demand, Reserved, Spot, Dedicated?"

| סוג | מאפיין | הנחה | שימוש |
|-----|--------|------|-------|
| **On-Demand** | לפי שימוש | 0% | Dev, Testing |
| **Reserved** | התחייבות 1-3 שנים | עד 72% | Production |
| **Spot** | קיבולת עודפת | עד 90% | Batch jobs |
| **Dedicated** | שרת פיזי שלם | תלוי | Compliance |

### ❓ "מה זה Lambda?"

**Lambda** = Serverless compute.
- Event-driven
- Pay per use
- Auto-scale
- Max 15 minutes

### ❓ "איזה שירות מתזמן טריגרים של Lambda?"

**Amazon EventBridge** - Cron, Rate, Event patterns

---

## פרק 14: Load Balancing, DNS, CDN

### ❓ "אילו סוגי Load Balancer יש?"

| סוג | שכבה | שימוש |
|-----|------|-------|
| **ALB** | Layer 7 | Web apps, Microservices |
| **NLB** | Layer 4 | High performance |
| **GLB** | Layer 3 | Security appliances |

### ❓ "מה ההבדל בין ניתוב Geolocation, Latency, Weight?"

| סוג | לוגיקה | שימוש |
|-----|--------|-------|
| **Geolocation** | לפי מיקום | תוכן מותאם למדינה |
| **Latency** | לפי זמן תגובה | ביצועים מיטביים |
| **Weighted** | לפי אחוזים | A/B testing |

### ❓ "מה זה CloudFront?"

**CloudFront** = CDN של AWS.
- מפיץ תוכן ל-Edge Locations
- מוריד Latency
- Caching
- SSL/TLS מובנה

### ❓ "האם SSL חינם? מהו ACM?"

**ACM** = AWS Certificate Manager. **חינם!**
- חידוש אוטומטי
- עובד עם: ALB, CloudFront, API Gateway

---

## פרק 15: Databases

### ❓ "מה ההבדל בין DB רלציוני ללא-רלציוני?"

| מאפיין | SQL | NoSQL |
|--------|-----|-------|
| מבנה | טבלאות | Documents, Key-Value |
| Schema | קבוע | גמיש |
| Scaling | Vertical | Horizontal |
| AWS | RDS, Aurora | DynamoDB |

### ❓ "מה זה Redis?"

**Redis** = In-memory key-value store.
- מהיר מאוד
- Caching
- Session storage
- **AWS:** ElastiCache for Redis

### ❓ "מה ההבדל בין Standby ל-Primary DB?"

| סוג | תפקיד |
|-----|-------|
| **Primary** | Write + Read |
| **Standby** | רק גיבוי - Failover אוטומטי |
| **Read Replica** | רק Read |

---

## פרק 16: Kubernetes מתקדם

### ❓ "מהו Namespace?"

**Namespace** = חלוקה לוגית של הקלאסטר.
- מפריד בין סביבות
- מאפשר Resource Quotas

### ❓ "מה ההבדל בין Deployment ל-ReplicaSet?"

| מאפיין | ReplicaSet | Deployment |
|--------|------------|------------|
| Rolling Updates | ❌ | ✅ |
| Rollback | ❌ | ✅ |
| שימוש | נדיר | תמיד! |

### ❓ "מה זה Ingress ו-Ingress Controller?"

| רכיב | תפקיד |
|------|-------|
| **Ingress** | YAML שמגדיר חוקי ניתוב |
| **Ingress Controller** | התוכנה שאוכפת (NGINX) |

### ❓ "מהו Sidecar, Init, Application Container?"

| סוג | מתי רץ | תפקיד |
|-----|--------|-------|
| **Init** | לפני Main | הכנות |
| **Application** | אחרי Init | האפליקציה |
| **Sidecar** | במקביל | עזר (Logging) |

### ❓ "מה זה Probe? Liveness?"

| Probe | שואל | אם נכשל |
|-------|------|---------|
| **Liveness** | "אתה חי?" | Restart |
| **Readiness** | "אתה מוכן?" | No traffic |

### ❓ "מהו Service Account?"

**Service Account** = זהות עבור Pods.
- תקשורת עם K8s API
- RBAC permissions
- קישור ל-AWS IAM (IRSA)

### ❓ "איך מתבצע Autoscale?"

- **HPA** - מוסיף Pods לפי metrics
- **VPA** - משנה Resources
- **Cluster Autoscaler** - מוסיף Nodes

### ❓ "מה זה PVC?"

**PVC** = Persistent Volume Claim = בקשה לאחסון.
- **PV** = האחסון הפיזי
- **PVC** = הבקשה
- **StorageClass** = סוג האחסון

---

## פרק 17: סוגי Workloads

### ❓ "StatefulSet vs DaemonSet vs Deployment?"

| סוג | תפקיד | דוגמה |
|-----|-------|-------|
| **Deployment** | Stateless, Pods זהים | Web servers |
| **StatefulSet** | Stateful, זהות קבועה | Databases |
| **DaemonSet** | Pod על כל Node | Logging agent |

### ❓ "סוגי Services?"

| סוג | נגישות |
|-----|--------|
| **ClusterIP** | רק מתוך הקלאסטר |
| **NodePort** | Port על כל Node |
| **LoadBalancer** | Cloud LB חיצוני |

### ❓ "מה הן 4 אסטרטגיות הפריסה ב-Kubernetes?"

**תשובה לראיון:**

"יש כמה דרכים לעדכן אפליקציה ב-Production. כל אסטרטגיה מתאימה למצב אחר, תלוי אם יש לנו Downtime, כמה מהר רוצים Rollback, וכמה משאבים יש."

---

**1. Rolling Update (ברירת מחדל)**

**מה קורה:** מחליפים Pod אחד בכל פעם. תמיד יש Pods שרצים.

```
שלב 1: [v1] [v1] [v1] [v1]     ← 4 pods ישנים
שלב 2: [v1] [v1] [v1] [v2]     ← מוסיפים 1 חדש, מורידים 1 ישן
שלב 3: [v1] [v1] [v2] [v2]     ← ממשיכים
שלב 4: [v1] [v2] [v2] [v2]     
שלב 5: [v2] [v2] [v2] [v2]     ← הושלם!
```

**יתרונות:** Zero downtime, Rollback קל (`kubectl rollout undo`)
**חסרונות:** שתי גרסאות רצות במקביל (צריך backward compatibility)
**מתי:** **ברירת מחדל.** רוב הפריסות.

**הגדרה ב-YAML:**
```yaml
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1        # כמה להוסיף מעל הרצוי
    maxUnavailable: 0  # כמה יכולים להיות למטה
```

---

**2. Recreate**

**מה קורה:** מורידים את כל הישנים, מעלים את כל החדשים.

```
שלב 1: [v1] [v1] [v1] [v1]     ← כולם רצים
שלב 2: [  ] [  ] [  ] [  ]     ← מורידים הכל (DOWNTIME!)
שלב 3: [v2] [v2] [v2] [v2]     ← מעלים חדשים
```

**יתרונות:** פשוט, אין שתי גרסאות במקביל
**חסרונות:** יש Downtime!
**מתי:** 
- כשאי אפשר להריץ שתי גרסאות (שינוי schema ב-DB)
- Development environments

**הגדרה ב-YAML:**
```yaml
strategy:
  type: Recreate
```

---

**3. Blue-Green**

**מה קורה:** מעלים סביבה חדשה שלמה (Green), בודקים שהיא עובדת, ואז מעבירים את התעבורה.

```
Blue (v1):  [v1] [v1] [v1] [v1]  ← Live traffic
Green (v2): [v2] [v2] [v2] [v2]  ← מוכן, בבדיקות

*Switch!* (משנים DNS/LB)

Blue (v1):  [v1] [v1] [v1] [v1]  ← Standby (rollback)
Green (v2): [v2] [v2] [v2] [v2]  ← Live traffic
```

**יתרונות:** Zero downtime, Rollback מיידי (פשוט מחזירים traffic)
**חסרונות:** דורש כפול משאבים!
**מתי:**
- כשחייבים Rollback מיידי
- שינויים קריטיים (אפשר לבדוק לפני Switch)

**איך מממשים:** לא מובנה ב-K8s. משתמשים ב:
- שני Deployments + Service selector
- Argo Rollouts
- Istio

---

**4. Canary**

**מה קורה:** שולחים אחוז קטן מהתעבורה לגרסה החדשה. אם הכל בסדר - מגדילים בהדרגה.

```
שלב 1: 5% ל-v2
[v1] [v1] [v1] [v1] [v1] [v1] [v1] [v1] [v1] [v2]
                                              ↑
                                           5% traffic

שלב 2: אם OK → 25% ל-v2
[v1] [v1] [v1] [v1] [v1] [v1] [v1] [v2] [v2] [v2]

שלב 3: אם OK → 100% ל-v2
[v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2]
```

**יתרונות:** בדיקה אמיתית ב-Production, סיכון מינימלי
**חסרונות:** מורכב לממש, דורש monitoring טוב
**מתי:**
- Features חדשים עם סיכון
- שינויים משמעותיים

**איך מממשים:**
- Istio (traffic splitting)
- Argo Rollouts
- Flagger

---

**סיכום:**

| אסטרטגיה | Downtime | Rollback | משאבים | שימוש |
|----------|----------|----------|--------|-------|
| Rolling | ❌ אין | מהיר | רגיל | ברירת מחדל |
| Recreate | ✅ יש | מהיר | רגיל | DB migrations |
| Blue-Green | ❌ אין | מיידי | כפול | Critical apps |
| Canary | ❌ אין | מהיר | +10-20% | High risk changes |

---

### ❓ "מהו Istio?"

**תשובה לראיון:**

"Istio זה Service Mesh - שכבה שמנהלת את התקשורת בין Microservices. במקום שכל שירות יטפל בעצמו ב-retry, timeout, encryption - Istio עושה את זה בשבילו."

**איך עובד:** מוסיף Sidecar container (Envoy proxy) לכל Pod. כל התקשורת עוברת דרכו.

**3 יכולות מרכזיות:**
| יכולת | מה עושה |
|-------|---------|
| **Traffic Management** | Load balancing, A/B testing, Canary releases, Retries |
| **Security** | mTLS אוטומטי בין services, Authorization policies |
| **Observability** | Metrics, Distributed tracing, Logging |

**מתי צריך:**
- הרבה Microservices
- רוצים mTLS בין הכל
- צריכים traffic splitting (Canary)

---

## פרק 18: Helm

### ❓ "מה זה Helm?"

**Helm** = Package manager לקוברנטיס.
- **Charts** - חבילות מוכנות
- **Templating** - YAMLים דינמיים
- **Values** - קובץ הגדרות
- **Releases** - ניהול גרסאות

### ❓ "מה זה Helm Lint?"

`helm lint` = בודק תקינות Chart לפני התקנה.

### ❓ "מה זה _helpers.tpl?"

קובץ עם פונקציות לשימוש חוזר בתוך Chart.

---

## פרק 19: CI/CD

### ❓ "מה זה CI ו-CD?"

| מונח | משמעות | מה כולל |
|------|--------|---------|
| **CI** | Continuous Integration | Build, Test, Lint |
| **CD** | Continuous Delivery | פריסה אוטומטית |

### ❓ "GitHub Actions vs Jenkins?"

| מאפיין | GitHub Actions | Jenkins |
|--------|----------------|---------|
| התקנה | מובנה (SaaS) | Self-hosted |
| תחזוקה | GitHub | אתה |
| גמישות | טובה | מקסימלית |

### ❓ "מה זה Artifact?"

**Artifact** = תוצר Build: Docker Image, JAR, Binary

### ❓ "Test vs Stage vs Prod?"

| סביבה | מטרה |
|-------|------|
| **Dev/Test** | בדיקות מפתחים |
| **Staging** | Pre-production |
| **Production** | משתמשים אמיתיים |

---

## פרק 20: Terraform

### ❓ "מהו Drift?"

**Drift** = פער בין State למצב האמיתי. קורה כששינו ידנית.

### ❓ "עריכת שם Bucket - מה יקרה?"

**ימחק את הישן ויצור חדש!** (immutable)

### ❓ "מה זה Terraform Validate?"

בודק תקינות קבצי .tf (לא מול הענן).

### ❓ "איפה לשמור State?"

**Remote Backend** - S3 + DynamoDB locking. לא ב-Git!

### ❓ "מה זה Workspace?"

State נפרד לאותו קוד (dev, staging, prod).

### ❓ "מהו Module?"

קבוצת Resources לשימוש חוזר (כמו פונקציה).

### ❓ "CloudFormation vs Terraform?"

| מאפיין | CloudFormation | Terraform |
|--------|----------------|-----------|
| ספק | AWS בלבד | Multi-cloud |
| שפה | JSON/YAML | HCL |
| State | AWS מנהל | אתה מנהל |

---

## פרק 21: Architecture

### ❓ "Microservices vs Monolith?"

| Monolith | Microservices |
|----------|---------------|
| אפליקציה אחת | שירותים קטנים |
| פשוט להתחיל | קשה לנהל |
| קשה לסקייל חלקים | כל שירות נפרד |

### ❓ "מה זה Decoupled Services?"

שירותים לא תלויים ישירות - תקשורת דרך Queue/Events.

### ❓ "מתי EC2 ומתי Kubernetes?"

| EC2 | Kubernetes |
|-----|------------|
| אפליקציה פשוטה | Microservices |
| צוות קטן | צוות עם ידע K8s |
| Stateful legacy | Cloud Native |

---

## פרק 22: Monitoring

### ❓ "מה זה Prometheus?"

מערכת Monitoring - Pull-based, Time-series, PromQL.

### ❓ "מה זה Grafana?"

כלי Visualization - Dashboards, Alerts.

### ❓ "מהו NGINX?"

Web server / Reverse Proxy / Load Balancer / Ingress Controller.

---

## פרק 23: API & HTTP

### ❓ "קודים 2xx, 3xx, 4xx, 5xx?"

| סדרה | משמעות |
|------|--------|
| **2xx** | הצלחה |
| **3xx** | Redirect |
| **4xx** | שגיאת Client |
| **5xx** | שגיאת Server |

### ❓ "4 סוגי קריאות API?"

GET (Read), POST (Create), PUT (Update), DELETE (Delete)

### ❓ "REST vs SOAP?"

| REST | SOAP |
|------|------|
| JSON | XML |
| קל | כבד |
| Modern | Enterprise |

---

## פרק 24: תרחישים

### תרחיש: הקמת אתר E-Commerce

**שאלות לשאול:**
1. גאוגרפיה - ישראל או גלובלי?
2. עדכניות מוצרים - לעיתים רחוקות? Redis
3. כמות כניסות - Scaling planning

### תרחיש: קמפיין חגים (10K → 40K)

1. Auto Scaling לפי CPU
2. Read Replicas
3. Redis Caching
4. Pre-warming

### תרחיש: שדרוג K8s Cluster

1. Control Plane קודם
2. בדיקת תקינות
3. Worker Nodes אחד-אחד

### תרחיש: Pods ב-Error

1. `kubectl describe pod`
2. `kubectl logs`
3. בדיקת: Image, Permissions, Resources

### תרחיש: Traffic מ-ALB לK8s

- ALB: Public Subnet, SG 80/443
- K8s: SG Referencing, Ingress

### תרחיש: K8s בלי אינטרנט

- Private Registry (ECR + Endpoint)
- Golden AMI
- Private Link

---

## פרק 25: Docker מתקדם

### ❓ "מה זה Multi-Stage Build?"

**תשובה לראיון:**

"Multi-Stage Build זה טכניקה לבניית Docker Images בכמה שלבים, כאשר כל שלב יכול להשתמש ב-Base Image שונה. הרעיון המרכזי הוא להפריד בין **שלב הבנייה (Build)** לבין **שלב ההרצה (Runtime)**, ובסוף לקחת רק את מה שצריך לImage הסופי."

**למה בכלל צריך את זה? בוא נבין את הבעיה:**

כשאני בונה אפליקציית Node.js לדוגמה, בשלב הפיתוח אני צריך:
- Node.js עצמו (כ-900MB)
- npm לניהול packages
- כל ה-devDependencies (webpack, typescript, babel...)
- קבצי source code

אבל ב-**Production** - כשהאפליקציה רצה - אני צריך רק:
- שרת web קטן (nginx - 20MB)
- הקבצים שנבנו (HTML, CSS, JS מקומפל)

**זו בדיוק הבעיה:** אם אני שם הכל ב-Image אחד, אני גורר 900MB של כלים שאני לא צריך בהרצה!

**איך Multi-Stage פותר את זה:**

```dockerfile
# ═══════════════════════════════════════════════════════
# STAGE 1: BUILD (שלב הבנייה)
# ═══════════════════════════════════════════════════════
# כאן אני משתמש ב-Image גדול עם כל הכלים
FROM node:18 AS builder

WORKDIR /app

# מעתיק את קבצי התלויות ומתקין
COPY package*.json ./
RUN npm install          # כולל devDependencies!

# מעתיק את כל הקוד ובונה
COPY . .
RUN npm run build        # יוצר תיקיית dist/

# בשלב הזה יש לי:
# - node_modules (מאות MB)
# - קבצי source
# - קבצי build (dist/)
# - כל כלי הפיתוח


# ═══════════════════════════════════════════════════════
# STAGE 2: RUNTIME (שלב ההרצה) - זה ה-Image הסופי!
# ═══════════════════════════════════════════════════════
# מתחיל מ-Image חדש ונקי!
FROM nginx:alpine

# מעתיק רק את התוצר מה-Stage הקודם
COPY --from=builder /app/dist /usr/share/nginx/html

# זהו! ה-Image הסופי מכיל רק:
# - nginx (~20MB)
# - הקבצים שנבנו (כמה MB)
# סה"כ: ~25MB במקום ~900MB!
```

**מה קורה כאן בפועל:**

```
┌─────────────────────────────────────────────────────────────────┐
│                    MULTI-STAGE BUILD                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  STAGE 1 - BUILD:                                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  FROM node:18                        (900MB base)       │   │
│  │  ├── npm install                     (+300MB deps)      │   │
│  │  ├── npm run build                   (creates dist/)    │   │
│  │  │                                                      │   │
│  │  │  מה יש כאן:                                          │   │
│  │  │  ✓ Node.js runtime                                   │   │
│  │  │  ✓ npm                                               │   │
│  │  │  ✓ node_modules/                                     │   │
│  │  │  ✓ webpack, babel, typescript...                     │   │
│  │  │  ✓ source code                                       │   │
│  │  │  ✓ dist/ (התוצר הסופי)                               │   │
│  │  │                                                      │   │
│  │  │  גודל: ~1.2GB                                        │   │
│  │  └──────────────────────────────────────────────────────┘   │
│                         │                                       │
│                         │ COPY --from=builder                   │
│                         │ (מעתיק רק את dist/)                   │
│                         ▼                                       │
│  STAGE 2 - RUNTIME:                                             │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  FROM nginx:alpine                   (20MB base)        │   │
│  │  └── dist/                           (+5MB files)       │   │
│  │                                                         │   │
│  │  מה יש כאן:                                             │   │
│  │  ✓ nginx web server                                     │   │
│  │  ✓ HTML/CSS/JS הסופיים                                  │   │
│  │  ✗ אין Node.js                                          │   │
│  │  ✗ אין npm                                              │   │
│  │  ✗ אין node_modules                                     │   │
│  │  ✗ אין כלי build                                        │   │
│  │                                                         │   │
│  │  גודל: ~25MB                                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  חיסכון: 1.2GB → 25MB = חיסכון של 98%!                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**שלושת היתרונות המרכזיים:**

| יתרון | הסבר מפורט |
|-------|------------|
| **Image קטן** | פחות מקום באחסון, פחות זמן להעברה ברשת, פחות זמן ל-Pull. במקום 1GB, יש לך 25MB. |
| **אבטחה** | ככל שיש פחות כלים ב-Image, יש פחות "משטח תקיפה". אם אין npm בProduction - אי אפשר לנצל פגיעויות שלו. |
| **הפרדה נקייה** | מה שצריך לבנות (compilers, bundlers) נפרד ממה שצריך להריץ (web server). כל אחד עושה את התפקיד שלו. |

**מתי להשתמש:**
- אפליקציות שצריכות compilation (Go, Java, TypeScript, React)
- כשרוצים Image קטן ל-Production
- כשיש הרבה devDependencies שלא צריך בהרצה

---

### ❓ "מה זה Volumes ו-Bind Mounts?"

**תשובה לראיון:**

"שניהם דרכים לשמור נתונים מחוץ ל-Container, אבל יש הבדל חשוב במי מנהל אותם ומתי להשתמש בכל אחד."

**הבעיה:** Container הוא Ephemeral (זמני) - כשהוא נמחק, כל הנתונים שבתוכו נמחקים. 
אם יש לי Database ב-Container ואני עושה לו restart - איבדתי את כל המידע!

**הפתרון - 3 סוגי אחסון:**

| סוג | מי מנהל | איפה נשמר | מתי להשתמש |
|-----|---------|-----------|------------|
| **Volume** | Docker מנהל | `/var/lib/docker/volumes/` | Production - Database, persistent data |
| **Bind Mount** | אתה מנהל | תיקייה שאתה בוחר | Development - קוד שמשתנה תדיר |
| **tmpfs** | זיכרון RAM | לא נשמר לדיסק! | Sensitive data, cache זמני |

**Volume - מתי ולמה:**
```bash
# Docker יוצר ומנהל את התיקייה
docker run -v mydata:/var/lib/mysql mysql

# היתרונות:
# ✓ Docker מנהל permissions
# ✓ עובד אותו דבר על כל OS
# ✓ קל לגבות (docker volume backup)
# ✓ אפשר לשתף בין containers
```

**Bind Mount - מתי ולמה:**
```bash
# אתה מצביע לתיקייה קיימת שלך
docker run -v /home/dev/mycode:/app node

# היתרונות:
# ✓ משנה קוד → רואה שינויים מיד ב-Container
# ✓ שליטה מלאה על המיקום
# ✓ מעולה לפיתוח (hot reload)
```

**tmpfs - מתי ולמה:**
```bash
# נשמר רק בזיכרון
docker run --tmpfs /tmp myapp

# שימושים:
# ✓ Secrets שלא רוצים על דיסק
# ✓ Session data
# ✓ Cache זמני
```

---

### ❓ "מה זה Docker Compose?"

**תשובה לראיון:**

"Docker Compose זה כלי שמאפשר להגדיר ולהריץ מספר Containers יחד כ-Application אחד. במקום להריץ 5 פקודות `docker run` ארוכות, אני כותב קובץ YAML אחד שמתאר את כל ה-Services, ומריץ פקודה אחת."

**למה צריך את זה?**

בלי Compose - נגיד יש לי אפליקציה עם Web + DB + Redis:
```bash
# צריך להריץ 3 פקודות ארוכות
docker network create mynet
docker run -d --name db --network mynet -e POSTGRES_PASSWORD=secret postgres
docker run -d --name redis --network mynet redis
docker run -d --name web --network mynet -p 5000:5000 -e DB_HOST=db myapp
```

**עם Compose - קובץ אחד:**
```yaml
# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    environment:
      - DB_HOST=db
      - REDIS_HOST=redis
    depends_on:
      - db
      - redis
  
  db:
    image: postgres:15
    environment:
      - POSTGRES_PASSWORD=secret
    volumes:
      - db-data:/var/lib/postgresql/data
  
  redis:
    image: redis:7-alpine

volumes:
  db-data:
```

**פקודה אחת:**
```bash
docker-compose up -d      # מעלה הכל
docker-compose down       # מוריד הכל
docker-compose logs web   # לוגים של service ספציפי
```

**מה Compose עושה בשבילך:**
- יוצר Network משותף אוטומטית
- מנהל סדר העלייה (depends_on)
- שמות DNS פנימיים (web יכול לפנות ל-db בשם)
- ניהול Volumes

### ❓ "מה זה Docker Networking?"

**תשובה לראיון:**

"Docker יוצר רשתות וירטואליות שמאפשרות ל-Containers לתקשר ביניהם. יש כמה סוגי רשתות, כל אחת למטרה שונה."

**4 סוגי רשתות:**

| Type | איך עובד | מתי להשתמש |
|------|----------|------------|
| **bridge** | רשת פרטית מבודדת. Containers מקבלים IP פנימי ויכולים לדבר ביניהם. | **ברירת מחדל.** כשרוצים בידוד בין Containers על אותו Host |
| **host** | Container משתמש ישירות ברשת של המכונה. אין בידוד! | ביצועים מקסימליים, כשהבידוד לא חשוב |
| **none** | אין רשת בכלל. Container מבודד לגמרי | אבטחה, עיבוד offline |
| **overlay** | רשת שמתפרסת על פני כמה Hosts | Docker Swarm, Kubernetes |

**דוגמה - למה bridge חשוב:**
```bash
# יוצר רשת
docker network create my-app-network

# Container A
docker run -d --name web --network my-app-network nginx

# Container B - יכול לפנות ל-"web" בשם!
docker run -d --name app --network my-app-network myapp
# בתוך app: curl http://web:80 ← עובד!
```

**בלי הגדרת רשת משותפת:**
Containers על רשת bridge ברירת מחדל לא יכולים לפנות אחד לשני בשם - רק ב-IP (שמשתנה!).

---

### ❓ "מה זה Container Restart Policies?"

**תשובה לראיון:**

"Restart Policy קובע מה Docker עושה כש-Container נעצר או קורס. זה חשוב ל-Production כי אנחנו רוצים שServices יעלו אוטומטית אחרי תקלה."

**4 אפשרויות:**

| Policy | מה קורה | מתי להשתמש |
|--------|---------|------------|
| `no` | לא מפעיל מחדש אף פעם | ברירת מחדל. Debug, one-time jobs |
| `always` | תמיד מפעיל מחדש, גם אחרי reboot של המכונה | Production services קריטיים |
| `on-failure` | מפעיל מחדש רק אם יצא עם error (exit code ≠ 0) | Services שצריכים לרוץ, אבל אם נעצרו בכוונה - נשארים למטה |
| `unless-stopped` | כמו always, אבל אם עצרת ידנית - לא עולה | הכי נפוץ ל-Production |

**דוגמה:**
```bash
# Production - תמיד עולה חזרה
docker run -d --restart unless-stopped --name web nginx

# מה קורה:
# Container קרס → Docker מעלה אותו מחדש ✓
# docker stop web → נשאר למטה ✓
# Server reboot → לא עולה (כי עצרת ידנית) ✓
```

**ב-Docker Compose:**
```yaml
services:
  web:
    image: nginx
    restart: unless-stopped
```

---

## פרק 26: Kubernetes Scheduling

### ❓ "Labels ו-Selectors?"

**Labels** = תגיות key-value על Resources.
**Selectors** = בחירת Resources לפי Labels.

### ❓ "Taints ו-Tolerations?"

**Taint** = "רעל" על Node - דוחה Pods.
**Toleration** = "חיסון" ל-Pod - מאפשר לו לרוץ.

*משל: שלט "כניסה אסורה" (Taint), אישור מיוחד (Toleration)*

### ❓ "Node Selector vs Node Affinity?"

| מושג | תיאור | גמישות |
|------|-------|--------|
| **Node Selector** | label פשוט | equality בלבד |
| **Node Affinity** | תנאים מורכבים | In, NotIn, Gt, Lt |

### ❓ "Pod Affinity vs Anti-Affinity?"

**Affinity** = "רוצה ליד Pod מסוים" (Web + Cache)
**Anti-Affinity** = "רוצה רחוק מ-Pod" (DB replicas - HA)

---

## פרק 27: Kubernetes Configuration

### ❓ "מה זה ConfigMap?"

אחסון configuration לא-רגיש: env vars, files.

### ❓ "מה זה Secret?"

אחסון רגיש (base64): passwords, API keys, certs.
⚠️ base64 ≠ הצפנה! להשתמש עם Vault.

### ❓ "Rolling Update ו-Rollback?"

**Rolling Update** = עדכון הדרגתי ללא downtime.
**Rollback** = חזרה לגרסה קודמת.

```bash
kubectl rollout undo deployment/myapp
kubectl rollout undo deployment/myapp --to-revision=2
```

---

## פרק 28: K8s Networking

### ❓ "מה זה CNI?"

**CNI** = Container Network Interface. Plugins: Calico, Flannel, Weave, AWS VPC CNI.

### ❓ "מה זה CoreDNS?"

DNS פנימי של הקלאסטר. מתרגם: `my-service.namespace.svc.cluster.local`

### ❓ "מה זה Network Policy?"

Firewall ברמת Pod. קובע איזה Traffic מותר Ingress/Egress.

---

## פרק 29: Jenkins

### ❓ "Freestyle vs Pipeline?"

| מאפיין | Freestyle | Pipeline |
|--------|-----------|----------|
| הגדרה | GUI | קוד (Jenkinsfile) |
| Git | ❌ | ✅ |
| שימוש | פשוט | CI/CD מלא |

### ❓ "Jenkins Agents/Slaves?"

**Master** = מנהל, מתזמן
**Agent** = מבצע העבודה

### ❓ "הרצה ידנית בין שלבים?"

כן! עם `input` step:
```groovy
input message: 'Deploy?', ok: 'Deploy!'
```

### ❓ "Jenkins Parameters?"

משתנים שהמשתמש מזין: string, choice, boolean.

---

## פרק 30: Security & Best Practices

### ❓ "מה זה SG Referencing?"

התייחסות ל-Security Group במקום CIDR.
**יתרון:** יותר מאובטח, יותר דינמי.

### ❓ "OIDC בין GitHub ל-AWS?"

אימות בלי Access Keys!
1. Identity Provider ב-AWS
2. IAM Role עם Trust Policy
3. `aws-actions/configure-aws-credentials`

### ❓ "GitHub vs GitLab?"

| מאפיין | GitHub | GitLab |
|--------|--------|--------|
| CI/CD | Actions | מובנה יותר |
| Self-hosted | יקר | Community חינם |

### ❓ "Vertical vs Horizontal Scaling?"

**"מה ההבדל בין Vertical ל-Horizontal Scaling?"**

יש לך אפליקציה שלא עומדת בעומס. מה עושים?

**Vertical Scaling (Scale Up):**
```
לפני:  [Server: 2 CPU, 4GB RAM]
         ↓ משדרגים
אחרי:  [Server: 8 CPU, 32GB RAM]
```
לוקחים את אותו server ונותנים לו **יותר כוח**.

**Horizontal Scaling (Scale Out):**
```
לפני:  [Server]

אחרי:  [Server] [Server] [Server] [Server]
              ↑
         Load Balancer מפזר traffic
```
מוסיפים **עוד servers** מאותו סוג.

| שאלה | Vertical | Horizontal |
|------|----------|------------|
| **מה משנים?** | גודל המכונה | כמות המכונות |
| **יש גבול?** | כן! | כמעט אין |
| **Downtime?** | בדרך כלל כן | לא |
| **מורכבות** | פשוט | צריך LB |

**מתי מה:**
- **Database** → Vertical (קשה לפזר data)
- **Web/API** → Horizontal (כל server עצמאי)

---

---

# 📚 מילון מושגים מפורט - A-Z

> **חיפוש מהיר:** Ctrl+F ← הקלד את המושג

---

## ☁️ AWS - Amazon Web Services

---

### ACM (AWS Certificate Manager)

**מה זה:** שירות לניהול תעודות SSL/TLS.

**עלות:** חינם לשירותי AWS!

**מאפיינים:**
- חידוש אוטומטי
- תומך wildcard certificates
- אינטגרציה עם ALB, CloudFront, API Gateway

**⚠️ מגבלה:** לא עובד ישירות עם EC2 - צריך לשים מאחורי ALB.

**פקודה:**
```bash
aws acm request-certificate --domain-name example.com
```

---

### ALB (Application Load Balancer)

**מה זה:** Load Balancer ברמת Layer 7 (HTTP/HTTPS).

**יכולות:**
- Path-based routing (`/api` → service A, `/web` → service B)
- Host-based routing (`api.example.com` → service A)
- WebSocket support
- HTTP/2 support
- Integration עם WAF

**מתי להשתמש:**
- Web applications
- Microservices
- Container-based apps

**לעומת NLB:**
| ALB | NLB |
|-----|-----|
| Layer 7 | Layer 4 |
| HTTP/HTTPS | TCP/UDP |
| Path routing | Port routing |
| איטי יותר | מהיר מאוד |

---

### Auto Scaling Group (ASG)

**מה זה:** קבוצת EC2 instances שגדלה וקטנה אוטומטית.

**הגדרות:**
- **Minimum:** מינימום instances (לא יורד מזה)
- **Maximum:** מקסימום instances (לא עולה מזה)
- **Desired:** כמות רצויה נוכחית

**Scaling Policies:**
| סוג | איך עובד |
|-----|----------|
| Target Tracking | "שמור על 70% CPU" |
| Step Scaling | "אם CPU > 80% הוסף 2" |
| Scheduled | "בשעה 9 בבוקר הוסף 5" |

**דוגמה:**
```
Min: 2, Max: 10, Desired: 4
CPU > 70% → Desired: 6
CPU < 30% → Desired: 3
```

---

### CloudFront

**מה זה:** CDN (Content Delivery Network) של AWS.

**איך עובד:**
1. משתמש מבקש קובץ
2. CloudFront בודק אם יש ב-Edge Location הקרוב
3. אם יש (Cache Hit) → מחזיר מיד
4. אם אין (Cache Miss) → מביא מה-Origin, שומר, מחזיר

**יתרונות:**
- Latency נמוך (200+ Edge Locations)
- DDoS protection מובנה
- SSL/TLS חינם
- עובד עם S3, ALB, EC2, או כל HTTP server

**TTL (Time To Live):**
- קובע כמה זמן לשמור ב-cache
- ברירת מחדל: 24 שעות

---

### CloudWatch

**מה זה:** שירות Monitoring וLogging של AWS.

**רכיבים:**

| רכיב | תפקיד |
|------|-------|
| **Metrics** | מדדים (CPU, Memory, Custom) |
| **Logs** | לוגים מכל שירות |
| **Alarms** | התראות על סף מסוים |
| **Dashboards** | גרפים ויזואליים |
| **Events/EventBridge** | תגובה לאירועים |

**Metrics חשובים ל-EC2:**
- CPUUtilization
- NetworkIn/Out
- DiskReadOps/WriteOps
- StatusCheckFailed

---

### CloudTrail

**מה זה:** מתעד כל פעולת API ב-AWS account.

**שימושים:**
- Security audit
- Compliance
- Troubleshooting

**מה נרשם:**
- מי עשה (User/Role)
- מה עשה (API call)
- מתי (Timestamp)
- מאיפה (IP address)

---

### Decoupled Services

**מה זה:** ארכיטקטורה שבה שירותים לא תלויים ישירות אחד בשני.

**Tightly Coupled (רע):**
```
Service A → Service B (ישיר)
אם B נופל, A נופל
```

**Decoupled (טוב):**
```
Service A → SQS Queue → Service B
אם B נופל, ההודעות ממתינות בQueue
```

**יתרונות:**
- Fault tolerance
- Independent scaling
- Async processing
- Easier maintenance

**שירותי AWS ל-Decoupling:**
- SQS (Simple Queue Service)
- SNS (Simple Notification Service)
- EventBridge

---

### EBS (Elastic Block Store)

**מה זה:** דיסק וירטואלי ל-EC2.

**סוגים:**

| סוג | IOPS | שימוש |
|-----|------|-------|
| gp3 | עד 16,000 | General purpose (הכי נפוץ) |
| io2 | עד 64,000 | High performance DB |
| st1 | עד 500 | Big data, throughput |
| sc1 | עד 250 | Cold data, archive |

**מאפיינים:**
- מחובר ל-EC2 אחד בלבד
- באותו AZ בלבד!
- Snapshots לגיבוי (נשמרים ב-S3)

---

### EFS (Elastic File System)

**מה זה:** NFS מנוהל - file system משותף.

**הבדל מ-EBS:**

| מאפיין | EBS | EFS |
|--------|-----|-----|
| חיבור | EC2 אחד | מרובה EC2 |
| AZ | אחד | Cross-AZ |
| Scaling | ידני | אוטומטי |
| פרוטוקול | Block | NFS |
| מחיר | זול יותר | יקר יותר |

**שימושים:**
- Shared application files
- CMS content
- Development environments

---

### IAM (Identity and Access Management)

**מה זה:** ניהול זהויות והרשאות ב-AWS.

**רכיבים:**

| רכיב | מה זה | דוגמה |
|------|-------|-------|
| **User** | זהות לאדם | john@company.com |
| **Group** | קבוצת Users | "Developers" |
| **Role** | זהות לשירות | EC2 שניגש ל-S3 |
| **Policy** | מסמך הרשאות | מה מותר/אסור |

**IAM User vs IAM Role:**

| מאפיין | User | Role |
|--------|------|------|
| מיועד ל | אנשים | שירותים |
| אימות | Password/Keys | Assume Role |
| תוקף | קבוע | זמני |
| Best Practice | לאנשים | לאוטומציה |

**IAM Policy vs Resource Policy:**

| מאפיין | IAM Policy | Resource Policy |
|--------|------------|-----------------|
| מוצמד ל | User/Group/Role | המשאב עצמו |
| שואל | "מה User יכול?" | "מי יכול לגשת?" |
| Cross-Account | דורש Assume | ישיר |

---

### Internet Gateway (IGW)

**מה זה:** שער שמחבר VPC לאינטרנט.

**מאפיינים:**
- Horizontally scaled, redundant, HA
- AWS מנהל - אין לך מה לדאוג
- חינמי (משלמים Data Transfer)
- אחד ל-VPC

**חובה בשביל:**
- EC2 עם Public IP יוכל לצאת לאינטרנט
- תנועה נכנסת מהאינטרנט

---

### Lambda

**מה זה:** Serverless compute - מריץ קוד בלי שרתים.

**מאפיינים:**
- Event-driven
- Pay per millisecond
- Auto-scale (עד אלפי executions במקביל)
- תומך: Python, Node.js, Java, Go, .NET

**מגבלות:**
| מגבלה | ערך |
|-------|-----|
| Timeout | 15 דקות |
| Memory | 128MB - 10GB |
| Package size | 250MB |
| /tmp storage | 512MB (או 10GB עם EFS) |

**Triggers נפוצים:**
- API Gateway
- S3 events
- EventBridge (cron)
- SQS
- DynamoDB Streams

**מתזמן:** EventBridge
```
cron(0 2 * * ? *)  # כל יום ב-2 בלילה
rate(5 minutes)    # כל 5 דקות
```

---

### NAT Gateway

**מה זה:** מאפשר ל-Private Subnet לצאת לאינטרנט.

**איך עובד:**
```
Private EC2 → NAT Gateway (Public Subnet) → IGW → Internet
```

**מאפיינים:**
- יציאה בלבד! אי אפשר להיכנס דרכו
- יושב ב-Public Subnet
- עלות: ~$0.045/שעה + Data processing
- HA באותו AZ (צריך NAT לכל AZ ל-HA מלא)

**שימושים:**
- EC2 ב-Private Subnet צריך לעדכן packages
- Lambda ב-VPC צריך גישה לאינטרנט
- ECS tasks צריכים למשוך images

---

### Private Link / VPC Endpoint

**מה זה:** גישה לשירותי AWS בלי אינטרנט.

**שני סוגים:**

| סוג | מה זה | עלות | שירותים |
|-----|-------|------|---------|
| **Interface** | ENI בתוך VPC | בתשלום | רוב השירותים |
| **Gateway** | Route Table | חינם! | S3, DynamoDB בלבד |

**יתרונות:**
- אבטחה: Traffic לא יוצא מ-AWS
- ביצועים: Latency נמוך
- עלות: חוסך NAT Gateway

**דוגמה - ECR בלי אינטרנט:**
```
צריך 3 Interface Endpoints:
- com.amazonaws.region.ecr.api
- com.amazonaws.region.ecr.dkr
- com.amazonaws.region.s3 (Gateway - חינם)
```

---

### RDS (Relational Database Service)

**מה זה:** בסיס נתונים מנוהל.

**מנועים נתמכים:**
MySQL, PostgreSQL, MariaDB, Oracle, SQL Server, Aurora

**Multi-AZ:**
- Standby ב-AZ אחר
- Failover אוטומטי (1-2 דקות)
- Standby לא נגיש לקריאה!

**Read Replica:**
- עותק לקריאה
- נגיש לקריאה
- Async replication

| מאפיין | Multi-AZ | Read Replica |
|--------|----------|--------------|
| מטרה | HA | ביצועים |
| נגיש? | לא | כן |
| Sync | Synchronous | Async |
| Failover | אוטומטי | ידני |

---

### Route 53

**מה זה:** שירות DNS של AWS.

**סוגי ניתוב:**

| סוג | לוגיקה | שימוש | דוגמה |
|-----|--------|-------|-------|
| **Simple** | IP אחד | Basic | אתר פשוט |
| **Weighted** | לפי אחוזים | A/B Testing | 90% v1, 10% v2 |
| **Latency** | לפי מהירות | Global users | Region הכי מהיר |
| **Geolocation** | לפי מיקום | Compliance | ישראל → il-central |
| **Failover** | Primary/Secondary | DR | אם Primary נופל |
| **Multivalue** | כמה IPs | Simple LB | 8 IPs רנדומלי |

---

### S3 (Simple Storage Service)

**מה זה:** Object Storage ללא הגבלה.

**מאפיינים:**
- Objects (לא קבצים רגילים)
- 99.999999999% Durability (11 תשיעיות)
- Max object size: 5TB
- Versioning
- Encryption (SSE-S3, SSE-KMS, SSE-C)

**Storage Classes:**

| Class | זמינות | Min Duration | שימוש |
|-------|--------|--------------|-------|
| Standard | מיידי | אין | גישה תכופה |
| Standard-IA | מיידי | 30 יום | גישה לא תכופה |
| One Zone-IA | מיידי | 30 יום | פחות קריטי |
| Glacier Instant | מיידי | 90 יום | ארכיון + גישה מהירה |
| Glacier Flexible | דקות-שעות | 90 יום | ארכיון |
| Glacier Deep | 12-48 שעות | 180 יום | ארכיון ארוך |

---

### Security Group (SG)

**מה זה:** Firewall וירטואלי ברמת Instance.

**מאפיינים:**
- **Stateful:** אם נכנס, יוצא אוטומטית
- Default: All inbound denied, All outbound allowed
- רק Allow rules (אין Deny)

**SG Referencing:**
במקום CIDR, אפשר להתייחס ל-SG אחר:
```
Inbound: Allow from sg-alb-12345 (רק ALB יכול)
```
**יותר מאובטח מ:** `Allow 10.0.0.0/16`

---

### Subnet

**מה זה:** חלוקה של VPC.

**Public vs Private:**

| מאפיין | Public | Private |
|--------|--------|---------|
| Route לאינטרנט | IGW ישיר | דרך NAT |
| Public IP | כן | לא |
| מה שמים | ALB, Bastion, NAT | DB, App servers |

**CIDR דוגמה:**
```
VPC: 10.0.0.0/16 (65,536 IPs)
├── Public: 10.0.1.0/24 (256 IPs)
├── Public: 10.0.2.0/24 (256 IPs)
├── Private: 10.0.10.0/24 (256 IPs)
└── Private: 10.0.11.0/24 (256 IPs)
```

---

### VPC (Virtual Private Cloud)

**מה זה:** רשת וירטואלית פרטית שלך ב-AWS.

**רכיבים:**
- **CIDR Block:** טווח IPs
- **Subnets:** חלוקות
- **Route Tables:** לאן לשלוח traffic
- **IGW:** גישה לאינטרנט
- **NAT:** יציאה לאינטרנט מ-Private
- **Security Groups:** Firewall

---

## ☸️ Kubernetes - מושגים מפורטים

---

### ConfigMap

**מה זה:** אחסון configuration לא-רגיש.

**שימושים:**
- Environment variables
- Configuration files
- Command-line arguments

**יצירה:**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  DATABASE_HOST: "db.example.com"
  LOG_LEVEL: "debug"
  config.json: |
    {"feature_flag": true}
```

**שימוש ב-Pod:**
```yaml
env:
  - name: DATABASE_HOST
    valueFrom:
      configMapKeyRef:
        name: app-config
        key: DATABASE_HOST
```

---

### DaemonSet

**מה זה:** מבטיח שPod אחד רץ על כל Node.

**שימושים:**
- Logging agents (Fluentd)
- Monitoring agents (Prometheus Node Exporter)
- Storage daemons
- Network plugins

**הבדל מ-Deployment:**
| Deployment | DaemonSet |
|------------|-----------|
| X replicas איפשהו | Pod אחד על כל Node |
| Scheduler מחליט | Node = Pod |

---

### Deployment Strategies - 4 אסטרטגיות פריסה

**1. Rolling Update (ברירת מחדל)**
```
[v1] [v1] [v1] [v1]
[v1] [v1] [v1] [v2]  ← מחליף אחד
[v1] [v1] [v2] [v2]  ← מחליף עוד אחד
[v1] [v2] [v2] [v2]
[v2] [v2] [v2] [v2]  ← הושלם
```
- ✅ Zero downtime
- ✅ Rollback קל
- ⚠️ שתי גרסאות במקביל

**2. Recreate**
```
[v1] [v1] [v1] [v1]
[  ] [  ] [  ] [  ]  ← מוחק הכל
[v2] [v2] [v2] [v2]  ← מעלה חדש
```
- ❌ יש Downtime!
- ✅ אין שתי גרסאות
- שימוש: כשאי אפשר 2 גרסאות (DB migrations)

**3. Blue-Green**
```
Blue (v1):  [v1] [v1] [v1] [v1]  ← Live
Green (v2): [v2] [v2] [v2] [v2]  ← Ready

Switch DNS/LB:
Blue (v1):  [v1] [v1] [v1] [v1]  ← Standby
Green (v2): [v2] [v2] [v2] [v2]  ← Live
```
- ✅ Zero downtime
- ✅ Instant rollback
- ❌ כפול משאבים

**4. Canary**
```
שלב 1: 5% traffic ל-v2
[v1] [v1] [v1] [v1] [v1] [v1] [v1] [v1] [v1] [v2]

שלב 2: 25% traffic ל-v2
[v1] [v1] [v1] [v1] [v1] [v1] [v1] [v2] [v2] [v2]

שלב 3: 100% traffic ל-v2
[v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2] [v2]
```
- ✅ בדיקה ב-Production
- ✅ Gradual rollout
- שימוש: Features חדשים, High risk changes

---

### HPA (Horizontal Pod Autoscaler)

**מה זה:** Auto-scaling של Pods לפי metrics.

**איך עובד:**
1. מודד CPU/Memory/Custom metrics
2. משווה ל-target (למשל 70%)
3. מחשב כמה Pods צריך
4. מוסיף/מוריד Pods

**הגדרה:**
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: my-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

---

### Ingress & Ingress Controller

**Ingress (Resource):**
מסמך YAML שמגדיר חוקי ניתוב.

**Ingress Controller (Software):**
התוכנה שקוראת את ה-Ingress ומבצעת בפועל.

**Controllers נפוצים:**
- NGINX Ingress Controller
- Traefik
- HAProxy
- AWS ALB Ingress Controller

**דוגמת Ingress:**
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
spec:
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /users
        pathType: Prefix
        backend:
          service:
            name: users-service
            port:
              number: 80
      - path: /orders
        pathType: Prefix
        backend:
          service:
            name: orders-service
            port:
              number: 80
```

---

### Namespace

**מה זה:** חלוקה לוגית של הקלאסטר.

**שימושים:**
- הפרדה בין סביבות: dev, staging, prod
- הפרדה בין צוותים
- Resource Quotas
- Network Policies

**Default Namespaces:**
| Namespace | תפקיד |
|-----------|--------|
| default | ברירת מחדל |
| kube-system | רכיבי K8s (CoreDNS, etc.) |
| kube-public | משאבים ציבוריים |

**פקודות:**
```bash
kubectl get namespaces
kubectl create namespace dev
kubectl get pods -n production
kubectl get pods --all-namespaces
```

---

### Node Affinity & Pod Affinity

**Node Selector (פשוט):**
```yaml
nodeSelector:
  disktype: ssd
```

**Node Affinity (מתקדם):**
```yaml
affinity:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
      - matchExpressions:
        - key: disktype
          operator: In
          values: [ssd, nvme]
```

**Pod Affinity:**
"רוץ על Node שיש עליו Pod עם label מסוים"
שימוש: Web server ליד Cache

**Pod Anti-Affinity:**
"רוץ על Node שאין עליו Pod עם label מסוים"
שימוש: DB replicas על Nodes שונים (HA)

---

### Probes - בדיקות בריאות

**3 סוגי Probes:**

| Probe | שואל | אם נכשל | מתי לבדוק |
|-------|------|---------|-----------|
| **Liveness** | "אתה חי?" | Restart | כל הזמן |
| **Readiness** | "אתה מוכן?" | לא שולחים traffic | כל הזמן |
| **Startup** | "עלית?" | ממתינים | רק בהתחלה |

**סוגי בדיקות:**
- **httpGet:** GET request ל-endpoint
- **tcpSocket:** בדיקת port פתוח
- **exec:** הרצת command

**דוגמה:**
```yaml
livenessProbe:
  httpGet:
    path: /healthcheck
    port: 8080
  initialDelaySeconds: 10
  periodSeconds: 30
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 10
```

---

### PVC (Persistent Volume Claim)

**מה זה:** בקשה לאחסון קבוע.

**3 רכיבים:**
| רכיב | מה זה | מי יוצר |
|------|-------|---------|
| **PV** | האחסון הפיזי | Admin / Dynamic |
| **PVC** | הבקשה | Developer |
| **StorageClass** | סוג האחסון | Admin |

**דוגמה:**
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: gp2
```

**Access Modes:**
- **ReadWriteOnce (RWO):** Node אחד
- **ReadOnlyMany (ROX):** הרבה Nodes קריאה
- **ReadWriteMany (RWX):** הרבה Nodes כתיבה

---

### Secret

**מה זה:** אחסון מידע רגיש.

**סוגים:**
- Opaque (ברירת מחדל)
- kubernetes.io/tls
- kubernetes.io/dockerconfigjson

**⚠️ חשוב:** base64 ≠ הצפנה!
לאבטחה אמיתית: External Secrets, Vault, Sealed Secrets

**יצירה:**
```bash
kubectl create secret generic db-secret \
  --from-literal=username=admin \
  --from-literal=password=secret123
```

---

### Service - סוגים בפירוט

**1. ClusterIP (ברירת מחדל)**
- נגיש רק מתוך הקלאסטר
- מקבל IP פנימי
- שימוש: שירותים פנימיים

```yaml
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 8080
```

**2. NodePort**
- פותח Port על כל Node (30000-32767)
- נגיש מבחוץ דרך `<NodeIP>:<NodePort>`
- שימוש: Dev/Testing, או כשאין Cloud LB

```yaml
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: 8080
    nodePort: 30080  # אופציונלי, אחרת אוטומטי
```

**⚠️ חסרונות NodePort:**
- צריך לדעת IP של Node
- Port בטווח מוגבל
- לא recommended ל-Production

**3. LoadBalancer**
- יוצר Cloud Load Balancer (ALB/NLB)
- מקבל External IP
- שימוש: Production

```yaml
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 8080
```

**4. ExternalName**
- DNS CNAME record
- מפנה לשירות חיצוני
- שימוש: גישה לשירות מחוץ לקלאסטר

```yaml
spec:
  type: ExternalName
  externalName: my.database.example.com
```

---

### Service Account

**מה זה:** זהות עבור Pods (לא בני אדם).

**שימושים:**
- גישה ל-Kubernetes API
- RBAC permissions
- קישור ל-AWS IAM (IRSA)

**דוגמה:**
```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-app-sa
---
# Pod שמשתמש ב-SA
spec:
  serviceAccountName: my-app-sa
```

---

### StatefulSet

**מה זה:** כמו Deployment אבל ל-Stateful apps.

**הבדלים מ-Deployment:**

| מאפיין | Deployment | StatefulSet |
|--------|------------|-------------|
| שמות Pods | רנדומלי (abc123) | סדרתי (pod-0, pod-1) |
| סדר יצירה | מקבילי | סדרתי |
| PVC | משותף | לכל Pod בנפרד |
| DNS | Service | Pod-specific |

**שימושים:**
- Databases (MySQL, PostgreSQL)
- Message queues (Kafka, RabbitMQ)
- Distributed systems (Elasticsearch)

---

### Taints & Tolerations

**Taint (על Node):**
"אל תשים עלי Pods (אלא אם יש להם Toleration)"

```bash
kubectl taint nodes node1 gpu=true:NoSchedule
```

**Toleration (על Pod):**
"אני יכול לרוץ על Node עם Taint"

```yaml
tolerations:
- key: "gpu"
  operator: "Equal"
  value: "true"
  effect: "NoSchedule"
```

**Effects:**
| Effect | התנהגות |
|--------|---------|
| NoSchedule | לא ישים Pods חדשים |
| PreferNoSchedule | ינסה לא לשים |
| NoExecute | יסיר Pods קיימים! |

---

## 🔧 CI/CD & DevOps Tools

---

### Artifact

**מה זה:** תוצר של תהליך Build.

**דוגמאות:**
- Docker Image
- JAR/WAR file
- Compiled binary
- npm package
- Test reports
- Helm chart

**איפה שומרים:**
- Docker Registry (ECR, Docker Hub)
- Artifactory / Nexus
- S3
- GitHub Packages

---

### CI vs CD

| מונח | משמעות | מה כולל |
|------|--------|---------|
| **CI** | Continuous Integration | Build, Test, Lint על כל commit |
| **CD** | Continuous Delivery | פריסה אוטומטית לסביבות |

**שלבי Pipeline מלא:**
```
1. Source     ← Code checkout
2. Build      ← Compile, npm install
3. Test       ← Unit, Integration
4. Security   ← SAST, Dependency scan
5. Package    ← Docker build
6. Deploy     ← Push to environment
7. Verify     ← Health checks
```

---

### GitHub Actions vs Jenkins

| מאפיין | GitHub Actions | Jenkins |
|--------|----------------|---------|
| סוג | SaaS (מנוהל) | Self-hosted |
| תחזוקה | GitHub | אתה |
| קובץ | YAML | Groovy |
| Marketplace | Actions | Plugins |
| עלות | דקות חינם + תשלום | חינם + שרתים |
| למידה | קל | מורכב יותר |
| גמישות | טובה | מקסימלית |

---

### Helm

**מה זה:** Package Manager לקוברנטיס.

**למה צריך:**
- Templating - YAMLים דינמיים
- Packaging - חבילות מוכנות (nginx, mysql)
- Versioning - גרסאות
- Rollback - חזרה לגרסה קודמת

**מבנה Chart:**
```
mychart/
├── Chart.yaml      # Metadata
├── values.yaml     # Default values
├── templates/
│   ├── deployment.yaml
│   ├── service.yaml
│   └── _helpers.tpl  # Functions
└── charts/         # Dependencies
```

**פקודות:**
```bash
helm install myapp ./mychart
helm upgrade myapp ./mychart
helm rollback myapp 1
helm uninstall myapp
helm lint ./mychart
```

**helm lint:** בודק תקינות Chart

**_helpers.tpl:** קובץ עם functions לשימוש חוזר

---

### Terraform

**מושגים:**

| מושג | הסבר |
|------|------|
| **State** | קובץ שמתעד מצב נוכחי |
| **Drift** | פער בין State לאמת |
| **Plan** | מראה מה ישתנה |
| **Apply** | מבצע שינויים |
| **Module** | קוד לשימוש חוזר |
| **Workspace** | States נפרדים |

**איפה לשמור State?**
Remote Backend (S3 + DynamoDB)
- שיתוף צוות
- Locking
- גיבוי
- לא ב-Git!

**terraform validate:** בודק syntax (לא מול הענן)

**שינוי שם Bucket:** ימחק וייצור חדש! (immutable)

---

## 📊 Monitoring

---

### Prometheus

**מה זה:** מערכת Monitoring ואיסוף Metrics.

**מאפיינים:**
- Pull-based (מושך metrics מכל target)
- Time-series database
- PromQL (שפת שאילתות)
- AlertManager לnרשות

**דוגמת PromQL:**
```
# CPU usage
rate(container_cpu_usage_seconds_total[5m])

# Memory
container_memory_usage_bytes
```

---

### Grafana

**מה זה:** כלי Visualization.

**מאפיינים:**
- Dashboards יפים
- מתחבר להרבה data sources
- Alerting
- Open source

---

### NGINX

**מה זה:** Web server רב-תכליתי.

**תפקידים:**
| תפקיד | הסבר |
|-------|------|
| Web Server | מגיש קבצים סטטיים |
| Reverse Proxy | מעביר ל-backend |
| Load Balancer | מפזר עומסים |
| Ingress Controller | בקוברנטיס |

---

## 🎯 תרחישים מלאים

---

### תרחיש: הקמת אתר E-Commerce

**שאלות לשאול:**

1. **גאוגרפיה**
   - ישראל בלבד → Region il-central-1
   - גלובלי → CloudFront

2. **עדכניות מוצרים**
   - לעיתים רחוקות → Redis caching
   - תכופות → פחות cache, יותר DB reads

3. **כמות כניסות**
   - לפי זה: sizing של instances ו-DB
   - Auto Scaling policies

**ארכיטקטורה:**
```
Users → CloudFront → ALB → EKS/EC2 (ASG)
                          ↓
                    RDS Aurora + ElastiCache
```

---

### תרחיש: קמפיין חגים (10K→40K)

**בעיה:** עומס צפוי x4

**פתרון:**

1. **Auto Scaling**
   - Target: CPU 70%
   - Max instances מספיק גבוה

2. **Database**
   - Read Replicas
   - Connection pooling

3. **Caching**
   - Redis/ElastiCache
   - CloudFront TTL

4. **Pre-warming**
   - הגדל capacity מראש
   - Load testing

---

### תרחיש: שדרוג K8s Cluster

**שלבים:**

1. **Control Plane קודם**
   - חייב להיות ≤2 versions מ-Workers
   - AWS EKS עושה אוטומטי

2. **בדיקה**
   ```bash
   kubectl get nodes
   kubectl get pods --all-namespaces
   ```

3. **Worker Nodes**
   - אחד-אחד
   - drain → upgrade → uncordon

4. **חזור על התהליך**
   - Max 2 minor versions בפעם

---

### תרחיש: Pods ב-ERROR

**שלב 1 - High Level:**
```bash
kubectl describe pod <name>
```
בודק: Events, Conditions, State

**שלב 2 - Application Level:**
```bash
kubectl logs <name>
kubectl logs <name> --previous  # אם קרס
```

**סיבות נפוצות:**

| Status | סיבה | פתרון |
|--------|------|-------|
| ImagePullBackOff | אין גישה ל-Registry | בדוק credentials |
| CrashLoopBackOff | App קורס | בדוק logs |
| OOMKilled | חוסר זיכרון | הגדל limits |
| Pending | אין resources | הוסף Nodes |

---

### תרחיש: Traffic ALB → K8s

**ברמת ALB:**
- Public Subnet
- SG: Inbound 80, 443 from 0.0.0.0/0
- Redirect HTTP → HTTPS
- Optional: WAF

**ברמת K8s:**
- SG Referencing (רק ALB SG)
- Ingress resource
- Ingress Controller (NGINX)

---

### תרחיש: K8s בלי אינטרנט

**בעיות:**
- לא יכול Pull images
- לא יכול להתקין packages

**פתרונות:**
1. **Private Registry**
   - ECR + VPC Endpoints
   
2. **Golden AMI**
   - Images מותקנים מראש
   
3. **Private Link**
   - Interface Endpoints לשירותי AWS

---

### תרחיש: DB Scaling ללא Downtime

**Aurora:**
- Auto Scaling אוטומטי
- Cross-Region reads

**RDS - Vertical:**
1. צור Standby ב-AZ אחר
2. Modify את ה-Standby (הוסף resources)
3. Failover (30-60 שניות)

**RDS - Horizontal:**
1. הוסף Read Replicas
2. Application routing:
   - SELECT → Replicas
   - INSERT/UPDATE → Master

**טיפ:** RDS Proxy מחזיק connections בזמן failover

---

**טיפ אחרון לראיון:**
אל תפחד להגיד "אני לא יודע".
עדיף להגיד "אני לא בטוח, אבל הייתי בודק ככה..." מאשר להמציא תשובה.

---

**בהצלחה בראיון!** 🚀

</div>
